Checking GDAL in Scala

- I've placed the gdal-2.21.jar in the lib directory of the DeepLearning Scala project and hope to get the functionality of the GDAL, OGR and OSR libraries in Scala. 


- The main aim is to check if I can make the code from Chris Garrard (Geoprocessing with Python, 2015) work in Scala too.

_________________________________



scala> import org.gdal._
import org.gdal._

scala> org.gdal.
gdal   gdalconst   gnm   ogr   osr

scala> org.gdal.ogr.
DataSource    FieldDefn       ProgressCallback       ogrConstants   
Driver        GeomFieldDefn   StyleTable             ogrJNI         
Feature       Geometry        TermProgressCallback                  
FeatureDefn   Layer           ogr          

scala> org.gdal.gdal.
AsyncReader            GridOptions            Transformer              
Band                   InfoOptions            TranslateOptions         
BuildVRTOptions        MajorObject            VectorTranslateOptions   
ColorTable             NearblackOptions       WarpOptions              
DEMProcessingOptions   ProgressCallback       XMLNode                  
Dataset                RasterAttributeTable   XMLNodeType              
Driver                 RasterizeOptions       gdal                     
GCP                    TermProgressCallback   gdalJNI                  

cala> org.gdal.osr.
CoordinateTransformation   SpatialReference   osr   osrConstants   osrJNI


__________________________________________

A) Background on geoprocessing: Introduction (from C.Garrard, 2015)

1) Types of spatial data

- vector data 
- raster data

Vector data is made up of points, lines and polygons.
Raster data is a two- or three-dimensional array of data values.

The features on a map are items of interest like e.g. roads, country boundaries, weather stations, etc..  Features have attributes attached to them such as name and recorded variables. Using digital data, has the advantage of attaching multiple attribute values to each feature, whether you plan to display the information on a map or analyse the data.

Spatial overlay analyses are easy using vactor data.

Raster data is well suited to any continuous data (e.g. aerial photos, satellite imagery). A grid of values can capture local variation more easily (e.g. temperature, rainfall, elevation - in Digital Elevation Models DEMs, vegetation mapping). 
Blocks of adjacent pixels can be used to calculate useful information like the slope from DEMs, which can be further used to estimate the runoff. This type of information gaining is done using windows (sets of pixels, for which we find the variable we want for the central pixel). You move a window around a raster so each pixel is in the center of its own window. 

Vector and raster data can also be used together.  
   

GEOPROCESSING IS A GENERAL TERM FOR MANIPULATING SPATIAL DATA (WHETHER RASTER OR VECTOR DATA). 

Simple vector geoprocessing: overlay and proximity analyses.
Simple raster geoprocessing: resizing pixels, performing calculations based on multiple datasets, moving windows analyses.

Using a programming language allows you to customize your analysis instead of being limited to what the software user interface allows. Also, it allows you to process many datasets at once. 

Free and open source software is not only free with regard to price but allows for customization. You don't give up quality by using open source tools. In fact several of these packages are also used by proprietary software. 


B) Background on geoprocessing: Reading and writing vector data (from C.Garrard, 2015)

The types of data, where the features of interest are all distinct objects, are called vector datasets.
For manipulating vector datasets we will use the OGR library (to read, writem and edit these types for later use).

VECTOR DATA ARE DATA IN WHICH THE FEATURES OF INTEREST ARE REPRESENTED AS DISCRETE GEOMETRIES (POINTS, LINES, AND POLYGONS). Such features have distinct boundaries, but countinuous data such as elevetion don't. For example, polygons showing subalpine zones for a region would be a good proxy for an elevation range, but you lose much of the detailed elevation data within those polygons. Vector data candidates are for example roads, power lines, rivers, lakes, landownerships,counties and countries, cities, restaurants, mountain peaks, etc..

Vector data is more than geometries however. Each one of these features also has associated attributes. These attributes can be of various types. They can be numeric variables or categorical variables (strings). 

 VECTOR DATA ALWAYS LOOKS SMOOTH, NO MATTER THE SCALE (CONTRARY TO RASTER DATA). 
Only the type of geometry used to represent the features of interest may vary depending on scale (e.g. point for a city for low resolution, and polygon for high-resolution -> the higher the resolution the more detail can be shown). 

One common type of vector data analysis is to measure relationships between features, typically by overlapping them on one another to determine their spatial relationship. Another aspect of spatial relationships is the distance between two features. You can use GPS-collared wildlife and see the direction of travel, what travel distances they covered and how they interact with man-made features such as roads. Shapefiles are a popular format for sotring vector data. A shapefile isn't made of a single file however. This format requires a minimum of three binary files, each of which serves a different purpose:
- geometry information is stored in .shp and .shx files, and attribute values are stored in a .dbf file. You need to make sure that they are all kept in the same folder! 

Another widely used format, esp. for web-mapping applications is GeoJSON. These are plain text files that you can open up and look at in any text editor. Unlike a shapefile, a GeoJSON dataset consists of one file that stores all required information. 

Vector data sets can also be stored in relational databases. The two most popular spatial extensions for database systems are PostGIS (extension on top of PostgreSQL) and SpatialLite (works with SQLite databases). Another popular database format is the Esri file geodatabase. 

1) Introduction OGR

The OGR Simple Features Library is part of the Geospatial Data Abstraction Library (GDAL), an extremely popular open source library for reading and writing spatial data. The OGR part of GDAL is the one that provides the ability to read and write many different vector data formats. OGR also allows you to create and manipulate geometries; edit attribute values; filter vector data based on attribute values or spatial location; and it offers data analysis capabilities. 
The GDAL library was originally written in C and C++ and has bindings for several other languages. 

THE OGR CLASS STRUCTURE:

Spatial vector data is stored in a DATA SOURCE object (the shapefile, GeoJSON file, SpatiaLite, or PostGIS database, a.o.). This data source object can have one or more LAYERS, one for each dataset contained in the data source. Many vector formats, such as shapefiles can only contain one dataset, but others like SpatiLite can contain multiple datasets. ONE DATASET -> ONE LAYER. 

Each layer contains a collection of FEATURES, that holds the geometries and their attributes. ONE DATASET -> ONE LAYER -> GEOMETRIES AND ATTRIBUTES OF THE FEATURES. 	

The first step to accessing any vector data is to open the data source. For this you need to have an appropriate DRIVER that tells OGR how to work with your data format. EACH VECTOR FORMAT HAS ITS OWN DRIVER. YOU USE THAT DRIVER TO READ AND WRITE A PARTICULAR FORMAT. 

 
IMPLEMENTING the ogr.getDriverByName(string) function:

examples: 
ogr.getDriverByName("geojson")
org.getDriverByName("ESRI shapefile")


When implementing the Java method in Scala I get an exception:
scala>  val driver = org.gdal.ogr.ogrJNI.GetDriverByName("ESRI Shapefile")
java.lang.UnsatisfiedLinkError: org.gdal.ogr.ogrJNI.GetDriverByName(Ljava/lang/String;)J
  at org.gdal.ogr.ogrJNI.GetDriverByName(Native Method)
  ... 42 elided

I will get the code of Rob Emanuele (https://github.com/geotrellis/gdal-scala/blob/master/gdal/src/main/scala/org/gdal/scala/Gdal.scala) to get around that exception. 
I still have to use the function though. 
I will set the Java options for sbt.


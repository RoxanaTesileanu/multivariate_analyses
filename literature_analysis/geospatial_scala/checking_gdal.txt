Checking GDAL in Scala
Author: Roxana Tesileanu, INCDS, roxana.te@web.de

- I've placed the gdal-2.21.jar in the lib directory of the DeepLearning Scala project and hope to get the functionality of the GDAL, OGR and OSR libraries in Scala. 


- The main aim is to check if I can make the code from Chris Garrard (Geoprocessing with Python, 2015) work in Scala too.

_________________________________



scala> import org.gdal._
import org.gdal._

scala> org.gdal.
gdal   gdalconst   gnm   ogr   osr

scala> org.gdal.ogr.
DataSource    FieldDefn       ProgressCallback       ogrConstants   
Driver        GeomFieldDefn   StyleTable             ogrJNI         
Feature       Geometry        TermProgressCallback                  
FeatureDefn   Layer           ogr          

scala> org.gdal.gdal.
AsyncReader            GridOptions            Transformer              
Band                   InfoOptions            TranslateOptions         
BuildVRTOptions        MajorObject            VectorTranslateOptions   
ColorTable             NearblackOptions       WarpOptions              
DEMProcessingOptions   ProgressCallback       XMLNode                  
Dataset                RasterAttributeTable   XMLNodeType              
Driver                 RasterizeOptions       gdal                     
GCP                    TermProgressCallback   gdalJNI                  

cala> org.gdal.osr.
CoordinateTransformation   SpatialReference   osr   osrConstants   osrJNI


__________________________________________

A) Background on geoprocessing: Introduction (from C.Garrard, 2015)

1) Types of spatial data

- vector data 
- raster data

Vector data is made up of points, lines and polygons.
Raster data is a two- or three-dimensional array of data values.

The features on a map are items of interest like e.g. roads, country boundaries, weather stations, etc..  Features have attributes attached to them such as name and recorded variables. Using digital data, has the advantage of attaching multiple attribute values to each feature, whether you plan to display the information on a map or analyse the data.

Spatial overlay analyses are easy using vactor data.

Raster data is well suited to any continuous data (e.g. aerial photos, satellite imagery). A grid of values can capture local variation more easily (e.g. temperature, rainfall, elevation - in Digital Elevation Models DEMs, vegetation mapping). 
Blocks of adjacent pixels can be used to calculate useful information like the slope from DEMs, which can be further used to estimate the runoff. This type of information gaining is done using windows (sets of pixels, for which we find the variable we want for the central pixel). You move a window around a raster so each pixel is in the center of its own window. 

Vector and raster data can also be used together.  
   

GEOPROCESSING IS A GENERAL TERM FOR MANIPULATING SPATIAL DATA (WHETHER RASTER OR VECTOR DATA). 

Simple vector geoprocessing: overlay and proximity analyses.
Simple raster geoprocessing: resizing pixels, performing calculations based on multiple datasets, moving windows analyses.

Using a programming language allows you to customize your analysis instead of being limited to what the software user interface allows. Also, it allows you to process many datasets at once. 

Free and open source software is not only free with regard to price but allows for customization. You don't give up quality by using open source tools. In fact several of these packages are also used by proprietary software. 


B) Background on geoprocessing: Reading and writing vector data (from C.Garrard, 2015)

The types of data, where the features of interest are all distinct objects, are called vector datasets.
For manipulating vector datasets we will use the OGR library (to read, writem and edit these types for later use).

VECTOR DATA ARE DATA IN WHICH THE FEATURES OF INTEREST ARE REPRESENTED AS DISCRETE GEOMETRIES (POINTS, LINES, AND POLYGONS). Such features have distinct boundaries, but countinuous data such as elevetion don't. For example, polygons showing subalpine zones for a region would be a good proxy for an elevation range, but you lose much of the detailed elevation data within those polygons. Vector data candidates are for example roads, power lines, rivers, lakes, landownerships,counties and countries, cities, restaurants, mountain peaks, etc..

Vector data is more than geometries however. Each one of these features also has associated attributes. These attributes can be of various types. They can be numeric variables or categorical variables (strings). 

 VECTOR DATA ALWAYS LOOKS SMOOTH, NO MATTER THE SCALE (CONTRARY TO RASTER DATA). 
Only the type of geometry used to represent the features of interest may vary depending on scale (e.g. point for a city for low resolution, and polygon for high-resolution -> the higher the resolution the more detail can be shown). 

One common type of vector data analysis is to measure relationships between features, typically by overlapping them on one another to determine their spatial relationship. Another aspect of spatial relationships is the distance between two features. You can use GPS-collared wildlife and see the direction of travel, what travel distances they covered and how they interact with man-made features such as roads. Shapefiles are a popular format for sotring vector data. A shapefile isn't made of a single file however. This format requires a minimum of three binary files, each of which serves a different purpose:
- geometry information is stored in .shp and .shx files, and attribute values are stored in a .dbf file. You need to make sure that they are all kept in the same folder! 

Another widely used format, esp. for web-mapping applications is GeoJSON. These are plain text files that you can open up and look at in any text editor. Unlike a shapefile, a GeoJSON dataset consists of one file that stores all required information. 

Vector data sets can also be stored in relational databases. The two most popular spatial extensions for database systems are PostGIS (extension on top of PostgreSQL) and SpatialLite (works with SQLite databases). Another popular database format is the Esri file geodatabase. 

1) Introduction OGR

The OGR Simple Features Library is part of the Geospatial Data Abstraction Library (GDAL), an extremely popular open source library for reading and writing spatial data. The OGR part of GDAL is the one that provides the ability to read and write many different vector data formats. OGR also allows you to create and manipulate geometries; edit attribute values; filter vector data based on attribute values or spatial location; and it offers data analysis capabilities. 
The GDAL library was originally written in C and C++ and has bindings for several other languages. 

THE OGR CLASS STRUCTURE:

Spatial vector data is stored in a DATA SOURCE object (the shapefile, GeoJSON file, SpatiaLite, or PostGIS database, a.o.). This data source object can have one or more LAYERS, one for each dataset contained in the data source. Many vector formats, such as shapefiles can only contain one dataset, but others like SpatiLite can contain multiple datasets. ONE DATASET -> ONE LAYER. 

Each layer contains a collection of FEATURES, that holds the geometries and their attributes. ONE DATASET -> ONE LAYER -> GEOMETRIES AND ATTRIBUTES OF THE FEATURES. 	

The first step to accessing any vector data is to open the data source. For this you need to have an appropriate DRIVER that tells OGR how to work with your data format. EACH VECTOR FORMAT HAS ITS OWN DRIVER. YOU USE THAT DRIVER TO READ AND WRITE A PARTICULAR FORMAT. 

 
IMPLEMENTING the ogr.getDriverByName(string) function:

examples: 
ogr.getDriverByName("geojson")
org.getDriverByName("ESRI shapefile")


When implementing the Java method in Scala I get an exception:
scala>  val driver = org.gdal.ogr.ogrJNI.GetDriverByName("ESRI Shapefile")
java.lang.UnsatisfiedLinkError: org.gdal.ogr.ogrJNI.GetDriverByName(Ljava/lang/String;)J
  at org.gdal.ogr.ogrJNI.GetDriverByName(Native Method)
  ... 42 elided

I will get the code of Rob Emanuele (https://github.com/geotrellis/gdal-scala/blob/master/gdal/src/main/scala/org/gdal/scala/Gdal.scala) to get around that exception. 
I still have to use the function though. 
I will set the Java options for sbt.
One fact is certain, I have to install the Java bindings for GDAl, which is done with "$sudo apt-get install libgdal-java" (necessary packages: libproj-dev, gdal-bin, libgdal-dev, libgdal-doc) (see https://packages.ubuntu.com/source/trusty/gdal). 

AND THE RESULT OF ALL THIS IS: 

scala> org.gdal.ogr.ogrJNI.GetDriverByName("ESRI Shapefile")
res0: Long = 0

scala> org.gdal.ogr.ogrJNI.GetDriverByName("GeoJSON")
res1: Long = 0

scala> val ds = ogr.Open("sal_alk_eu27_laea1052.shp", 1)
ds: org.gdal.ogr.DataSource = null
________________________________________________


THE WORKING CODE FOR A NON-EMPTY DATASOURCE IS:

scala> org.gdal.ogr.ogr.RegisterAll()

scala> org.gdal.ogr.ogr.Open("example.shp")
res1: org.gdal.ogr.DataSource = org.gdal.ogr.DataSource@305c6b70

scala> res1.
CommitTransaction   GetLayerCount           SetDescription     
CopyLayer           GetMetadataDomainList   SetMetadata        
CreateLayer         GetMetadataItem         SetMetadataItem    
DeleteLayer         GetMetadata_Dict        SetStyleTable      
ExecuteSQL          GetMetadata_List        StartTransaction   
FlushCache          GetName                 SyncToDisk         
GetDescription      GetRefCount             TestCapability     
GetDriver           GetStyleTable           delete             
GetLayer            GetSummaryRefCount      equals             
GetLayerByIndex     ReleaseResultSet        getName            
GetLayerByName      RollbackTransaction     hashCode           

scala> res1.GetLayerCount
res2: Int = 1

scala> val lyr = res1.GetLayer(0)
lyr: org.gdal.ogr.Layer = org.gdal.ogr.Layer@305ca330

cala> lyr.
AlterFieldDefn      GetMetadataDomainList   SetIgnoredFields       
Clip                GetMetadataItem         SetMetadata            
CommitTransaction   GetMetadata_Dict        SetMetadataItem        
CreateFeature       GetMetadata_List        SetNextByIndex         
CreateField         GetName                 SetSpatialFilter       
CreateGeomField     GetNextFeature          SetSpatialFilterRect   
DeleteFeature       GetRefCount             SetStyleTable          
DeleteField         GetSpatialFilter        StartTransaction       
Erase               GetSpatialRef           SymDifference          
FindFieldIndex      GetStyleTable           SyncToDisk             
GetDescription      Identity                TestCapability         
GetExtent           Intersection            Union                  
GetFIDColumn        ReorderField            Update                 
GetFeature          ReorderFields           addReference           
GetFeatureCount     ResetReading            delete                 
GetFeaturesRead     RollbackTransaction     equals                 
GetGeomType         SetAttributeFilter      hashCode               
GetGeometryColumn   SetDescription                                 
GetLayerDefn        SetFeature                                     

scala> lyr.GetName
res3: String = example

cala> lyr.GetFeatureCount
res4: Long = 927

scala> lyr.GetSpatialRef
res5: org.gdal.osr.SpatialReference = null

cala> val feat0 = lyr.GetFeature(0)
feat0: org.gdal.ogr.Feature = org.gdal.ogr.Feature@3164b9a0

scala> feat0.
Clone                   GetFieldType                  SetFieldNull           
DumpReadable            GetGeomFieldCount             SetFieldStringList     
Equal                   GetGeomFieldDefnRef           SetFrom                
FillUnsetWithDefault    GetGeomFieldIndex             SetFromWithMap         
GetDefnRef              GetGeomFieldRef               SetGeomField           
GetFID                  GetGeometryRef                SetGeomFieldDirectly   
GetFieldAsBinary        GetNativeData                 SetGeometry            
GetFieldAsDateTime      GetNativeMediaType            SetGeometryDirectly    
GetFieldAsDouble        GetStyleString                SetNativeData          
GetFieldAsDoubleList    IsFieldNull                   SetNativeMediaType     
GetFieldAsInteger       IsFieldSet                    SetStyleString         
GetFieldAsInteger64     IsFieldSetAndNotNull          UnsetField             
GetFieldAsIntegerList   SetFID                        Validate               
GetFieldAsString        SetField                      clone                  
GetFieldAsStringList    SetFieldBinaryFromHexString   delete                 
GetFieldCount           SetFieldDoubleList            equals                 
GetFieldDefnRef         SetFieldInteger64             hashCode               
GetFieldIndex           SetFieldIntegerList                                  


cala> res1.delete()

DON'T FORGET TO CLOSE THE DATA SOURCE WITH ds.delete()!!!

___________________________________________

Checking OSR

scala> lyr.GetSpatialRef
res10: org.gdal.osr.SpatialReference =
GEOGCS["GCS_WGS_1984",
    DATUM["WGS_1984",
        SPHEROID["WGS_84",6378137,298.257223563]],
    PRIMEM["Greenwich",0],
    UNIT["Degree",0.017453292519943295],
    AUTHORITY["EPSG","4326"]]


__________________________________________

Creating SpatialReference objects: I will use the ETRS-LAEASRS as it is the single CRS for all Europe and is used for statistical mapping at all scales and other purposes where true area representation is required.

http://spatialreference.org/ref/epsg/3035/


scala> org.gdal.ogr.ogr.RegisterAll()

scala> val ds = org.gdal.ogr.ogr.Open("sal_alk_eu27_laea1052.shp")
ds: org.gdal.ogr.DataSource = org.gdal.ogr.DataSource@68b12470

scala> val lyr = ds.GetLayer(0)
lyr: org.gdal.ogr.Layer = org.gdal.ogr.Layer@68b12de0

scala> lyr.GetSpatialRef
res1: org.gdal.osr.SpatialReference =
PROJCS["ETRS_1989_LAEA",
    GEOGCS["GCS_ETRS_1989",
        DATUM["European_Terrestrial_Reference_System_1989",
            SPHEROID["GRS_1980",6378137.0,298.257222101]],
        PRIMEM["Greenwich",0.0],
        UNIT["Degree",0.0174532925199433]],
    PROJECTION["Lambert_Azimuthal_Equal_Area"],
    PARAMETER["False_Easting",4321000.0],
    PARAMETER["False_Northing",3210000.0],
    PARAMETER["longitude_of_center",10.0],
    PARAMETER["latitude_of_center",52.0],
    UNIT["Meter",1.0]]

scala> val newSR = org.gdal.osr.SpatialReference
<console>:11: error: object org.gdal.osr.SpatialReference is not a value
       val newSR = org.gdal.osr.SpatialReference
                                ^

scala> val newSR = org.gdal.osr.SpatialReference()
<console>:11: error: object org.gdal.osr.SpatialReference is not a value
       val newSR = org.gdal.osr.SpatialReference()
                                ^

scala> val newSR = org.gdal.osr.SpatialReference.getCPtr
   def getCPtr(x$1: org.gdal.osr.SpatialReference): Long

scala> val newSR = org.gdal.osr.
CoordinateTransformation   SpatialReference   osr   osrConstants   osrJNI

scala> val newSR = org.gdal.osr.SpatialReference
   object SpatialReference

scala> val newSR = org.gdal.osr.SpatialReference
<console>:11: error: object org.gdal.osr.SpatialReference is not a value
       val newSR = org.gdal.osr.SpatialReference
                                ^

scala> val newSR = org.gdal.osr.SpatialReference()
<console>:11: error: object org.gdal.osr.SpatialReference is not a value
       val newSR = org.gdal.osr.SpatialReference()
                                ^

scala> val newSR = new org.gdal.osr.SpatialReference()
newSR: org.gdal.osr.SpatialReference =

scala> newSR.
AutoIdentifyEPSG              SetCS                               
Clone                         SetCompoundCS                       
CloneGeogCS                   SetEC                               
CopyGeogCSFrom                SetEckertIV                         
EPSGTreatsAsLatLong           SetEckertVI                         
EPSGTreatsAsNorthingEasting   SetEquirectangular                  
ExportToMICoordSys            SetEquirectangular2                 
ExportToPCI                   SetFromUserInput                    
ExportToPrettyWkt             SetGEOS                             
ExportToProj4                 SetGH                               
ExportToUSGS                  SetGS                               
ExportToWkt                   SetGaussSchreiberTMercator          
ExportToXML                   SetGeocCS                           
Fixup                         SetGeogCS                           
FixupOrdering                 SetGnomonic                         
GetAngularUnits               SetHOM                              
GetAngularUnitsName           SetHOM2PNO                          
GetAttrValue                  SetIGH                              
GetAuthorityCode              SetKrovak                           
GetAuthorityName              SetLAEA                             
GetAxisName                   SetLCC                              
GetAxisOrientation            SetLCC1SP                           
GetInvFlattening              SetLCCB                             
GetLinearUnits                SetLinearUnits                      
GetLinearUnitsName            SetLinearUnitsAndUpdateParameters   
GetNormProjParm               SetLocalCS                          
GetProjParm                   SetMC                               
GetSemiMajor                  SetMercator                         
GetSemiMinor                  SetMollweide                        
GetTOWGS84                    SetNZMG                             
GetTargetLinearUnits          SetNormProjParm                     
GetUTMZone                    SetOS                               
ImportFromEPSG                SetOrthographic                     
ImportFromEPSGA               SetPS                               
ImportFromERM                 SetPolyconic                        
ImportFromESRI                SetProjCS                           
ImportFromMICoordSys          SetProjParm                         
ImportFromOzi                 SetProjection                       
ImportFromPCI                 SetRobinson                         
ImportFromProj4               SetSOC                              
ImportFromUSGS                SetSinusoidal                       
ImportFromUrl                 SetStatePlane                       
ImportFromWkt                 SetStereographic                    
ImportFromXML                 SetTM                               
IsCompound                    SetTMG                              
IsGeocentric                  SetTMSO                             
IsGeographic                  SetTMVariant                        
IsLocal                       SetTOWGS84                          
IsProjected                   SetTargetLinearUnits                
IsSame                        SetUTM                              
IsSameGeogCS                  SetVDG                              
IsSameVertCS                  SetVertCS                           
IsVertical                    SetWellKnownGeogCS                  
MorphFromESRI                 StripCTParms                        
MorphToESRI                   Validate                            
SetACEA                       __str__                             
SetAE                         clone                               
SetAngularUnits               delete                              
SetAttrValue                  equals                              
SetAuthority                  hashCode                            
SetBonne                      toString                            
SetCEA            

cala> newSR.ImportFrom
ImportFromEPSG    ImportFromESRI         ImportFromPCI     ImportFromUrl   
ImportFromEPSGA   ImportFromMICoordSys   ImportFromProj4   ImportFromWkt   
ImportFromERM     ImportFromOzi          ImportFromUSGS    ImportFromXML   

scala> newSR.ImportFromEPSG(3035)
res2: Int = 0

scala> newSR
res3: org.gdal.osr.SpatialReference =
PROJCS["ETRS89 / LAEA Europe",
    GEOGCS["ETRS89",
        DATUM["European_Terrestrial_Reference_System_1989",
            SPHEROID["GRS 1980",6378137,298.257222101,
                AUTHORITY["EPSG","7019"]],
            TOWGS84[0,0,0,0,0,0,0],
            AUTHORITY["EPSG","6258"]],
        PRIMEM["Greenwich",0,
            AUTHORITY["EPSG","8901"]],
        UNIT["degree",0.0174532925199433,
            AUTHORITY["EPSG","9122"]],
        AUTHORITY["EPSG","4258"]],
    PROJECTION["Lambert_Azimuthal_Equal_Area"],
    PARAMETER["latitude_of_center",52],
    PARAMETER["longitude_of_center",10],
    PARAMETER["false_easting",4321000],
    PARAMETER["false_northing",3210000],
    UNIT["metre",1,
        AUTHORITY["EPSG","9001"]],
    AUTHORITY["EPSG","30...

scala> val newSR2 = new org.gdal.osr.SpatialReference()
newSR2: org.gdal.osr.SpatialReference =

scala> newSR2.ImportFromURL("http://spatialreference.org/ref/epsg/3035/proj4/")
<console>:13: error: value ImportFromURL is not a member of org.gdal.osr.SpatialReference
       newSR2.ImportFromURL("http://spatialreference.org/ref/epsg/3035/proj4/")
              ^

scala> newSR2.ImportFrom
ImportFromEPSG    ImportFromESRI         ImportFromPCI     ImportFromUrl   
ImportFromEPSGA   ImportFromMICoordSys   ImportFromProj4   ImportFromWkt   
ImportFromERM     ImportFromOzi          ImportFromUSGS    ImportFromXML   

scala> newSR2.ImportFromProj4("+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ")
res6: Int = 0

scala> newSR2
res7: org.gdal.osr.SpatialReference =
PROJCS["unnamed",
    GEOGCS["GRS 1980(IUGG, 1980)",
        DATUM["unknown",
            SPHEROID["GRS80",6378137,298.257222101]],
        PRIMEM["Greenwich",0],
        UNIT["degree",0.0174532925199433]],
    PROJECTION["Lambert_Azimuthal_Equal_Area"],
    PARAMETER["latitude_of_center",52],
    PARAMETER["longitude_of_center",10],
    PARAMETER["false_easting",4321000],
    PARAMETER["false_northing",3210000],
    UNIT["Meter",1]]

cala> newSR3.ImportFromWkt("""PROJCS["ETRS89 / ETRS-LAEA",
     |     GEOGCS["ETRS89",
     |         DATUM["European_Terrestrial_Reference_System_1989",
     |             SPHEROID["GRS 1980",6378137,298.257222101,
     |                 AUTHORITY["EPSG","7019"]],
     |             AUTHORITY["EPSG","6258"]],
     |         PRIMEM["Greenwich",0,
     |             AUTHORITY["EPSG","8901"]],
     |         UNIT["degree",0.01745329251994328,
     |             AUTHORITY["EPSG","9122"]],
     |         AUTHORITY["EPSG","4258"]],
     |     UNIT["metre",1,
     |         AUTHORITY["EPSG","9001"]],
     |     PROJECTION["Lambert_Azimuthal_Equal_Area"],
     |     PARAMETER["latitude_of_center",52],
     |     PARAMETER["longitude_of_center",10],
     |     PARAMETER["false_easting",4321000],
     |     PARAMETER["false_northing",3210000],
     |     AUTHORITY["EPSG","3035"],
     |     AXIS["X",EAST],
     |     AXIS["Y",NORTH]]""")
res9: Int = 0


scala> val newSR3 = new org.gdal.osr.SpatialReference()
newSR3: org.gdal.osr.SpatialReference =

scala> newSR3.ImportFromWkt("""PROJCS["ETRS89 / ETRS-LAEA",
     |     GEOGCS["ETRS89",
     |         DATUM["European_Terrestrial_Reference_System_1989",
     |             SPHEROID["GRS 1980",6378137,298.257222101,
     |                 AUTHORITY["EPSG","7019"]],
     |             AUTHORITY["EPSG","6258"]],
     |         PRIMEM["Greenwich",0,
     |             AUTHORITY["EPSG","8901"]],
     |         UNIT["degree",0.01745329251994328,
     |             AUTHORITY["EPSG","9122"]],
     |         AUTHORITY["EPSG","4258"]],
     |     UNIT["metre",1,
     |         AUTHORITY["EPSG","9001"]],
     |     PROJECTION["Lambert_Azimuthal_Equal_Area"],
     |     PARAMETER["latitude_of_center",52],
     |     PARAMETER["longitude_of_center",10],
     |     PARAMETER["false_easting",4321000],
     |     PARAMETER["false_northing",3210000],
     |     AUTHORITY["EPSG","3035"],
     |     AXIS["X",EAST],
     |     AXIS["Y",NORTH]]""")
res9: Int = 0

scala> newSR3
res10: org.gdal.osr.SpatialReference =
PROJCS["ETRS89 / ETRS-LAEA",
    GEOGCS["ETRS89",
        DATUM["European_Terrestrial_Reference_System_1989",
            SPHEROID["GRS 1980",6378137,298.257222101,
                AUTHORITY["EPSG","7019"]],
            AUTHORITY["EPSG","6258"]],
        PRIMEM["Greenwich",0,
            AUTHORITY["EPSG","8901"]],
        UNIT["degree",0.01745329251994328,
            AUTHORITY["EPSG","9122"]],
        AUTHORITY["EPSG","4258"]],
    UNIT["metre",1,
        AUTHORITY["EPSG","9001"]],
    PROJECTION["Lambert_Azimuthal_Equal_Area"],
    PARAMETER["latitude_of_center",52],
    PARAMETER["longitude_of_center",10],
    PARAMETER["false_easting",4321000],
    PARAMETER["false_northing",3210000],
    AUTHORITY["EPSG","3035"],
    AXIS["X",EAST],
    AXIS["...
scala> 

_________________________________-

Now I will give it a try with Pulkovo 1942(58)/Stereo 70, ESPG 3844, http://spatialreference.org/ref/epsg/3844/.
Non-military large and medium scale topographic map for Romania.

scala> val roSR1 = new org.gdal.osr.SpatialReference()
roSR1: org.gdal.osr.SpatialReference =

scala> roSR1.ImportFromEPSG(3844)
res14: Int = 0

scala> roSR1
res15: org.gdal.osr.SpatialReference =
PROJCS["Pulkovo 1942(58) / Stereo70",
    GEOGCS["Pulkovo 1942(58)",
        DATUM["Pulkovo_1942_58",
            SPHEROID["Krassowsky 1940",6378245,298.3,
                AUTHORITY["EPSG","7024"]],
            TOWGS84[2.329,-147.042,-92.08,0.309,-0.325,-0.497,5.69],
            AUTHORITY["EPSG","6179"]],
        PRIMEM["Greenwich",0,
            AUTHORITY["EPSG","8901"]],
        UNIT["degree",0.0174532925199433,
            AUTHORITY["EPSG","9122"]],
        AUTHORITY["EPSG","4179"]],
    PROJECTION["Oblique_Stereographic"],
    PARAMETER["latitude_of_origin",46],
    PARAMETER["central_meridian",25],
    PARAMETER["scale_factor",0.99975],
    PARAMETER["false_easting",500000],
    PARAMETER["false_northing",500000],
    UNIT["metre",1,
        A...
cala> val roSR2 = new org.gdal.osr.SpatialReference()
roSR2: org.gdal.osr.SpatialReference =

scala> roSR2.ImportFromWkt("""PROJCS["Pulkovo 1942(58) / Stereo70",
     |     GEOGCS["Pulkovo 1942(58)",
     |         DATUM["Pulkovo 1942(58)",
     |             SPHEROID["Krassowsky 1940",6378245.0,298.3,
     |                 AUTHORITY["EPSG","7024"]],
     |             TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.17326243724756094],
     |             AUTHORITY["EPSG","6179"]],
     |         PRIMEM["Greenwich",0.0,
     |             AUTHORITY["EPSG","8901"]],
     |         UNIT["degree",0.017453292519943295],
     |         AXIS["Geodetic latitude",NORTH],
     |         AXIS["Geodetic longitude",EAST],
     |         AUTHORITY["EPSG","4179"]],
     |     PROJECTION["Oblique Stereographic",
     |         AUTHORITY["EPSG","9809"]],
     |     PARAMETER["central_meridian",25.0],
     |     PARAMETER["latitude_of_origin",46.0],
     |     PARAMETER["scale_factor",0.99975],
     |     PARAMETER["false_easting",500000.0],
     |     PARAMETER["false_northing",500000.0],
     |     UNIT["m",1.0],
     |     AXIS["Northing",NORTH],
     |     AXIS["Easting",EAST],
     |     AUTHORITY["EPSG","3844"]]""")
res16: Int = 0

scala> roSR2
res17: org.gdal.osr.SpatialReference =
PROJCS["Pulkovo 1942(58) / Stereo70",
    GEOGCS["Pulkovo 1942(58)",
        DATUM["Pulkovo 1942(58)",
            SPHEROID["Krassowsky 1940",6378245.0,298.3,
                AUTHORITY["EPSG","7024"]],
            TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.17326243724756094],
            AUTHORITY["EPSG","6179"]],
        PRIMEM["Greenwich",0.0,
            AUTHORITY["EPSG","8901"]],
        UNIT["degree",0.017453292519943295],
        AXIS["Geodetic latitude",NORTH],
        AXIS["Geodetic longitude",EAST],
        AUTHORITY["EPSG","4179"]],
    PROJECTION["Oblique Stereographic",
        AUTHORITY["EPSG","9809"]],
    PARAMETER["central_meridian",25.0],
    PARAMETER["latitude_of_origin",46.0],
    PARAMETER["scale_factor",0.99975],
  PAR...

_______________________________________-

I will construct a Polygon. I look up the points on the Internet:
45.650988, 25.581612
45.651026, 25.582142
45.650854, 25.581635
45.650801, 25.582182

myBuilding

val ring = org.Geometry(ogr.wkbLinearRing)
ring.AddPoint(45.650988, 25.581612)
ring.AddPoint(45.651026, 25.582142)
ring.AddPoint(45.650854, 25.581635)
ring.AddPoint(45.650801, 25.582182)

val building = ogr.Geometry(ogr.wkbPolygon)
building.AddGeometry(ring)
building.CloseRings()
building.IsValid
____________

NOTE: Google uses WGS 84 Web Mercator as its coordinate system !!!!!

EPSG:3857

https://en.wikipedia.org/wiki/Web_Mercator

WGS 84 / Pseudo-Mercator -- Spherical Mercator, Google Maps, OpenStreetMap, Bing, ArcGIS, ESRI

www.epsg.io/3857
WKT """PROJCS["WGS 84 / Pseudo-Mercator",
    GEOGCS["WGS 84",
        DATUM["WGS_1984",
            SPHEROID["WGS 84",6378137,298.257223563,
                AUTHORITY["EPSG","7030"]],
            AUTHORITY["EPSG","6326"]],
        PRIMEM["Greenwich",0,
            AUTHORITY["EPSG","8901"]],
        UNIT["degree",0.0174532925199433,
            AUTHORITY["EPSG","9122"]],
        AUTHORITY["EPSG","4326"]],
    PROJECTION["Mercator_1SP"],
    PARAMETER["central_meridian",0],
    PARAMETER["scale_factor",1],
    PARAMETER["false_easting",0],
    PARAMETER["false_northing",0],
    UNIT["metre",1,
        AUTHORITY["EPSG","9001"]],
    AXIS["X",EAST],
    AXIS["Y",NORTH],
    EXTENSION["PROJ4","+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"],
    AUTHORITY["EPSG","3857"]]
"""
_________________________________________________________

Creating Points:

cornerNW = 45.654542, 25.576068
cornerNE1 = 45.654689, 25.577259
cornerNE2 = 45.654599, 25.577560
cornerSE1 = 45.653862, 25.577713
cornerSE2 = 45.653530, 25.577458
cornerSW = 45.653208, 25.576524

val firstPoint = ogr.Geometry(ogr.wkbPoint)
firstPoint.AddPoint( 45.654542, 25.576068)

Creating MultiPoints (multiple points as one geometry):

val patchCorners = ogr.Geometry(ogr.wkbMultiPoint)
val corner = ogr.Geometry(ogr.wkbPoint)
corner.AddPoint( 45.654542, 25.576068)
patchCorners.AddGeometry(corner)
corner.AddPoint(45.654689, 25.577259)
patchCorners.AddGeometry(corner)
corner.AddPoint(45.654599, 25.577560)
patchCorners.AddGeometry(corner)
corner.AddPoint(45.653862, 25.577713)
patchCorners.AddGeometry(corner)
corner.AddPoint(45.653530, 25.577458)
patchCorners.AddGeometry(corner)
corner.AddPoint(45.653208, 25.576524)
patchCorners.AddGeometry(corner)
I will probably have to use vars for this. 

Def. of VERTEX: A vertex is a point where two line segments of a geometry meet.Vertices hold the coordinates of the ends of each line segment. 

Creating lines:

Lines are a sequence of vertices connected by straight line segments. 

var road1 = ogr.Geometry(ogr.wkbLineString)
road1.AddPoint(45.654919, 25.579059)
road1.AddPoint(45.653869, 25.578466)
road1.AddPoint(45.652947, 25.578791)
road1.AddPoint(45.652585, 25.578785)
road1.AddPoint(45.652553, 25.579220)
road1.AddPoint(45.651732, 25.580851)

var road2 = ogr.Geometry(ogr.wkbLineString)
road2.AddPoint(45.654859, 25.576184)
road2.AddPoint(45.653828, 25.576524)

Creating multilines (multiple lines as one geometry):
var roads = ogr.Geometry(ogr.wkbMultiLineString)
roads.addGeometry(road1)
roads.addGeometry(road2)

Creating polygons:
Polygons have an area!
Polygons are made of rings. Rings are made up of a series of vertices connected by straight line segments. The first and the last vertices of a ring are the same -> they create a closed ring. 

I've written above the code for a polygon called building. 
I will sketch the code for a habitat patch now.  
var ring=ogr.Geometry(ogr.wkbLinearRing)
I have to check if adding a MultiPoint works. 
If so: 
ring.AddGeometry(patchCorners)
val habitatPatch = ogr.Geometry(ogr.wkbPolygon)
habitatPatch.AddGeometry(ring)
habitatPatch.CloseRings()

NOTE: SHAPEFILES SPECIFY THE OUTER RING MUST BE CLOCKWISE! 

Creating multipolygons: multiple polygons as one geometry

Let's assume my building is another habitat patch. I will create a variable patches which holds the two geometries. 

var habitatPatches = ogr.Geometry(ogr.wkbMultiPolygon)
habitatPatches.AddGeometry(building)
habitatPatches.AddGeometry(habitatPatch)
habitatPatches.CloseRings()

SUMMARY:
- a geometry consists of a collection of vertices
- multigeometries consist of multiple geometries combined into one
- all polygon geometries are made up of one or more rings (donut polygons have an outer and an inner ring).
________________________________________________________

Now I will create layers with the geometries I've got.
A new layer needs: a name, a spatial reference system, a geometry type. 
You can have point layer, line layer, polygon layer and their multiple-geometry version. You can't have two types in one layer. 

val habitatPatchesLyr = ds.CreateLayer("habitat_patches", googleMapsSR, ogr.wkbMultiPolygon)

For this I need to create a data source object. 
This is done by calling a driver and creating a data source. 

val driver = ogr.GetDriverByName("ESRI Shapefile")
val ds = driver.CreateDataSource("habitat_paches") // the CreateDataSource() function takes as parameter the file name.
!!! You can delete a file with the driver.DeleteDataSource("filename")!!!
Now that I have a data source I can create the habitatPatchesLyr.

For the moment the layer is empty. I haven't stored anything in it.
Each layer can contain one or more features. Each feature has a geometry and a variable number of attribute fields.

In order to store my geometries I have to firstly add them to a feature and set the field schema. 

Create Fields and Field Definitions:
habitatPatchesLyr.CreateField(ogr.FieldDefn("ID", ogr.OFTInteger))
After the creation of all fields for a layer you obtain a LAYER DEFINITION. You have to get that layer definition and use it to create features:
val usedDefn = habitatPathchesLyr.GetLayerDefn()
val feat = ogr.Feature(usedDefn)
This feature called feat is a dummy feature, that you add the geometry and attributes to and insert into the layer:
feat.SetGeometry("wkbPolygon") //for each feature
I have to set the fields with:
feat.SetField("ID",n) where n is n+=1. 
(I will do a recursive function for that to set the field for all features).

You insert the feature into the layer:
habitatPatchesLyr.CreateFeature(feat) // for each feature


__________________________________________________________________



I've prepared some point coordinates in the pointcoord.txt file.  

I will see how good the sketched code on creation of geometries, features and layers fits in REPL:

__________new REPL session _______________________

 
cala> import scala.io._
import scala.io._

scala> val source = Source.fromFile("pointcoord.txt")
source: scala.io.BufferedSource = non-empty iterator

scala> val data = source.getLines.toArray
data: Array[String] = Array("/* The following point coordinates were taken from Google Maps. They provide thegeodata for the geometries and vector layer created for educational purposes by me for my tutorial "Geospatial Analysis with Scala". ", @author: Roxana Tesileanu, "*/ ", "", //points for Tampa Hill, BV, entered clockwise, 45.631118, 25.583995, 45.632863, 25.586184, 45.633955, 25.586698, 45.634345, 25.587706, 45.636370, 25.589595, 45.636730, 25.589423, 45.639431, 25.593006, 45.642450, 25.598735, 45.642083, 25.603038, 45.640676, 25.607061, 45.639738, 25.607404, 45.638925, 25.607131, 45.636318, 25.604551, 45.634559, 25.602963, 45.633002, 25.602048, 45.630514, 25.597860, 45.630139, 25.596379, 45.629801, 25.596057, 45.629043, 25.596454, 45.627693, 25.595639, 45.627115, 25.594705, 45.6...
scala> 

cala> source.close

scala> val source = Source.fromFile("pointcoord2.txt")
source: scala.io.BufferedSource = non-empty iterator

scala> val data = source.getLines.map(_.split("\n")).toArray
data: Array[Array[String]] = Array(Array(45.631118, 25.583995), Array(45.632863, 25.586184), Array(45.633955, 25.586698), Array(45.634345, 25.587706), Array(45.636370, 25.589595), Array(45.636730, 25.589423), Array(45.639431, 25.593006), Array(45.642450, 25.598735), Array(45.642083, 25.603038), Array(45.640676, 25.607061), Array(45.639738, 25.607404), Array(45.638925, 25.607131), Array(45.636318, 25.604551), Array(45.634559, 25.602963), Array(45.633002, 25.602048), Array(45.630514, 25.597860), Array(45.630139, 25.596379), Array(45.629801, 25.596057), Array(45.629043, 25.596454), Array(45.627693, 25.595639), Array(45.627115, 25.594705), Array(45.626380, 25.595060), Array(45.625577, 25.594877), Array(45.626220, 25.592055), Array(45.626215, 25.589502), Array(45.627325, 25.589545), Array(45...
scala> source.close

NOTE: each inner array represents a set of point coordinates. The first one is the longitude (east/west) and the second one is the latitude (N/S).
The first 30 points are for the first polygon: habitatPatch1 (dealul Tampa).
The following 20 points are for the first road: road1 (zona Racadau).
The following 10 points are for the second road: road2 (zona Carpatilor).
The following 9 points are for the third road: road3 (zona Noua).
The following 33 points are for the second polygon: habitatPatch2 (padurea Noua).
The following 9 lines are for the imaginary GPS-track: gpsTrack (for our imaginary friend).
The following 13 lines are for the third polygon: habitatPatch3 (towards Postavaru Peak).
The following 7 lines are for the fourth polygon: the study area. 

scala> val pointsHP1 = data.take(29)
pointsHP1: Array[Array[String]] = Array(Array(45.631118, 25.583995), Array(45.632863, 25.586184), Array(45.633955, 25.586698), Array(45.634345, 25.587706), Array(45.636370, 25.589595), Array(45.636730, 25.589423), Array(45.639431, 25.593006), Array(45.642450, 25.598735), Array(45.642083, 25.603038), Array(45.640676, 25.607061), Array(45.639738, 25.607404), Array(45.638925, 25.607131), Array(45.636318, 25.604551), Array(45.634559, 25.602963), Array(45.633002, 25.602048), Array(45.630514, 25.597860), Array(45.630139, 25.596379), Array(45.629801, 25.596057), Array(45.629043, 25.596454), Array(45.627693, 25.595639), Array(45.627115, 25.594705), Array(45.626380, 25.595060), Array(45.625577, 25.594877), Array(45.626220, 25.592055), Array(45.626215, 25.589502), Array(45.627325, 25.589545), Arr...

cala> val data2 = data.drop(29)
data2: Array[Array[String]] = Array(Array(45.612195, 25.588475), Array(45.614445, 25.590527), Array(45.620019, 25.594370), Array(45.623190, 25.594629), Array(45.625304, 25.595018), Array(45.626392, 25.595363), Array(45.626890, 25.595169), Array(45.627222, 25.595623), Array(45.628853, 25.597199), Array(45.628929, 25.597285), Array(45.629729, 25.599574), Array(45.629442, 25.600114), Array(45.630016, 25.601280), Array(45.630590, 25.603785), Array(45.631979, 25.606290), Array(45.633806, 25.609572), Array(45.637007, 25.611947), Array(45.636780, 25.614906), Array(45.636146, 25.618339), Array(45.636539, 25.618857), Array(45.633428, 25.620369), Array(45.632975, 25.619160), Array(45.631299, 25.620088), Array(45.631888, 25.623327), Array(45.630529, 25.624105), Array(45.629789, 25.622442), Array(4...

-----------------------------------------------

scala> val source = Source.fromFile("pointcoord2.txt")
source: scala.io.BufferedSource = non-empty iterator

scala> val data = source.getLines.map(_.split("\n")).toArray
data: Array[Array[String]] = Array(Array(45.631118, 25.583995), Array(45.632863, 25.586184), Array(45.633955, 25.586698), Array(45.634345, 25.587706), Array(45.636370, 25.589595), Array(45.636730, 25.589423), Array(45.639431, 25.593006), Array(45.642450, 25.598735), Array(45.642083, 25.603038), Array(45.640676, 25.607061), Array(45.639738, 25.607404), Array(45.638925, 25.607131), Array(45.636318, 25.604551), Array(45.634559, 25.602963), Array(45.633002, 25.602048), Array(45.630514, 25.597860), Array(45.630139, 25.596379), Array(45.629801, 25.596057), Array(45.629043, 25.596454), Array(45.627693, 25.595639), Array(45.627115, 25.594705), Array(45.626380, 25.595060), Array(45.625577, 25.594877), Array(45.626220, 25.592055), Array(45.626215, 25.589502), Array(45.627325, 25.589545), Array(45...
scala> data.length
length   lengthCompare

scala> data.length
res9: Int = 123

scala> source.close


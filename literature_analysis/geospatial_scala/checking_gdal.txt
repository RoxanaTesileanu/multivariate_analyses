Checking GDAL in Scala
Author: Roxana Tesileanu, INCDS, roxana.te@web.de

- I've placed the gdal-2.21.jar in the lib directory of the DeepLearning Scala project and hope to get the functionality of the GDAL, OGR and OSR libraries in Scala. 


- The main aim is to check if I can make the code from Chris Garrard (Geoprocessing with Python, 2015) work in Scala too.

_________________________________



scala> import org.gdal._
import org.gdal._

scala> org.gdal.
gdal   gdalconst   gnm   ogr   osr

scala> org.gdal.ogr.
DataSource    FieldDefn       ProgressCallback       ogrConstants   
Driver        GeomFieldDefn   StyleTable             ogrJNI         
Feature       Geometry        TermProgressCallback                  
FeatureDefn   Layer           ogr          

scala> org.gdal.gdal.
AsyncReader            GridOptions            Transformer              
Band                   InfoOptions            TranslateOptions         
BuildVRTOptions        MajorObject            VectorTranslateOptions   
ColorTable             NearblackOptions       WarpOptions              
DEMProcessingOptions   ProgressCallback       XMLNode                  
Dataset                RasterAttributeTable   XMLNodeType              
Driver                 RasterizeOptions       gdal                     
GCP                    TermProgressCallback   gdalJNI                  

cala> org.gdal.osr.
CoordinateTransformation   SpatialReference   osr   osrConstants   osrJNI


__________________________________________

A) Background on geoprocessing: Introduction (from C.Garrard, 2015)

1) Types of spatial data

- vector data 
- raster data

Vector data is made up of points, lines and polygons.
Raster data is a two- or three-dimensional array of data values.

The features on a map are items of interest like e.g. roads, country boundaries, weather stations, etc..  Features have attributes attached to them such as name and recorded variables. Using digital data, has the advantage of attaching multiple attribute values to each feature, whether you plan to display the information on a map or analyse the data.

Spatial overlay analyses are easy using vactor data.

Raster data is well suited to any continuous data (e.g. aerial photos, satellite imagery). A grid of values can capture local variation more easily (e.g. temperature, rainfall, elevation - in Digital Elevation Models DEMs, vegetation mapping). 
Blocks of adjacent pixels can be used to calculate useful information like the slope from DEMs, which can be further used to estimate the runoff. This type of information gaining is done using windows (sets of pixels, for which we find the variable we want for the central pixel). You move a window around a raster so each pixel is in the center of its own window. 

Vector and raster data can also be used together.  
   

GEOPROCESSING IS A GENERAL TERM FOR MANIPULATING SPATIAL DATA (WHETHER RASTER OR VECTOR DATA). 

Simple vector geoprocessing: overlay and proximity analyses.
Simple raster geoprocessing: resizing pixels, performing calculations based on multiple datasets, moving windows analyses.

Using a programming language allows you to customize your analysis instead of being limited to what the software user interface allows. Also, it allows you to process many datasets at once. 

Free and open source software is not only free with regard to price but allows for customization. You don't give up quality by using open source tools. In fact several of these packages are also used by proprietary software. 


B) Background on geoprocessing: Reading and writing vector data (from C.Garrard, 2015)

The types of data, where the features of interest are all distinct objects, are called vector datasets.
For manipulating vector datasets we will use the OGR library (to read, writem and edit these types for later use).

VECTOR DATA ARE DATA IN WHICH THE FEATURES OF INTEREST ARE REPRESENTED AS DISCRETE GEOMETRIES (POINTS, LINES, AND POLYGONS). Such features have distinct boundaries, but countinuous data such as elevetion don't. For example, polygons showing subalpine zones for a region would be a good proxy for an elevation range, but you lose much of the detailed elevation data within those polygons. Vector data candidates are for example roads, power lines, rivers, lakes, landownerships,counties and countries, cities, restaurants, mountain peaks, etc..

Vector data is more than geometries however. Each one of these features also has associated attributes. These attributes can be of various types. They can be numeric variables or categorical variables (strings). 

 VECTOR DATA ALWAYS LOOKS SMOOTH, NO MATTER THE SCALE (CONTRARY TO RASTER DATA). 
Only the type of geometry used to represent the features of interest may vary depending on scale (e.g. point for a city for low resolution, and polygon for high-resolution -> the higher the resolution the more detail can be shown). 

One common type of vector data analysis is to measure relationships between features, typically by overlapping them on one another to determine their spatial relationship. Another aspect of spatial relationships is the distance between two features. You can use GPS-collared wildlife and see the direction of travel, what travel distances they covered and how they interact with man-made features such as roads. Shapefiles are a popular format for sotring vector data. A shapefile isn't made of a single file however. This format requires a minimum of three binary files, each of which serves a different purpose:
- geometry information is stored in .shp and .shx files, and attribute values are stored in a .dbf file. You need to make sure that they are all kept in the same folder! 

Another widely used format, esp. for web-mapping applications is GeoJSON. These are plain text files that you can open up and look at in any text editor. Unlike a shapefile, a GeoJSON dataset consists of one file that stores all required information. 

Vector data sets can also be stored in relational databases. The two most popular spatial extensions for database systems are PostGIS (extension on top of PostgreSQL) and SpatialLite (works with SQLite databases). Another popular database format is the Esri file geodatabase. 

1) Introduction OGR

The OGR Simple Features Library is part of the Geospatial Data Abstraction Library (GDAL), an extremely popular open source library for reading and writing spatial data. The OGR part of GDAL is the one that provides the ability to read and write many different vector data formats. OGR also allows you to create and manipulate geometries; edit attribute values; filter vector data based on attribute values or spatial location; and it offers data analysis capabilities. 
The GDAL library was originally written in C and C++ and has bindings for several other languages. 

THE OGR CLASS STRUCTURE:

Spatial vector data is stored in a DATA SOURCE object (the shapefile, GeoJSON file, SpatiaLite, or PostGIS database, a.o.). This data source object can have one or more LAYERS, one for each dataset contained in the data source. Many vector formats, such as shapefiles can only contain one dataset, but others like SpatiLite can contain multiple datasets. ONE DATASET -> ONE LAYER. 

Each layer contains a collection of FEATURES, that holds the geometries and their attributes. ONE DATASET -> ONE LAYER -> GEOMETRIES AND ATTRIBUTES OF THE FEATURES. 	

The first step to accessing any vector data is to open the data source. For this you need to have an appropriate DRIVER that tells OGR how to work with your data format. EACH VECTOR FORMAT HAS ITS OWN DRIVER. YOU USE THAT DRIVER TO READ AND WRITE A PARTICULAR FORMAT. 

 
IMPLEMENTING the ogr.getDriverByName(string) function:

examples: 
ogr.getDriverByName("geojson")
org.getDriverByName("ESRI shapefile")


When implementing the Java method in Scala I get an exception:
scala>  val driver = org.gdal.ogr.ogrJNI.GetDriverByName("ESRI Shapefile")
java.lang.UnsatisfiedLinkError: org.gdal.ogr.ogrJNI.GetDriverByName(Ljava/lang/String;)J
  at org.gdal.ogr.ogrJNI.GetDriverByName(Native Method)
  ... 42 elided

I will get the code of Rob Emanuele (https://github.com/geotrellis/gdal-scala/blob/master/gdal/src/main/scala/org/gdal/scala/Gdal.scala) to get around that exception. 
I still have to use the function though. 
I will set the Java options for sbt.
One fact is certain, I have to install the Java bindings for GDAl, which is done with "$sudo apt-get install libgdal-java" (necessary packages: libproj-dev, gdal-bin, libgdal-dev, libgdal-doc) (see https://packages.ubuntu.com/source/trusty/gdal). 

AND THE RESULT OF ALL THIS IS: 

scala> org.gdal.ogr.ogrJNI.GetDriverByName("ESRI Shapefile")
res0: Long = 0

scala> org.gdal.ogr.ogrJNI.GetDriverByName("GeoJSON")
res1: Long = 0

scala> val ds = ogr.Open("sal_alk_eu27_laea1052.shp", 1)
ds: org.gdal.ogr.DataSource = null
________________________________________________


THE WORKING CODE FOR A NON-EMPTY DATASOURCE IS:

scala> org.gdal.ogr.ogr.RegisterAll()

scala> org.gdal.ogr.ogr.Open("example.shp")
res1: org.gdal.ogr.DataSource = org.gdal.ogr.DataSource@305c6b70

scala> res1.
CommitTransaction   GetLayerCount           SetDescription     
CopyLayer           GetMetadataDomainList   SetMetadata        
CreateLayer         GetMetadataItem         SetMetadataItem    
DeleteLayer         GetMetadata_Dict        SetStyleTable      
ExecuteSQL          GetMetadata_List        StartTransaction   
FlushCache          GetName                 SyncToDisk         
GetDescription      GetRefCount             TestCapability     
GetDriver           GetStyleTable           delete             
GetLayer            GetSummaryRefCount      equals             
GetLayerByIndex     ReleaseResultSet        getName            
GetLayerByName      RollbackTransaction     hashCode           

scala> res1.GetLayerCount
res2: Int = 1

scala> val lyr = res1.GetLayer(0)
lyr: org.gdal.ogr.Layer = org.gdal.ogr.Layer@305ca330

cala> lyr.
AlterFieldDefn      GetMetadataDomainList   SetIgnoredFields       
Clip                GetMetadataItem         SetMetadata            
CommitTransaction   GetMetadata_Dict        SetMetadataItem        
CreateFeature       GetMetadata_List        SetNextByIndex         
CreateField         GetName                 SetSpatialFilter       
CreateGeomField     GetNextFeature          SetSpatialFilterRect   
DeleteFeature       GetRefCount             SetStyleTable          
DeleteField         GetSpatialFilter        StartTransaction       
Erase               GetSpatialRef           SymDifference          
FindFieldIndex      GetStyleTable           SyncToDisk             
GetDescription      Identity                TestCapability         
GetExtent           Intersection            Union                  
GetFIDColumn        ReorderField            Update                 
GetFeature          ReorderFields           addReference           
GetFeatureCount     ResetReading            delete                 
GetFeaturesRead     RollbackTransaction     equals                 
GetGeomType         SetAttributeFilter      hashCode               
GetGeometryColumn   SetDescription                                 
GetLayerDefn        SetFeature                                     

scala> lyr.GetName
res3: String = example

cala> lyr.GetFeatureCount
res4: Long = 927

scala> lyr.GetSpatialRef
res5: org.gdal.osr.SpatialReference = null

cala> val feat0 = lyr.GetFeature(0)
feat0: org.gdal.ogr.Feature = org.gdal.ogr.Feature@3164b9a0

scala> feat0.
Clone                   GetFieldType                  SetFieldNull           
DumpReadable            GetGeomFieldCount             SetFieldStringList     
Equal                   GetGeomFieldDefnRef           SetFrom                
FillUnsetWithDefault    GetGeomFieldIndex             SetFromWithMap         
GetDefnRef              GetGeomFieldRef               SetGeomField           
GetFID                  GetGeometryRef                SetGeomFieldDirectly   
GetFieldAsBinary        GetNativeData                 SetGeometry            
GetFieldAsDateTime      GetNativeMediaType            SetGeometryDirectly    
GetFieldAsDouble        GetStyleString                SetNativeData          
GetFieldAsDoubleList    IsFieldNull                   SetNativeMediaType     
GetFieldAsInteger       IsFieldSet                    SetStyleString         
GetFieldAsInteger64     IsFieldSetAndNotNull          UnsetField             
GetFieldAsIntegerList   SetFID                        Validate               
GetFieldAsString        SetField                      clone                  
GetFieldAsStringList    SetFieldBinaryFromHexString   delete                 
GetFieldCount           SetFieldDoubleList            equals                 
GetFieldDefnRef         SetFieldInteger64             hashCode               
GetFieldIndex           SetFieldIntegerList                                  


cala> res1.delete()

DON'T FORGET TO CLOSE THE DATA SOURCE WITH ds.delete()!!!

___________________________________________

Checking OSR

scala> lyr.GetSpatialRef
res10: org.gdal.osr.SpatialReference =
GEOGCS["GCS_WGS_1984",
    DATUM["WGS_1984",
        SPHEROID["WGS_84",6378137,298.257223563]],
    PRIMEM["Greenwich",0],
    UNIT["Degree",0.017453292519943295],
    AUTHORITY["EPSG","4326"]]


__________________________________________

Creating SpatialReference objects: I will use the ETRS-LAEASRS as it is the single CRS for all Europe and is used for statistical mapping at all scales and other purposes where true area representation is required.

http://spatialreference.org/ref/epsg/3035/


scala> org.gdal.ogr.ogr.RegisterAll()

scala> val ds = org.gdal.ogr.ogr.Open("sal_alk_eu27_laea1052.shp")
ds: org.gdal.ogr.DataSource = org.gdal.ogr.DataSource@68b12470

scala> val lyr = ds.GetLayer(0)
lyr: org.gdal.ogr.Layer = org.gdal.ogr.Layer@68b12de0

scala> lyr.GetSpatialRef
res1: org.gdal.osr.SpatialReference =
PROJCS["ETRS_1989_LAEA",
    GEOGCS["GCS_ETRS_1989",
        DATUM["European_Terrestrial_Reference_System_1989",
            SPHEROID["GRS_1980",6378137.0,298.257222101]],
        PRIMEM["Greenwich",0.0],
        UNIT["Degree",0.0174532925199433]],
    PROJECTION["Lambert_Azimuthal_Equal_Area"],
    PARAMETER["False_Easting",4321000.0],
    PARAMETER["False_Northing",3210000.0],
    PARAMETER["longitude_of_center",10.0],
    PARAMETER["latitude_of_center",52.0],
    UNIT["Meter",1.0]]

scala> val newSR = org.gdal.osr.SpatialReference
<console>:11: error: object org.gdal.osr.SpatialReference is not a value
       val newSR = org.gdal.osr.SpatialReference
                                ^

scala> val newSR = org.gdal.osr.SpatialReference()
<console>:11: error: object org.gdal.osr.SpatialReference is not a value
       val newSR = org.gdal.osr.SpatialReference()
                                ^

scala> val newSR = org.gdal.osr.SpatialReference.getCPtr
   def getCPtr(x$1: org.gdal.osr.SpatialReference): Long

scala> val newSR = org.gdal.osr.
CoordinateTransformation   SpatialReference   osr   osrConstants   osrJNI

scala> val newSR = org.gdal.osr.SpatialReference
   object SpatialReference

scala> val newSR = org.gdal.osr.SpatialReference
<console>:11: error: object org.gdal.osr.SpatialReference is not a value
       val newSR = org.gdal.osr.SpatialReference
                                ^

scala> val newSR = org.gdal.osr.SpatialReference()
<console>:11: error: object org.gdal.osr.SpatialReference is not a value
       val newSR = org.gdal.osr.SpatialReference()
                                ^

scala> val newSR = new org.gdal.osr.SpatialReference()
newSR: org.gdal.osr.SpatialReference =

scala> newSR.
AutoIdentifyEPSG              SetCS                               
Clone                         SetCompoundCS                       
CloneGeogCS                   SetEC                               
CopyGeogCSFrom                SetEckertIV                         
EPSGTreatsAsLatLong           SetEckertVI                         
EPSGTreatsAsNorthingEasting   SetEquirectangular                  
ExportToMICoordSys            SetEquirectangular2                 
ExportToPCI                   SetFromUserInput                    
ExportToPrettyWkt             SetGEOS                             
ExportToProj4                 SetGH                               
ExportToUSGS                  SetGS                               
ExportToWkt                   SetGaussSchreiberTMercator          
ExportToXML                   SetGeocCS                           
Fixup                         SetGeogCS                           
FixupOrdering                 SetGnomonic                         
GetAngularUnits               SetHOM                              
GetAngularUnitsName           SetHOM2PNO                          
GetAttrValue                  SetIGH                              
GetAuthorityCode              SetKrovak                           
GetAuthorityName              SetLAEA                             
GetAxisName                   SetLCC                              
GetAxisOrientation            SetLCC1SP                           
GetInvFlattening              SetLCCB                             
GetLinearUnits                SetLinearUnits                      
GetLinearUnitsName            SetLinearUnitsAndUpdateParameters   
GetNormProjParm               SetLocalCS                          
GetProjParm                   SetMC                               
GetSemiMajor                  SetMercator                         
GetSemiMinor                  SetMollweide                        
GetTOWGS84                    SetNZMG                             
GetTargetLinearUnits          SetNormProjParm                     
GetUTMZone                    SetOS                               
ImportFromEPSG                SetOrthographic                     
ImportFromEPSGA               SetPS                               
ImportFromERM                 SetPolyconic                        
ImportFromESRI                SetProjCS                           
ImportFromMICoordSys          SetProjParm                         
ImportFromOzi                 SetProjection                       
ImportFromPCI                 SetRobinson                         
ImportFromProj4               SetSOC                              
ImportFromUSGS                SetSinusoidal                       
ImportFromUrl                 SetStatePlane                       
ImportFromWkt                 SetStereographic                    
ImportFromXML                 SetTM                               
IsCompound                    SetTMG                              
IsGeocentric                  SetTMSO                             
IsGeographic                  SetTMVariant                        
IsLocal                       SetTOWGS84                          
IsProjected                   SetTargetLinearUnits                
IsSame                        SetUTM                              
IsSameGeogCS                  SetVDG                              
IsSameVertCS                  SetVertCS                           
IsVertical                    SetWellKnownGeogCS                  
MorphFromESRI                 StripCTParms                        
MorphToESRI                   Validate                            
SetACEA                       __str__                             
SetAE                         clone                               
SetAngularUnits               delete                              
SetAttrValue                  equals                              
SetAuthority                  hashCode                            
SetBonne                      toString                            
SetCEA            

cala> newSR.ImportFrom
ImportFromEPSG    ImportFromESRI         ImportFromPCI     ImportFromUrl   
ImportFromEPSGA   ImportFromMICoordSys   ImportFromProj4   ImportFromWkt   
ImportFromERM     ImportFromOzi          ImportFromUSGS    ImportFromXML   

scala> newSR.ImportFromEPSG(3035)
res2: Int = 0

scala> newSR
res3: org.gdal.osr.SpatialReference =
PROJCS["ETRS89 / LAEA Europe",
    GEOGCS["ETRS89",
        DATUM["European_Terrestrial_Reference_System_1989",
            SPHEROID["GRS 1980",6378137,298.257222101,
                AUTHORITY["EPSG","7019"]],
            TOWGS84[0,0,0,0,0,0,0],
            AUTHORITY["EPSG","6258"]],
        PRIMEM["Greenwich",0,
            AUTHORITY["EPSG","8901"]],
        UNIT["degree",0.0174532925199433,
            AUTHORITY["EPSG","9122"]],
        AUTHORITY["EPSG","4258"]],
    PROJECTION["Lambert_Azimuthal_Equal_Area"],
    PARAMETER["latitude_of_center",52],
    PARAMETER["longitude_of_center",10],
    PARAMETER["false_easting",4321000],
    PARAMETER["false_northing",3210000],
    UNIT["metre",1,
        AUTHORITY["EPSG","9001"]],
    AUTHORITY["EPSG","30...

scala> val newSR2 = new org.gdal.osr.SpatialReference()
newSR2: org.gdal.osr.SpatialReference =

scala> newSR2.ImportFromURL("http://spatialreference.org/ref/epsg/3035/proj4/")
<console>:13: error: value ImportFromURL is not a member of org.gdal.osr.SpatialReference
       newSR2.ImportFromURL("http://spatialreference.org/ref/epsg/3035/proj4/")
              ^

scala> newSR2.ImportFrom
ImportFromEPSG    ImportFromESRI         ImportFromPCI     ImportFromUrl   
ImportFromEPSGA   ImportFromMICoordSys   ImportFromProj4   ImportFromWkt   
ImportFromERM     ImportFromOzi          ImportFromUSGS    ImportFromXML   

scala> newSR2.ImportFromProj4("+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ")
res6: Int = 0

scala> newSR2
res7: org.gdal.osr.SpatialReference =
PROJCS["unnamed",
    GEOGCS["GRS 1980(IUGG, 1980)",
        DATUM["unknown",
            SPHEROID["GRS80",6378137,298.257222101]],
        PRIMEM["Greenwich",0],
        UNIT["degree",0.0174532925199433]],
    PROJECTION["Lambert_Azimuthal_Equal_Area"],
    PARAMETER["latitude_of_center",52],
    PARAMETER["longitude_of_center",10],
    PARAMETER["false_easting",4321000],
    PARAMETER["false_northing",3210000],
    UNIT["Meter",1]]

cala> newSR3.ImportFromWkt("""PROJCS["ETRS89 / ETRS-LAEA",
     |     GEOGCS["ETRS89",
     |         DATUM["European_Terrestrial_Reference_System_1989",
     |             SPHEROID["GRS 1980",6378137,298.257222101,
     |                 AUTHORITY["EPSG","7019"]],
     |             AUTHORITY["EPSG","6258"]],
     |         PRIMEM["Greenwich",0,
     |             AUTHORITY["EPSG","8901"]],
     |         UNIT["degree",0.01745329251994328,
     |             AUTHORITY["EPSG","9122"]],
     |         AUTHORITY["EPSG","4258"]],
     |     UNIT["metre",1,
     |         AUTHORITY["EPSG","9001"]],
     |     PROJECTION["Lambert_Azimuthal_Equal_Area"],
     |     PARAMETER["latitude_of_center",52],
     |     PARAMETER["longitude_of_center",10],
     |     PARAMETER["false_easting",4321000],
     |     PARAMETER["false_northing",3210000],
     |     AUTHORITY["EPSG","3035"],
     |     AXIS["X",EAST],
     |     AXIS["Y",NORTH]]""")
res9: Int = 0


scala> val newSR3 = new org.gdal.osr.SpatialReference()
newSR3: org.gdal.osr.SpatialReference =

scala> newSR3.ImportFromWkt("""PROJCS["ETRS89 / ETRS-LAEA",
     |     GEOGCS["ETRS89",
     |         DATUM["European_Terrestrial_Reference_System_1989",
     |             SPHEROID["GRS 1980",6378137,298.257222101,
     |                 AUTHORITY["EPSG","7019"]],
     |             AUTHORITY["EPSG","6258"]],
     |         PRIMEM["Greenwich",0,
     |             AUTHORITY["EPSG","8901"]],
     |         UNIT["degree",0.01745329251994328,
     |             AUTHORITY["EPSG","9122"]],
     |         AUTHORITY["EPSG","4258"]],
     |     UNIT["metre",1,
     |         AUTHORITY["EPSG","9001"]],
     |     PROJECTION["Lambert_Azimuthal_Equal_Area"],
     |     PARAMETER["latitude_of_center",52],
     |     PARAMETER["longitude_of_center",10],
     |     PARAMETER["false_easting",4321000],
     |     PARAMETER["false_northing",3210000],
     |     AUTHORITY["EPSG","3035"],
     |     AXIS["X",EAST],
     |     AXIS["Y",NORTH]]""")
res9: Int = 0

scala> newSR3
res10: org.gdal.osr.SpatialReference =
PROJCS["ETRS89 / ETRS-LAEA",
    GEOGCS["ETRS89",
        DATUM["European_Terrestrial_Reference_System_1989",
            SPHEROID["GRS 1980",6378137,298.257222101,
                AUTHORITY["EPSG","7019"]],
            AUTHORITY["EPSG","6258"]],
        PRIMEM["Greenwich",0,
            AUTHORITY["EPSG","8901"]],
        UNIT["degree",0.01745329251994328,
            AUTHORITY["EPSG","9122"]],
        AUTHORITY["EPSG","4258"]],
    UNIT["metre",1,
        AUTHORITY["EPSG","9001"]],
    PROJECTION["Lambert_Azimuthal_Equal_Area"],
    PARAMETER["latitude_of_center",52],
    PARAMETER["longitude_of_center",10],
    PARAMETER["false_easting",4321000],
    PARAMETER["false_northing",3210000],
    AUTHORITY["EPSG","3035"],
    AXIS["X",EAST],
    AXIS["...
scala> 

_________________________________-

Now I will give it a try with Pulkovo 1942(58)/Stereo 70, ESPG 3844, http://spatialreference.org/ref/epsg/3844/.
Non-military large and medium scale topographic map for Romania.

scala> val roSR1 = new org.gdal.osr.SpatialReference()
roSR1: org.gdal.osr.SpatialReference =

scala> roSR1.ImportFromEPSG(3844)
res14: Int = 0

scala> roSR1
res15: org.gdal.osr.SpatialReference =
PROJCS["Pulkovo 1942(58) / Stereo70",
    GEOGCS["Pulkovo 1942(58)",
        DATUM["Pulkovo_1942_58",
            SPHEROID["Krassowsky 1940",6378245,298.3,
                AUTHORITY["EPSG","7024"]],
            TOWGS84[2.329,-147.042,-92.08,0.309,-0.325,-0.497,5.69],
            AUTHORITY["EPSG","6179"]],
        PRIMEM["Greenwich",0,
            AUTHORITY["EPSG","8901"]],
        UNIT["degree",0.0174532925199433,
            AUTHORITY["EPSG","9122"]],
        AUTHORITY["EPSG","4179"]],
    PROJECTION["Oblique_Stereographic"],
    PARAMETER["latitude_of_origin",46],
    PARAMETER["central_meridian",25],
    PARAMETER["scale_factor",0.99975],
    PARAMETER["false_easting",500000],
    PARAMETER["false_northing",500000],
    UNIT["metre",1,
        A...
cala> val roSR2 = new org.gdal.osr.SpatialReference()
roSR2: org.gdal.osr.SpatialReference =

scala> roSR2.ImportFromWkt("""PROJCS["Pulkovo 1942(58) / Stereo70",
     |     GEOGCS["Pulkovo 1942(58)",
     |         DATUM["Pulkovo 1942(58)",
     |             SPHEROID["Krassowsky 1940",6378245.0,298.3,
     |                 AUTHORITY["EPSG","7024"]],
     |             TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.17326243724756094],
     |             AUTHORITY["EPSG","6179"]],
     |         PRIMEM["Greenwich",0.0,
     |             AUTHORITY["EPSG","8901"]],
     |         UNIT["degree",0.017453292519943295],
     |         AXIS["Geodetic latitude",NORTH],
     |         AXIS["Geodetic longitude",EAST],
     |         AUTHORITY["EPSG","4179"]],
     |     PROJECTION["Oblique Stereographic",
     |         AUTHORITY["EPSG","9809"]],
     |     PARAMETER["central_meridian",25.0],
     |     PARAMETER["latitude_of_origin",46.0],
     |     PARAMETER["scale_factor",0.99975],
     |     PARAMETER["false_easting",500000.0],
     |     PARAMETER["false_northing",500000.0],
     |     UNIT["m",1.0],
     |     AXIS["Northing",NORTH],
     |     AXIS["Easting",EAST],
     |     AUTHORITY["EPSG","3844"]]""")
res16: Int = 0

scala> roSR2
res17: org.gdal.osr.SpatialReference =
PROJCS["Pulkovo 1942(58) / Stereo70",
    GEOGCS["Pulkovo 1942(58)",
        DATUM["Pulkovo 1942(58)",
            SPHEROID["Krassowsky 1940",6378245.0,298.3,
                AUTHORITY["EPSG","7024"]],
            TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.17326243724756094],
            AUTHORITY["EPSG","6179"]],
        PRIMEM["Greenwich",0.0,
            AUTHORITY["EPSG","8901"]],
        UNIT["degree",0.017453292519943295],
        AXIS["Geodetic latitude",NORTH],
        AXIS["Geodetic longitude",EAST],
        AUTHORITY["EPSG","4179"]],
    PROJECTION["Oblique Stereographic",
        AUTHORITY["EPSG","9809"]],
    PARAMETER["central_meridian",25.0],
    PARAMETER["latitude_of_origin",46.0],
    PARAMETER["scale_factor",0.99975],
  PAR...

_______________________________________-

I will construct a Polygon. I look up the points on the Internet:
45.650988, 25.581612
45.651026, 25.582142
45.650854, 25.581635
45.650801, 25.582182

myBuilding

val ring = org.Geometry(ogr.wkbLinearRing)
ring.AddPoint(45.650988, 25.581612)
ring.AddPoint(45.651026, 25.582142)
ring.AddPoint(45.650854, 25.581635)
ring.AddPoint(45.650801, 25.582182)

val building = ogr.Geometry(ogr.wkbPolygon)
building.AddGeometry(ring)
building.CloseRings()
building.IsValid
____________

NOTE: Google uses WGS 84 Web Mercator as its coordinate system !!!!!

EPSG:3857

https://en.wikipedia.org/wiki/Web_Mercator

WGS 84 / Pseudo-Mercator -- Spherical Mercator, Google Maps, OpenStreetMap, Bing, ArcGIS, ESRI

www.epsg.io/3857
WKT """PROJCS["WGS 84 / Pseudo-Mercator",
    GEOGCS["WGS 84",
        DATUM["WGS_1984",
            SPHEROID["WGS 84",6378137,298.257223563,
                AUTHORITY["EPSG","7030"]],
            AUTHORITY["EPSG","6326"]],
        PRIMEM["Greenwich",0,
            AUTHORITY["EPSG","8901"]],
        UNIT["degree",0.0174532925199433,
            AUTHORITY["EPSG","9122"]],
        AUTHORITY["EPSG","4326"]],
    PROJECTION["Mercator_1SP"],
    PARAMETER["central_meridian",0],
    PARAMETER["scale_factor",1],
    PARAMETER["false_easting",0],
    PARAMETER["false_northing",0],
    UNIT["metre",1,
        AUTHORITY["EPSG","9001"]],
    AXIS["X",EAST],
    AXIS["Y",NORTH],
    EXTENSION["PROJ4","+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"],
    AUTHORITY["EPSG","3857"]]
"""
_________________________________________________________

Creating Points:

cornerNW = 45.654542, 25.576068
cornerNE1 = 45.654689, 25.577259
cornerNE2 = 45.654599, 25.577560
cornerSE1 = 45.653862, 25.577713
cornerSE2 = 45.653530, 25.577458
cornerSW = 45.653208, 25.576524

val firstPoint = ogr.Geometry(ogr.wkbPoint)
firstPoint.AddPoint( 45.654542, 25.576068)

Creating MultiPoints (multiple points as one geometry):

val patchCorners = ogr.Geometry(ogr.wkbMultiPoint)
val corner = ogr.Geometry(ogr.wkbPoint)
corner.AddPoint( 45.654542, 25.576068)
patchCorners.AddGeometry(corner)
corner.AddPoint(45.654689, 25.577259)
patchCorners.AddGeometry(corner)
corner.AddPoint(45.654599, 25.577560)
patchCorners.AddGeometry(corner)
corner.AddPoint(45.653862, 25.577713)
patchCorners.AddGeometry(corner)
corner.AddPoint(45.653530, 25.577458)
patchCorners.AddGeometry(corner)
corner.AddPoint(45.653208, 25.576524)
patchCorners.AddGeometry(corner)
I will probably have to use vars for this. 

Def. of VERTEX: A vertex is a point where two line segments of a geometry meet.Vertices hold the coordinates of the ends of each line segment. 

Creating lines:

Lines are a sequence of vertices connected by straight line segments. 

var road1 = ogr.Geometry(ogr.wkbLineString)
road1.AddPoint(45.654919, 25.579059)
road1.AddPoint(45.653869, 25.578466)
road1.AddPoint(45.652947, 25.578791)
road1.AddPoint(45.652585, 25.578785)
road1.AddPoint(45.652553, 25.579220)
road1.AddPoint(45.651732, 25.580851)

var road2 = ogr.Geometry(ogr.wkbLineString)
road2.AddPoint(45.654859, 25.576184)
road2.AddPoint(45.653828, 25.576524)

Creating multilines (multiple lines as one geometry):
var roads = ogr.Geometry(ogr.wkbMultiLineString)
roads.addGeometry(road1)
roads.addGeometry(road2)

Creating polygons:
Polygons have an area!
Polygons are made of rings. Rings are made up of a series of vertices connected by straight line segments. The first and the last vertices of a ring are the same -> they create a closed ring. 

I've written above the code for a polygon called building. 
I will sketch the code for a habitat patch now.  
var ring=ogr.Geometry(ogr.wkbLinearRing)
I have to check if adding a MultiPoint works. 
If so: 
ring.AddGeometry(patchCorners)
val habitatPatch = ogr.Geometry(ogr.wkbPolygon)
habitatPatch.AddGeometry(ring)
habitatPatch.CloseRings()

NOTE: SHAPEFILES SPECIFY THE OUTER RING MUST BE CLOCKWISE! 

Creating multipolygons: multiple polygons as one geometry

Let's assume my building is another habitat patch. I will create a variable patches which holds the two geometries. 

var habitatPatches = ogr.Geometry(ogr.wkbMultiPolygon)
habitatPatches.AddGeometry(building)
habitatPatches.AddGeometry(habitatPatch)
habitatPatches.CloseRings()

SUMMARY:
- a geometry consists of a collection of vertices
- multigeometries consist of multiple geometries combined into one
- all polygon geometries are made up of one or more rings (donut polygons have an outer and an inner ring).
________________________________________________________

Now I will create layers with the geometries I've got.
A new layer needs: a name, a spatial reference system, a geometry type. 
You can have point layer, line layer, polygon layer and their multiple-geometry version. You can't have two types in one layer. 

val habitatPatchesLyr = ds.CreateLayer("habitat_patches", googleMapsSR, ogr.wkbMultiPolygon)

For this I need to create a data source object. 
This is done by calling a driver and creating a data source. 

val driver = ogr.GetDriverByName("ESRI Shapefile")
val ds = driver.CreateDataSource("habitat_paches") // the CreateDataSource() function takes as parameter the file name.
!!! You can delete a file with the driver.DeleteDataSource("filename")!!!
Now that I have a data source I can create the habitatPatchesLyr.

For the moment the layer is empty. I haven't stored anything in it.
Each layer can contain one or more features. Each feature has a geometry and a variable number of attribute fields.

In order to store my geometries I have to firstly add them to a feature and set the field schema. 

Create Fields and Field Definitions:
habitatPatchesLyr.CreateField(ogr.FieldDefn("ID", ogr.OFTInteger))
After the creation of all fields for a layer you obtain a LAYER DEFINITION. You have to get that layer definition and use it to create features:
val usedDefn = habitatPathchesLyr.GetLayerDefn()
val feat = ogr.Feature(usedDefn)
This feature called feat is a dummy feature, that you add the geometry and attributes to and insert into the layer:
feat.SetGeometry("wkbPolygon") //for each feature
I have to set the fields with:
feat.SetField("ID",n) where n is n+=1. 
(I will do a recursive function for that to set the field for all features).

You insert the feature into the layer:
habitatPatchesLyr.CreateFeature(feat) // for each feature


__________________________________________________________________



I've prepared some point coordinates in the pointcoord.txt file.  

I will see how good the sketched code on creation of geometries, features and layers fits in REPL:

__________new REPL session _______________________

 
cala> import scala.io._
import scala.io._

scala> val source = Source.fromFile("pointcoord.txt")
source: scala.io.BufferedSource = non-empty iterator

scala> val data = source.getLines.toArray
data: Array[String] = Array("/* The following point coordinates were taken from Google Maps. They provide thegeodata for the geometries and vector layer created for educational purposes by me for my tutorial "Geospatial Analysis with Scala". ", @author: Roxana Tesileanu, "*/ ", "", //points for Tampa Hill, BV, entered clockwise, 45.631118, 25.583995, 45.632863, 25.586184, 45.633955, 25.586698, 45.634345, 25.587706, 45.636370, 25.589595, 45.636730, 25.589423, 45.639431, 25.593006, 45.642450, 25.598735, 45.642083, 25.603038, 45.640676, 25.607061, 45.639738, 25.607404, 45.638925, 25.607131, 45.636318, 25.604551, 45.634559, 25.602963, 45.633002, 25.602048, 45.630514, 25.597860, 45.630139, 25.596379, 45.629801, 25.596057, 45.629043, 25.596454, 45.627693, 25.595639, 45.627115, 25.594705, 45.6...
scala> 

cala> source.close

scala> val source = Source.fromFile("pointcoord2.txt")
source: scala.io.BufferedSource = non-empty iterator

scala> val data = source.getLines.map(_.split("\n")).toArray
data: Array[Array[String]] = Array(Array(45.631118, 25.583995), Array(45.632863, 25.586184), Array(45.633955, 25.586698), Array(45.634345, 25.587706), Array(45.636370, 25.589595), Array(45.636730, 25.589423), Array(45.639431, 25.593006), Array(45.642450, 25.598735), Array(45.642083, 25.603038), Array(45.640676, 25.607061), Array(45.639738, 25.607404), Array(45.638925, 25.607131), Array(45.636318, 25.604551), Array(45.634559, 25.602963), Array(45.633002, 25.602048), Array(45.630514, 25.597860), Array(45.630139, 25.596379), Array(45.629801, 25.596057), Array(45.629043, 25.596454), Array(45.627693, 25.595639), Array(45.627115, 25.594705), Array(45.626380, 25.595060), Array(45.625577, 25.594877), Array(45.626220, 25.592055), Array(45.626215, 25.589502), Array(45.627325, 25.589545), Array(45...
scala> source.close

NOTE: each inner array represents a set of point coordinates. The first one is the longitude (east/west) and the second one is the latitude (N/S). There are 123 points.
The first group of points are for the first polygon: habitatPatch1 (dealul Tampa).
The following group of points are for the first road: road1 (zona Racadau).
The following group of points are for the second road: road2 (zona Carpatilor).
The following group of points are for the third road: road3 (zona Noua).
The following group of points are for the second polygon: habitatPatch2 (padurea Noua).
The following group of points are for the imaginary GPS-track: gpsTrack (for our imaginary friend).
The following group of points are for the third polygon: habitatPatch3 (towards Postavaru Peak).
The following group of points are for the fourth polygon: the study area. 

scala> val pointsHP1 = data.take(29)
pointsHP1: Array[Array[String]] = Array(Array(45.631118, 25.583995), Array(45.632863, 25.586184), Array(45.633955, 25.586698), Array(45.634345, 25.587706), Array(45.636370, 25.589595), Array(45.636730, 25.589423), Array(45.639431, 25.593006), Array(45.642450, 25.598735), Array(45.642083, 25.603038), Array(45.640676, 25.607061), Array(45.639738, 25.607404), Array(45.638925, 25.607131), Array(45.636318, 25.604551), Array(45.634559, 25.602963), Array(45.633002, 25.602048), Array(45.630514, 25.597860), Array(45.630139, 25.596379), Array(45.629801, 25.596057), Array(45.629043, 25.596454), Array(45.627693, 25.595639), Array(45.627115, 25.594705), Array(45.626380, 25.595060), Array(45.625577, 25.594877), Array(45.626220, 25.592055), Array(45.626215, 25.589502), Array(45.627325, 25.589545), Arr...

cala> val data2 = data.drop(29)
data2: Array[Array[String]] = Array(Array(45.612195, 25.588475), Array(45.614445, 25.590527), Array(45.620019, 25.594370), Array(45.623190, 25.594629), Array(45.625304, 25.595018), Array(45.626392, 25.595363), Array(45.626890, 25.595169), Array(45.627222, 25.595623), Array(45.628853, 25.597199), Array(45.628929, 25.597285), Array(45.629729, 25.599574), Array(45.629442, 25.600114), Array(45.630016, 25.601280), Array(45.630590, 25.603785), Array(45.631979, 25.606290), Array(45.633806, 25.609572), Array(45.637007, 25.611947), Array(45.636780, 25.614906), Array(45.636146, 25.618339), Array(45.636539, 25.618857), Array(45.633428, 25.620369), Array(45.632975, 25.619160), Array(45.631299, 25.620088), Array(45.631888, 25.623327), Array(45.630529, 25.624105), Array(45.629789, 25.622442), Array(4...

-----------------------------------------------

scala> val source = Source.fromFile("pointcoord2.txt")
source: scala.io.BufferedSource = non-empty iterator

scala> val data = source.getLines.map(_.split("\n")).toArray
data: Array[Array[String]] = Array(Array(45.631118, 25.583995), Array(45.632863, 25.586184), Array(45.633955, 25.586698), Array(45.634345, 25.587706), Array(45.636370, 25.589595), Array(45.636730, 25.589423), Array(45.639431, 25.593006), Array(45.642450, 25.598735), Array(45.642083, 25.603038), Array(45.640676, 25.607061), Array(45.639738, 25.607404), Array(45.638925, 25.607131), Array(45.636318, 25.604551), Array(45.634559, 25.602963), Array(45.633002, 25.602048), Array(45.630514, 25.597860), Array(45.630139, 25.596379), Array(45.629801, 25.596057), Array(45.629043, 25.596454), Array(45.627693, 25.595639), Array(45.627115, 25.594705), Array(45.626380, 25.595060), Array(45.625577, 25.594877), Array(45.626220, 25.592055), Array(45.626215, 25.589502), Array(45.627325, 25.589545), Array(45...
scala> data.length
length   lengthCompare

scala> data.length
res9: Int = 123

scala> source.close
----------------------------

NOT A GOOD IDEA TO PUT THE POINTS IN A TXT FILE. 
I'LL PUT THEM IN A CSV AND ADD A COLUMN WITH THE ITEM ID, SO THAT I CAN FILTER THEM UPON IT.

--------------------------
scala> val source = Source.fromFile("pointcoord.csv")
source: scala.io.BufferedSource = non-empty iterator

scala> val data = source.getLines.map(_.split(",")).toArray
data: Array[Array[String]] = Array(Array(45.631118, 25.583995, 1), Array(45.632863, 25.586184, 1), Array(45.633955, 25.586698, 1), Array(45.634345, 25.587706, 1), Array(45.63637, 25.589595, 1), Array(45.63673, 25.589423, 1), Array(45.639431, 25.593006, 1), Array(45.64245, 25.598735, 1), Array(45.642083, 25.603038, 1), Array(45.640676, 25.607061, 1), Array(45.639738, 25.607404, 1), Array(45.638925, 25.607131, 1), Array(45.636318, 25.604551, 1), Array(45.634559, 25.602963, 1), Array(45.633002, 25.602048, 1), Array(45.630514, 25.59786, 1), Array(45.630139, 25.596379, 1), Array(45.629801, 25.596057, 1), Array(45.629043, 25.596454, 1), Array(45.627693, 25.595639, 1), Array(45.627115, 25.594705, 1), Array(45.62638, 25.59506, 1), Array(45.625577, 25.594877, 1), Array(45.62622, 25.592055, 1), A...
scala> data(0)
res22: Array[String] = Array(45.631118, 25.583995, 1)

scala> res22(0)
res23: String = 45.631118

scala> val dataHP1 = data.filter(_(2) == "1")
dataHP1: Array[Array[String]] = Array(Array(45.631118, 25.583995, 1), Array(45.632863, 25.586184, 1), Array(45.633955, 25.586698, 1), Array(45.634345, 25.587706, 1), Array(45.63637, 25.589595, 1), Array(45.63673, 25.589423, 1), Array(45.639431, 25.593006, 1), Array(45.64245, 25.598735, 1), Array(45.642083, 25.603038, 1), Array(45.640676, 25.607061, 1), Array(45.639738, 25.607404, 1), Array(45.638925, 25.607131, 1), Array(45.636318, 25.604551, 1), Array(45.634559, 25.602963, 1), Array(45.633002, 25.602048, 1), Array(45.630514, 25.59786, 1), Array(45.630139, 25.596379, 1), Array(45.629801, 25.596057, 1), Array(45.629043, 25.596454, 1), Array(45.627693, 25.595639, 1), Array(45.627115, 25.594705, 1), Array(45.62638, 25.59506, 1), Array(45.625577, 25.594877, 1), Array(45.62622, 25.592055, 1)...
scala> dataHP1.length
res24: Int = 29

scala> val dataRoad1 = data.filter(_(2) == "2")
dataRoad1: Array[Array[String]] = Array(Array(45.612195, 25.588475, 2), Array(45.614445, 25.590527, 2), Array(45.620019, 25.59437, 2), Array(45.62319, 25.594629, 2), Array(45.625304, 25.595018, 2), Array(45.626392, 25.595363, 2), Array(45.62689, 25.595169, 2), Array(45.627222, 25.595623, 2), Array(45.628853, 25.597199, 2), Array(45.628929, 25.597285, 2), Array(45.629729, 25.599574, 2), Array(45.629442, 25.600114, 2), Array(45.630016, 25.60128, 2), Array(45.63059, 25.603785, 2), Array(45.631979, 25.60629, 2), Array(45.633806, 25.609572, 2), Array(45.637007, 25.611947, 2), Array(45.63678, 25.614906, 2), Array(45.636146, 25.618339, 2))

scala> val dataRoad2 = data.filter(_(2) == "3")
dataRoad2: Array[Array[String]] = Array(Array(45.636539, 25.618857, 3), Array(45.633428, 25.620369, 3), Array(45.632975, 25.61916, 3), Array(45.631299, 25.620088, 3), Array(45.631888, 25.623327, 3), Array(45.630529, 25.624105, 3), Array(45.629789, 25.622442, 3), Array(45.627494, 25.622463, 3), Array(45.628023, 25.618209, 3))

scala> dataRoad1.length
res25: Int = 19

scala> dataRoad2.length
res26: Int = 9

scala> val dataRoad3 = data.filter(_(2) == "4")
dataRoad3: Array[Array[String]] = Array(Array(45.628627, 25.624364, 4), Array(45.624866, 25.629071, 4), Array(45.627011, 25.633951, 4), Array(45.623432, 25.635506, 4), Array(45.622359, 25.634275, 4), Array(45.619671, 25.631036, 4), Array(45.619626, 25.624752, 4), Array(45.620547, 25.622507, 4))

scala> dataRoad3.length
res27: Int = 8

scala> val dataHP2 = data.filter(_(2) == "5")
dataHP2: Array[Array[String]] = Array(Array(45.612222, 25.589546, 5), Array(45.621849, 25.59521, 5), Array(45.626304, 25.597557, 5), Array(45.62989, 25.602105, 5), Array(45.632456, 25.609955, 5), Array(45.633898, 25.610253, 5), Array(45.635462, 25.612225, 5), Array(45.636364, 25.615346, 5), Array(45.635233, 25.616744, 5), Array(45.631935, 25.617357, 5), Array(45.629894, 25.621671, 5), Array(45.62775, 25.621804, 5), Array(45.628823, 25.617216, 5), Array(45.627631, 25.617099, 5), Array(45.626265, 25.618057, 5), Array(45.626477, 25.619801, 5), Array(45.625147, 25.621939, 5), Array(45.625546, 25.625259, 5), Array(45.623579, 25.626994, 5), Array(45.623868, 25.629202, 5), Array(45.622561, 25.632379, 5), Array(45.620556, 25.630997, 5), Array(45.620293, 25.626782, 5), Array(45.622734, 25.621884...
scala> dataHP2.length
res28: Int = 32

scala> val dataGPSTrack = data.filter(_(2) == "6")
dataGPSTrack: Array[Array[String]] = Array(Array(45.617797, 25.612945, 6), Array(45.620919, 25.618952, 6), Array(45.618454, 25.608328, 6), Array(45.622381, 25.619041, 6), Array(45.62018, 25.603591, 6), Array(45.617171, 25.585708, 6), Array(45.62291, 25.586664, 6), Array(45.633693, 25.596202, 6))

scala> dataGPSTrack.length
res29: Int = 8

scala> val dataHP3 = data.filter(_(2) == "7")
dataHP3: Array[Array[String]] = Array(Array(45.610059, 25.586784, 7), Array(45.62118, 25.560753, 7), Array(45.627951, 25.569719, 7), Array(45.627187, 25.577856, 7), Array(45.627582, 25.579325, 7), Array(45.63098, 25.583281, 7), Array(45.631979, 25.60629, 7), Array(45.629479, 25.587688, 7), Array(45.628346, 25.589346, 7), Array(45.626449, 25.589949, 7), Array(45.625579, 25.594658, 7), Array(45.615251, 25.590175, 7))

scala> dataHP3.length
res30: Int = 12

scala> val dataStArea =  data.filter(_(2) == "8")
dataStArea: Array[Array[String]] = Array(Array(45.623683, 25.562561, 8), Array(45.64394, 25.599744, 8), Array(45.637329, 25.623779, 8), Array(45.622708, 25.636663, 8), Array(45.614645, 25.633913, 8), Array(45.599965, 25.615302, 8))

scala> dataStArea.lenght
<console>:16: error: value lenght is not a member of Array[Array[String]]
       dataStArea.lenght
                  ^

scala> dataStArea.length
res32: Int = 6

cala> val pointsHP1 = dataHP1.map(i => (i(0).toDouble, i(1).toDouble))
pointsHP1: Array[(Double, Double)] = Array((45.631118,25.583995), (45.632863,25.586184), (45.633955,25.586698), (45.634345,25.587706), (45.63637,25.589595), (45.63673,25.589423), (45.639431,25.593006), (45.64245,25.598735), (45.642083,25.603038), (45.640676,25.607061), (45.639738,25.607404), (45.638925,25.607131), (45.636318,25.604551), (45.634559,25.602963), (45.633002,25.602048), (45.630514,25.59786), (45.630139,25.596379), (45.629801,25.596057), (45.629043,25.596454), (45.627693,25.595639), (45.627115,25.594705), (45.62638,25.59506), (45.625577,25.594877), (45.62622,25.592055), (45.626215,25.589502), (45.627325,25.589545), (45.628361,25.589137), (45.629576,25.587421), (45.631077,25.58388))

cala> val pointsRoad1 = dataRoad1.map(i => (i(0).toDouble, i(1).toDouble))
pointsRoad1: Array[(Double, Double)] = Array((45.612195,25.588475), (45.614445,25.590527), (45.620019,25.59437), (45.62319,25.594629), (45.625304,25.595018), (45.626392,25.595363), (45.62689,25.595169), (45.627222,25.595623), (45.628853,25.597199), (45.628929,25.597285), (45.629729,25.599574), (45.629442,25.600114), (45.630016,25.60128), (45.63059,25.603785), (45.631979,25.60629), (45.633806,25.609572), (45.637007,25.611947), (45.63678,25.614906), (45.636146,25.618339))

scala> val pointsRoad2 = dataRoad2.map(i => (i(0).toDouble, i(1).toDouble))
pointsRoad2: Array[(Double, Double)] = Array((45.636539,25.618857), (45.633428,25.620369), (45.632975,25.61916), (45.631299,25.620088), (45.631888,25.623327), (45.630529,25.624105), (45.629789,25.622442), (45.627494,25.622463), (45.628023,25.618209))

scala> val pointsRoad3 = dataRoad3.map(scala> val pointsHP1 = dataHP1.map(i => (i(0).toDouble, i(1).toDouble))
<console>:1: error: ')' expected but 'val' found.
val pointsRoad3 = dataRoad3.map(scala> val pointsHP1 = dataHP1.map(i => (i(0).toDouble, i(1).toDouble))
                                       ^

scala> pointsHP1: Array[(Double, Double)] = Array((45.631118,25.583995), (45.632863,25.586184), (45.633955,25.586698), (45.634345,25.587706), (45.63637,25.589595), (45.63673,25.589423), (45.639431,25.593006), (45.64245,25.598735), (45.642083,25.603038), (45.640676,25.607061), (45.639738,25.607404), (45.638925,25.607131), (45.636318,25.604551), (45.634559,25.602963), (45.633002,25.602048), (45.630514,25.59786), (45.630139,25.596379), (45.629801,25.596057), (45.629043,25.596454), (45.627693,25.595639), (45.627115,25.594705), (45.62638,25.59506), (45.625577,25.594877), (45.62622,25.592055), (45.626215,25.589502), (45.627325,25.589545), (45.628361,25.589137), (45.629576,25.587421), (45.631077,25.58388))
<console>:1: error: ';' expected but '=' found.
pointsHP1: Array[(Double, Double)] = Array((45.631118,25.583995), (45.632863,25.586184), (45.633955,25.586698), (45.634345,25.587706), (45.63637,25.589595), (45.63673,25.589423), (45.639431,25.593006), (45.64245,25.598735), (45.642083,25.603038), (45.640676,25.607061), (45.639738,25.607404), (45.638925,25.607131), (45.636318,25.604551), (45.634559,25.602963), (45.633002,25.602048), (45.630514,25.59786), (45.630139,25.596379), (45.629801,25.596057), (45.629043,25.596454), (45.627693,25.595639), (45.627115,25.594705), (45.62638,25.59506), (45.625577,25.594877), (45.62622,25.592055), (45.626215,25.589502), (45.627325,25.589545), (45.628361,25.589137), (45.629576,25.587421), (45.631077,25.58388))
                                   ^

scala> 

scala> pointsHP1: Array[(Double, Double)] = Array((45.631118,25.583995), (45.632863,25.586184), (45.633955,25.586698), (45.634345,25.587706), (45.63637,25.589595), (45.63673,25.589423), (45.639431,25.593006), (45.64245,25.598735), (45.642083,25.603038), (45.640676,25.607061), (45.639738,25.607404), (45.638925,25.607131), (45.636318,25.604551), (45.634559,25.602963), (45.633002,25.602048), (45.630514,25.59786), (45.630139,25.596379), (45.629801,25.596057), (45.629043,25.596454), (45.627693,25.595639), (45.627115,25.594705), (45.62638,25.59506), (45.625577,25.594877), (45.62622,25.592055), (45.626215,25.589502), (45.627325,25.589545), (45.628361,25.589137), (45.629576,25.587421), (45.631077,25.58388))
<console>:1: error: ';' expected but '=' found.
pointsHP1: Array[(Double, Double)] = Array((45.631118,25.583995), (45.632863,25.586184), (45.633955,25.586698), (45.634345,25.587706), (45.63637,25.589595), (45.63673,25.589423), (45.639431,25.593006), (45.64245,25.598735), (45.642083,25.603038), (45.640676,25.607061), (45.639738,25.607404), (45.638925,25.607131), (45.636318,25.604551), (45.634559,25.602963), (45.633002,25.602048), (45.630514,25.59786), (45.630139,25.596379), (45.629801,25.596057), (45.629043,25.596454), (45.627693,25.595639), (45.627115,25.594705), (45.62638,25.59506), (45.625577,25.594877), (45.62622,25.592055), (45.626215,25.589502), (45.627325,25.589545), (45.628361,25.589137), (45.629576,25.587421), (45.631077,25.58388))
                                   ^

scala> val pointsRoad3 = dataRoad3.map(i => (i(0).toDouble, i(1).toDouble))
pointsRoad3: Array[(Double, Double)] = Array((45.628627,25.624364), (45.624866,25.629071), (45.627011,25.633951), (45.623432,25.635506), (45.622359,25.634275), (45.619671,25.631036), (45.619626,25.624752), (45.620547,25.622507))

scala> val pointsHP2 = dataHP2.map((i => (i(0).toDouble, i(1).toDouble))
     | )
pointsHP2: Array[(Double, Double)] = Array((45.612222,25.589546), (45.621849,25.59521), (45.626304,25.597557), (45.62989,25.602105), (45.632456,25.609955), (45.633898,25.610253), (45.635462,25.612225), (45.636364,25.615346), (45.635233,25.616744), (45.631935,25.617357), (45.629894,25.621671), (45.62775,25.621804), (45.628823,25.617216), (45.627631,25.617099), (45.626265,25.618057), (45.626477,25.619801), (45.625147,25.621939), (45.625546,25.625259), (45.623579,25.626994), (45.623868,25.629202), (45.622561,25.632379), (45.620556,25.630997), (45.620293,25.626782), (45.622734,25.621884), (45.621789,25.618871), (45.619452,25.621083), (45.61835,25.625433), (45.616194,25.625733), (45.613602,25.628569), (45.611492,25.629284), (45.602445,25.618537), (45.606375,25.590345))

scala> val pointsHP2 = dataHP2.map(i => (i(0).toDouble, i(1).toDouble))
pointsHP2: Array[(Double, Double)] = Array((45.612222,25.589546), (45.621849,25.59521), (45.626304,25.597557), (45.62989,25.602105), (45.632456,25.609955), (45.633898,25.610253), (45.635462,25.612225), (45.636364,25.615346), (45.635233,25.616744), (45.631935,25.617357), (45.629894,25.621671), (45.62775,25.621804), (45.628823,25.617216), (45.627631,25.617099), (45.626265,25.618057), (45.626477,25.619801), (45.625147,25.621939), (45.625546,25.625259), (45.623579,25.626994), (45.623868,25.629202), (45.622561,25.632379), (45.620556,25.630997), (45.620293,25.626782), (45.622734,25.621884), (45.621789,25.618871), (45.619452,25.621083), (45.61835,25.625433), (45.616194,25.625733), (45.613602,25.628569), (45.611492,25.629284), (45.602445,25.618537), (45.606375,25.590345))

scala> val pointsGPSTrack = dataGPSTrack.map(i => (i(0).toDouble, i(1).toDouble))
pointsGPSTrack: Array[(Double, Double)] = Array((45.617797,25.612945), (45.620919,25.618952), (45.618454,25.608328), (45.622381,25.619041), (45.62018,25.603591), (45.617171,25.585708), (45.62291,25.586664), (45.633693,25.596202))

scala> val pointsStArea = dataStArea.map(i => (i(0).toDouble, i(1).toDouble))
pointsStArea: Array[(Double, Double)] = Array((45.623683,25.562561), (45.64394,25.599744), (45.637329,25.623779), (45.622708,25.636663), (45.614645,25.633913), (45.599965,25.615302))

____________ new REPL session ____________________

scala> :load readPointCoord.scala
Loading readPointCoord.scala...
import scala.io._
defined object ReadPointCoordFromFile

scala> import ReadPointCoordFromFile._
import ReadPointCoordFromFile._

scala> pointsRoad1
res0: Array[(Double, Double)] = Array((45.612195,25.588475), (45.614445,25.590527), (45.620019,25.59437), (45.62319,25.594629), (45.625304,25.595018), (45.626392,25.595363), (45.62689,25.595169), (45.627222,25.595623), (45.628853,25.597199), (45.628929,25.597285), (45.629729,25.599574), (45.629442,25.600114), (45.630016,25.60128), (45.63059,25.603785), (45.631979,25.60629), (45.633806,25.609572), (45.637007,25.611947), (45.63678,25.614906), (45.636146,25.618339))

scala> val currentPosition = new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbPoint)
currentPosition: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@6d5640

scala> currentPosition.AddPoint(pointsRoad1(0)._1, pointsRoad1(0)._2)

scala> currentPosition
res6: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@6d5640

scala> currentPosition.
AddGeometry              ExportToWkt              IsRing                     
AddGeometryDirectly      FlattenTo2D              IsSimple                   
AddPoint                 GetArea                  IsValid                    
AddPointM                GetBoundary              Length                     
AddPointZM               GetCoordinateDimension   Overlaps                   
AddPoint_2D              GetCurveGeometry         PointOnSurface             
Area                     GetDimension             Segmentize                 
AssignSpatialReference   GetEnvelope              Set3D                      
Boundary                 GetEnvelope3D            SetCoordinateDimension     
Buffer                   GetGeometryCount         SetMeasured                
Centroid                 GetGeometryName          SetPoint                   
Clone                    GetGeometryRef           SetPointM                  
CloseRings               GetGeometryType          SetPointZM                 
Contains                 GetLinearGeometry        SetPoint_2D                
ConvexHull               GetM                     Simplify                   
CoordinateDimension      GetPoint                 SimplifyPreserveTopology   
Crosses                  GetPointCount            SymDifference              
DelaunayTriangulation    GetPointZM               SymmetricDifference        
Difference               GetPoint_2D              Touches                    
Disjoint                 GetPoints                Transform                  
Distance                 GetSpatialReference      TransformTo                
Distance3D               GetX                     Union                      
Empty                    GetY                     UnionCascaded              
Equal                    GetZ                     Value                      
Equals                   HasCurveGeometry         Within                     
ExportToGML              Intersect                WkbSize                    
ExportToIsoWkb           Intersection             clone                      
ExportToIsoWkt           Intersects               delete                     
ExportToJson             Is3D                     equals                     
ExportToKML              IsEmpty                  hashCode                   
ExportToWkb              IsMeasured                                          

scala> currentPosition.GetX
res7: Double = 45.612195

scala> currentPosition.GetY
res8: Double = 25.588475

scala> val multiPointsHP1 = new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbMultiPoint)
multiPointsHP1: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@72b4f0

scala> val pointHP1 = new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbPoint)
pointHP1: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@720d40

scala> pointHP1.AddPoint(pointsHP1(0)._1, pointsHP1(0)._2)

scala> multiPointsHP1.AddGeometry(pointHP1)
res11: Int = 0

scala> multiPointsHP1.co
             CoordinateDimension      GetPointCount            
Contains     GetCoordinateDimension   SetCoordinateDimension   
ConvexHull   GetGeometryCount         hashCode                 

scala> multiPointsHP1.GetGeometry
GetGeometryCount   GetGeometryName   GetGeometryRef   GetGeometryType

scala> multiPointsHP1.GetGeometryCount
res12: Int = 1


scala> val geomsForMP = for (p<- pointsHP1) yield new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbPoint)
geomsForMP: Array[org.gdal.ogr.Geometry] = Array(org.gdal.ogr.Geometry@71f6d0, org.gdal.ogr.Geometry@7160b0, org.gdal.ogr.Geometry@710c10, org.gdal.ogr.Geometry@710c50, org.gdal.ogr.Geometry@724ec0, org.gdal.ogr.Geometry@724f00, org.gdal.ogr.Geometry@724f40, org.gdal.ogr.Geometry@724840, org.gdal.ogr.Geometry@724880, org.gdal.ogr.Geometry@7248c0, org.gdal.ogr.Geometry@724900, org.gdal.ogr.Geometry@724940, org.gdal.ogr.Geometry@724980, org.gdal.ogr.Geometry@7249c0, org.gdal.ogr.Geometry@724a00, org.gdal.ogr.Geometry@724a40, org.gdal.ogr.Geometry@724a80, org.gdal.ogr.Geometry@724ac0, org.gdal.ogr.Geometry@724b00, org.gdal.ogr.Geometry@724b40, org.gdal.ogr.Geometry@724b80, org.gdal.ogr.Geometry@724bc0, org.gdal.ogr.Geometry@724c00, org.gdal.ogr.Geometry@724c40, org.gdal.ogr.Geometry@724c80...
scala> val pointsForMP = geomsForMP.foreach(_.AddPoint(pointsHP(_)._1, pointsHP(_)._2))

scala> pointsHP1
res13: Array[(Double, Double)] = Array((45.631118,25.583995), (45.632863,25.586184), (45.633955,25.586698), (45.634345,25.587706), (45.63637,25.589595), (45.63673,25.589423), (45.639431,25.593006), (45.64245,25.598735), (45.642083,25.603038), (45.640676,25.607061), (45.639738,25.607404), (45.638925,25.607131), (45.636318,25.604551), (45.634559,25.602963), (45.633002,25.602048), (45.630514,25.59786), (45.630139,25.596379), (45.629801,25.596057), (45.629043,25.596454), (45.627693,25.595639), (45.627115,25.594705), (45.62638,25.59506), (45.625577,25.594877), (45.62622,25.592055), (45.626215,25.589502), (45.627325,25.589545), (45.628361,25.589137), (45.629576,25.587421), (45.631077,25.58388))

scala> val zippedGeomsPointsHP1 = geomsForMP.zip(pointsHP1)
zippedGeomsPointsHP1: Array[(org.gdal.ogr.Geometry, (Double, Double))] = Array((org.gdal.ogr.Geometry@71f6d0,(45.631118,25.583995)), (org.gdal.ogr.Geometry@7160b0,(45.632863,25.586184)), (org.gdal.ogr.Geometry@710c10,(45.633955,25.586698)), (org.gdal.ogr.Geometry@710c50,(45.634345,25.587706)), (org.gdal.ogr.Geometry@724ec0,(45.63637,25.589595)), (org.gdal.ogr.Geometry@724f00,(45.63673,25.589423)), (org.gdal.ogr.Geometry@724f40,(45.639431,25.593006)), (org.gdal.ogr.Geometry@724840,(45.64245,25.598735)), (org.gdal.ogr.Geometry@724880,(45.642083,25.603038)), (org.gdal.ogr.Geometry@7248c0,(45.640676,25.607061)), (org.gdal.ogr.Geometry@724900,(45.639738,25.607404)), (org.gdal.ogr.Geometry@724940,(45.638925,25.607131)), (org.gdal.ogr.Geometry@724980,(45.636318,25.604551)), (org.gdal.ogr.Geome...

scala> zippedGeomsPointsHP1(0)
res17: (org.gdal.ogr.Geometry, (Double, Double)) = (org.gdal.ogr.Geometry@71f6d0,(45.631118,25.583995))

scala> (res17._1).AddPoint((res17._2)._1, (res17._2)._2)

scala> (res17._1).GetX
res19: Double = 45.631118

scala> val pointsForMP = for (z <- zippedGeomsPointsHP1) yield ( (z._1).AddPoint((z._2)._1, (z._2)._2))
pointsForMP: Array[Unit] = Array((), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), ())

scala> for (z <- zippedGeomsPointsHP1)  ( (z._1).AddPoint((z._2)._1, (z._2)._2))

scala> zippedGeomsHP1(2)
<console>:19: error: not found: value zippedGeomsHP1
       zippedGeomsHP1(2)
       ^

scala> zippedGeomsPointsHP1(2)
res24: (org.gdal.ogr.Geometry, (Double, Double)) = (org.gdal.ogr.Geometry@710c10,(45.633955,25.586698))

scala> (zippedGeomsPointsHP1(2)._1).GetX
res25: Double = 45.633955

scala> (zippedGeomsPointsHP1(7)._1).GetX
res26: Double = 45.64245

scala> (zippedGeomsPointsHP1(7)._1).GetY
res27: Double = 25.598735

I'VE MANAGED TO ADD THE POINTS TO THE GEOMS with "for (z <- zippedGeomsPointsHP1)  ( (z._1).AddPoint((z._2)._1, (z._2)._2))"

scala> for (z <- zippedGeomsPointsHP1) multiPointsHP1.AddGeometry(z)
<console>:21: error: type mismatch;
 found   : (org.gdal.ogr.Geometry, (Double, Double))
 required: org.gdal.ogr.Geometry
       for (z <- zippedGeomsPointsHP1) multiPointsHP1.AddGeometry(z)
                                                                  ^

scala> for (z <- zippedGeomsPointsHP1) multiPointsHP1.AddGeometry(z._1)

scala> multiPointsHP1.Get
GetArea                  GetGeometryName     GetPoint_2D           
GetBoundary              GetGeometryRef      GetPoints             
GetCoordinateDimension   GetGeometryType     GetSpatialReference   
GetCurveGeometry         GetLinearGeometry   GetX                  
GetDimension             GetM                GetY                  
GetEnvelope              GetPoint            GetZ                  
GetEnvelope3D            GetPointCount                             
GetGeometryCount         GetPointZM                                

scala> multiPointsHP1.GetGeometryCount
res30: Int = 30

OK, SO I'VE CREATED A POINT, THEN A MULTIPOINT GEMOMETRY!


scala> pointsRoad1
res31: Array[(Double, Double)] = Array((45.612195,25.588475), (45.614445,25.590527), (45.620019,25.59437), (45.62319,25.594629), (45.625304,25.595018), (45.626392,25.595363), (45.62689,25.595169), (45.627222,25.595623), (45.628853,25.597199), (45.628929,25.597285), (45.629729,25.599574), (45.629442,25.600114), (45.630016,25.60128), (45.63059,25.603785), (45.631979,25.60629), (45.633806,25.609572), (45.637007,25.611947), (45.63678,25.614906), (45.636146,25.618339))

scala> val road1 = new org.gdal.ogr.Geometry(org.gdal.ogrConstants.wkbLineString)
<console>:18: error: object ogrConstants is not a member of package org.gdal
       val road1 = new org.gdal.ogr.Geometry(org.gdal.ogrConstants.wkbLineString)
                                                      ^

scala> val road1 = new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbLineString)
road1: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@7f6350

scala> for (p <- pointsRoad1) road1.AddPoint(p)
<console>:20: error: overloaded method value AddPoint with alternatives:
  (x$1: Double,x$2: Double)Unit <and>
  (x$1: Double,x$2: Double,x$3: Double)Unit
 cannot be applied to ((Double, Double))
       for (p <- pointsRoad1) road1.AddPoint(p)
                                    ^

scala> for (p <- pointsRoad1) road1.AddPoint(p._1, p._2)

scala> road1.
AddGeometry              ExportToWkt              IsRing                     
AddGeometryDirectly      FlattenTo2D              IsSimple                   
AddPoint                 GetArea                  IsValid                    
AddPointM                GetBoundary              Length                     
AddPointZM               GetCoordinateDimension   Overlaps                   
AddPoint_2D              GetCurveGeometry         PointOnSurface             
Area                     GetDimension             Segmentize                 
AssignSpatialReference   GetEnvelope              Set3D                      
Boundary                 GetEnvelope3D            SetCoordinateDimension     
Buffer                   GetGeometryCount         SetMeasured                
Centroid                 GetGeometryName          SetPoint                   
Clone                    GetGeometryRef           SetPointM                  
CloseRings               GetGeometryType          SetPointZM                 
Contains                 GetLinearGeometry        SetPoint_2D                
ConvexHull               GetM                     Simplify                   
CoordinateDimension      GetPoint                 SimplifyPreserveTopology   
Crosses                  GetPointCount            SymDifference              
DelaunayTriangulation    GetPointZM               SymmetricDifference        
Difference               GetPoint_2D              Touches                    
Disjoint                 GetPoints                Transform                  
Distance                 GetSpatialReference      TransformTo                
Distance3D               GetX                     Union                      
Empty                    GetY                     UnionCascaded              
Equal                    GetZ                     Value                      
Equals                   HasCurveGeometry         Within                     
ExportToGML              Intersect                WkbSize                    
ExportToIsoWkb           Intersection             clone                      
ExportToIsoWkt           Intersects               delete                     
ExportToJson             Is3D                     equals                     
ExportToKML              IsEmpty                  hashCode                   
ExportToWkb              IsMeasured                                          

scala> road1.GetGeometryCount
res34: Int = 0

scala> road1.AddPoint(pointsRoad1(0)._1, pointsRoad1(0)._2)

scala> road1.GetGeometryCount
res36: Int = 0

scala> road1.IsEmpty
res37: Boolean = false

scala> road1.GetPointCount
res38: Int = 20

I'VE CREATED A LINE!

scala> val road2 = new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbLineString)
road2: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@803220

scala> for (p <- pointsRoad2) road2.AddPoint(p._1, p._2)

scala> road2.GetPointCount
res40: Int = 9


scala> val road3 = new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbLineString)
road3: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@806060

scala> for (p <- pointsRoad3) road3.AddPoint(p._1, p._2)

scala> road3.GetPointCount
res42: Int = 8

scala> val habitatPatch1 = new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbPolygon)
habitatPatch1: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@7fd4a0

scala> val habitatRing = new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbLinearRing)
habitatRing: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@7fd220

scala> for (p<- pointsHP1) habitatRing.AddPoint(p._1, p._2)

scala> habitatRing.GetPoint
GetPoint   GetPointCount   GetPointZM   GetPoint_2D   GetPoints

scala> habitatRing.GetPointCount
res46: Int = 29

scala> habitatPatch1.AddGeometry(habitatRing)
res47: Int = 0

scala> habitatPatch1.
AddGeometry              ExportToWkt              IsRing                     
AddGeometryDirectly      FlattenTo2D              IsSimple                   
AddPoint                 GetArea                  IsValid                    
AddPointM                GetBoundary              Length                     
AddPointZM               GetCoordinateDimension   Overlaps                   
AddPoint_2D              GetCurveGeometry         PointOnSurface             
Area                     GetDimension             Segmentize                 
AssignSpatialReference   GetEnvelope              Set3D                      
Boundary                 GetEnvelope3D            SetCoordinateDimension     
Buffer                   GetGeometryCount         SetMeasured                
Centroid                 GetGeometryName          SetPoint                   
Clone                    GetGeometryRef           SetPointM                  
CloseRings               GetGeometryType          SetPointZM                 
Contains                 GetLinearGeometry        SetPoint_2D                
ConvexHull               GetM                     Simplify                   
CoordinateDimension      GetPoint                 SimplifyPreserveTopology   
Crosses                  GetPointCount            SymDifference              
DelaunayTriangulation    GetPointZM               SymmetricDifference        
Difference               GetPoint_2D              Touches                    
Disjoint                 GetPoints                Transform                  
Distance                 GetSpatialReference      TransformTo                
Distance3D               GetX                     Union                      
Empty                    GetY                     UnionCascaded              
Equal                    GetZ                     Value                      
Equals                   HasCurveGeometry         Within                     
ExportToGML              Intersect                WkbSize                    
ExportToIsoWkb           Intersection             clone                      
ExportToIsoWkt           Intersects               delete                     
ExportToJson             Is3D                     equals                     
ExportToKML              IsEmpty                  hashCode                   
ExportToWkb              IsMeasured                                          

scala> habitatPatch1.CloseRings()

scala> habitatPatch1.IsValid
res49: Boolean = true

OK, I'VE CREATED LINES AND A POLYGON!

scala> val habitatPatch2 = new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbPolygon)
habitatPatch2: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@803f30

scala> val habitatRing2 = new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbLinearRing)
habitatRing2: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@7d53c0

scala> for (p<- pointsHP2) habitatRing2.AddPoint(p._1, p._2)

scala> habitatRing2.GetPointCount
res53: Int = 32

scala> habitatPatch2.AddGeometry(habitatRing2)
res54: Int = 0

scala> habitatPatch2.isValid
<console>:20: error: value isValid is not a member of org.gdal.ogr.Geometry
       habitatPatch2.isValid
                     ^

scala> habitatPatch2.IsValid
ERROR 1: IllegalArgumentException: Points of LinearRing do not form a closed linestring
res56: Boolean = false

scala> val stArea = new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbPolygon)
stArea: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@7dac50

scala> val ringStArea = new org.gdal.ogr.Geometry(org.gdal.ogr.ogrConstants.wkbLinearRing)
ringStArea: org.gdal.ogr.Geometry = org.gdal.ogr.Geometry@7e3d70

scala> for (p <- pointsStArea) ringStArea.AddPoint(p._1, p._2)

scala> stArea.AddGeometry(ringStArea)
res59: Int = 0

scala> stArea.IsValid
ERROR 1: IllegalArgumentException: Points of LinearRing do not form a closed linestring
res60: Boolean = false


IT LOOKS LIKE i'VE FORGOTTEN TO CALL CloseRing() on the polygon!

----------------------------------------------------------


scala> import com.mai.GeospatialScala._
import com.mai.GeospatialScala._

scala> import Re
ReadPointCoordFromFile   Readable   ReflectiveOperationException   Responder

scala> import ReadPointCoordFromFile._
import ReadPointCoordFromFile._

scala> import CreateGeoms._
import CreateGeoms._

scala> CreateGeoms.
currentPosition   habitatPatch3   multiLineLines   road1                  
geomsForMP        habitatRing1    multiPointHP1    road2                  
gpsTrack1         habitatRing2    multiPolyPolys   road3                  
habitatPatch1     habitatRing3    multiPolygonEx   stArea                 
habitatPatch2     multiLineEx     ringStArea       zippedGeomsPointsHP1   

scala> org.gdal.ogr.ogr.GetDriverByName("ESRI Shapefile")
res3: org.gdal.ogr.Driver = org.gdal.ogr.Driver@28c4c640

scala> val driver = org.gdal.ogr.ogr.GetDriverByName("ESRI Shapefile")
driver: org.gdal.ogr.Driver = org.gdal.ogr.Driver@28c4c640

scala> val ds = driver.CreateDataSource("rdgps")
ds: org.gdal.ogr.DataSource = org.gdal.ogr.DataSource@2804e0c0

scala> val googleMapSR = new org.gdal.osr.SpatialReference()
googleMapSR: org.gdal.osr.SpatialReference =

scala> googleMapSR.ImportFromEPSG(3857)
res4: Int = 0

scala> val lyr = ds.CreateLayer("RoadsAndGPSTracks", googleMapSR, wkbMultiLineString)
<console>:22: error: not found: value wkbMultiLineString
       val lyr = ds.CreateLayer("RoadsAndGPSTracks", googleMapSR, wkbMultiLineString)
                                                                  ^

scala> val lyr = ds.CreateLayer("RoadsAndGPSTracks", googleMapSR, wkbMultilineString)
<console>:22: error: not found: value wkbMultilineString
       val lyr = ds.CreateLayer("RoadsAndGPSTracks", googleMapSR, wkbMultilineString)
                                                                  ^

scala> val lyr = ds.CreateLayer("RoadsAndGPSTracks", googleMapSR, wkbLineString) 
<console>:22: error: not found: value wkbLineString
       val lyr = ds.CreateLayer("RoadsAndGPSTracks", googleMapSR, wkbLineString)
                                                                  ^

scala> val lyr = ds.CreateLayer("RoadsAndGPSTracks", googleMapSR, org.gdal.ogr.ogrConstants.wkbMultiLineString)
lyr: org.gdal.ogr.Layer = org.gdal.ogr.Layer@28bfead0

scala> val fd1 = new org.gdal.ogr.FieldDefn("Type", OFTString)
<console>:20: error: not found: value OFTString
       val fd1 = new org.gdal.ogr.FieldDefn("Type", OFTString)
                                                    ^
---------------- new REPL session ____________________________

scala> val myConst = org.gdal.ogr.ogrConstants.OFTString
myConst: Int = 4

scala> import com.mai.GeospatialScala._
import com.mai.GeospatialScala._

scala> Create
CreateGeoms   CreateVLayer

scala> Create
CreateGeoms   CreateVLayer

scala> import CreateVLayer._
import CreateVLayer._

scala> val fd1 = new org.gdal.ogr.FieldDefn("Type", myConst)
fd1: org.gdal.ogr.FieldDefn = org.gdal.ogr.FieldDefn@307c4bb0

scala> val fd2 = new org.gdal.ogr.FieldDefn("ID", org.gdal.ogr.ogrConstants.OFTInteger)
fd2: org.gdal.ogr.FieldDefn = org.gdal.ogr.FieldDefn@307c5380

scala> ds.GetLayer(0)
res5: org.gdal.ogr.Layer = org.gdal.ogr.Layer@3010c1e0

scala> res5.CreateField(fd1)
res6: Int = 0

scala> res5.CreateField(fd2)
res7: Int = 0

scala> res5.Get
GetDescription    GetFeaturesRead         GetMetadataItem    GetRefCount        
GetExtent         GetGeomType             GetMetadata_Dict   GetSpatialFilter   
GetFIDColumn      GetGeometryColumn       GetMetadata_List   GetSpatialRef      
GetFeature        GetLayerDefn            GetName            GetStyleTable      
GetFeatureCount   GetMetadataDomainList   GetNextFeature                        

scala> res5.GetLayerDefn
res8: org.gdal.ogr.FeatureDefn = org.gdal.ogr.FeatureDefn@301122a0

scala> val usedDfn = res5.GetLayerDefn()
usedDfn: org.gdal.ogr.FeatureDefn = org.gdal.ogr.FeatureDefn@301122a0

scala> val feat1 = new org.gdal.ogr.Feature(usedDfn)
feat1: org.gdal.ogr.Feature = org.gdal.ogr.Feature@30119b30

scala> import CreateGeoms._
import CreateGeoms._

scala> feat1.SetGeometry(road1)
res13: Int = 0

scala> feat1.SetF
SetFID                        SetFieldInteger64     SetFrom          
SetField                      SetFieldIntegerList   SetFromWithMap   
SetFieldBinaryFromHexString   SetFieldNull                           
SetFieldDoubleList            SetFieldStringList                     

scala> feat1.SetField("Type", "road")

scala> fead1.SetField("ID", 1)
<console>:21: error: not found: value fead1
       fead1.SetField("ID", 1)
       ^

scala> feat1.SetField("ID", 1)

scala> res5.CreateFeature(feat1)
res17: Int = 0

scala> val feat2 = new org.gdal.ogr.Feature(usedDfn)
feat2: org.gdal.ogr.Feature = org.gdal.ogr.Feature@30886470

scala> feat2.SetGeometry(road2)
res18: Int = 0

scala> feat2.SetField("Type", "road")

scala> feat2.SetField("ID", 2)

scala> res5.CreateFeature(feat2)
res21: Int = 0

scala> val feat3 = new org.gdal.ogr.Feature(usedDfn)
feat3: org.gdal.ogr.Feature = org.gdal.ogr.Feature@30892c40

scala> feat3.SetGeometry(road3)
res22: Int = 0

scala> feat3.SetField("Type", "road")

scala> feat3.SetField("ID", 3)



\documentclass {article}

\title {Geospatial analysis in Scala}
\date {October 2017}

\usepackage {amsmath}
\usepackage {graphics}
\usepackage {verbatim}
\usepackage {cite}
\usepackage {booktabs}
\usepackage {float}
\usepackage [titletoc, toc, title] {appendix}
\usepackage {hyperref}
\usepackage [T1]{fontenc}

\author {Roxana Tesileanu \\
\\
\href{mailto: roxana.te@web.de}{roxana.te@web.de} \\
INCDS, Romania}

\begin {document}
	\maketitle

\tableofcontents

\section {Introduction}

The aim of the present paper is to investigate the use of some of the existing libraries for geospatial analysis available in Scala, the Geospatial Data Abstraction Library (GDAL) and Geotrellis, for performing the main geospatial analysis tasks: manipulating vector and raster data (geoprocessing) and geostatistics.
The former task will be approched using GDAL and the later using Geotrellis.  

\section {Geoprocessing using GDAL}

Using a programming language for geospatial analysis allows you to customize your analyses instead of being limited to what the software user interface allows. This is one of the most important advantages of open source software \cite{garrard_geoprocessing_2016}. The GDAL library is one of the open source libraries used in this work. It was written in C and C++ and has bindings for several languages (Java, Perl and Python). \\     
In order to use GDAL, you need to install it on your machine, and for its import in Scala you need to install its Java bindings along with it.  
For installation details you can look at the GDAL homepage \href{http://www.gdal.org/}{http://www.gdal.org/}, download GDAL and follow the instructions for building from source, which might not be an easy task, depending on your operating system. 
Thanks to the efforts of the UbuntuGIS team (\href{https://wiki.ubuntu.com/UbuntuGIS}{https://wiki.ubuntu.com/UbuntuGIS}), on Ubuntu, the installation procedure of GDAL and its bindings is done rapidly. Firstly, you need to add the ubuntugis PPA, which offers the official stable UbuntuGIS packages, to your system (\href{https://launchpad.net/~ubuntugis/+archive/ubuntu/ppa}{https://launchpad.net/~ubuntugis/+archive/ubuntu/ppa}). This is done with the commands: \\
\\
sudo add-apt-repository ppa:ubuntugis/ppa \\
sudo apt-get update.\\
\\
Next, you install GDAL on your machine with the commands \cite{safavi_installing_2015} \cite{noauthor_ubuntugis_nodate} (\href{http://www.sarasafavi.com/installing-gdalogr-on-ubuntu.html}{http://www\\.sarasafavi.com/installing-gdalogr-on-ubuntu.html}, \href{https://packages.ubuntu.com/source/trusty/gdal}{https://packages.ubuntu.co\\m/source/trusty/gdal}):\\
\\
sudo apt-get install libproj-dev, gdal-bin, libgdal-dev, libgdal-doc \\
sudo apt-get update.\\
\\
Finally, you add the Java bindings to your GDAL package (\href{https://launchpad.net/ubuntu/+source/proj}{https://launchpad.ne\\ t/ubuntu/+source/proj}):\\
\\
sudo apt-get install libgdal-java, libproj-java.    \\
\\
In order to import GDAL in Scala, you have to add its jar to the project's classpath. An easy way of managing dependencies of a Scala project is to use SBT (for further details see \cite{tesileanu_using_2017}). In this way you can take advantage of the most convenient way to place the gdal jar to the project's classpath, namely, to place a copy of it into the lib directory of the Scala project, now that the actual installation has already taken place. \\ 
\\
The following subsections will offer a background in geoprocessing, starting with manipulating vector data (reading and writing files of different vector data formats and performing overlay and proximity analyses), and continuing with manipulating raster data (reading and writing files of different raster data formats, resizing pixels, performing moving window analyses and map algebra).    

\subsection {Types of spatial data}

Spatial data are divided in two categories: vector data and raster data. Vector data provide information about distinct features in space, i.e. different distinct items of interest, and are made up of points, lines and polygons \cite{garrard_geoprocessing_2016}. The features of interest could be for example:
\begin{itemize}
\item roads, rivers, road networks, hidrological networks, country boundaries, city boundaries as examples of features represented by lines,
\item  mountain peaks, volcano peaks, weather stations, restaurants, as examples of features represented by points, and 
\item lakes, oceans, ownership status as examples of features represented by polygons.     
\end{itemize}
Features have attributes attached to them such as the name of the individual observations (for example the wheather stations's name) and other recorded variables (like for example different concentrations of air pollutants, temperature or wind regime for each individual weather station). As it can be noticed, the multiple attributes which can be attached to features, can be of different types, and they actually represent different types of recorded variables (they might be dicrete or continuous numerical variables or categorical variables). \\ 
\\
On the other hand, raster data provide information about characteristics of interest which take the form of a continuum like gradients, with no distinct boundaries. They are represented as two- or three-dimensional arrays of data values which form grids of values \cite{garrard_geoprocessing_2016}.
Because they can cope well with gradients, they capture local variation more easily than vector geometries, and are used in digital elevation models (DEMs). Also because the data source is pixel-based (e.g. aerial photos, satellite imagery) they can be used in vegetation mapping.     

\subsection {Reading vector data}

The main objective of vector data analysis is to investigate relationships between features, by overlapping them on another or measuring distances between them \cite{garrard_geoprocessing_2016}. 
A typical example for vector analyses is the investigation of GPS-collared wildlife to see the direction of travel, distances covered and how they interact with man-made features like roads \cite{garrard_geoprocessing_2016}. \\
In order to perform such vector-based analyses, we need to be able to read, edit and write vector data. This kind of functionality is offered by the OGR Simple Features Library for geoprocessing vector data, which is included in GDAL. \\
\\
At this point it is noted that the Scala code relating to using the GDAL functionality introduced in this document has its origins in the Python code written by Chris Garrard in her book "Geoprocessing with Python" (2016). The main reason for the transition towards using Scala for geospatial analysis is the use of Scala's functional nature for the further processing of geodata, by using higher-order functions. \\
\\
There are many different types of vector data formats. Among the most widely used ones are: the ESRI shapefile, the GeoJSON file, or the SpatiaLite or PostGIS databases. 
The ESRI shapefile format requires a minimum of three binary files, each of which serves a different purpose: geometry information is stored in .shp and .shx files, and attribute values are stored in a .dbf file. You need to make sure they are all grouped in the same folder, because they work together \cite{garrard_geoprocessing_2016}. The GeoJSON format is used mainly for web-mapping applications and is a plain text file which can be easily examined. The GeoJSON format consists of a single file. Vector data can also be stored in relational databases with spatial extensions. The most widely used spatial extensions are SpatiaLite (for SQLite databases) and PostGIS (for PostgreSQL). 
You can check other vector data formats supported by GDAL at \href{http://www.gdal.org/ogr_formats.html}{http://www.gdal.org/ogr\underline{\space}formats.html}. \\ 
\\
The OGR package of GDAL contains the classes used for geoprocessing vector data. The OGR Java Application Programming Interface (API) \cite{noauthor_gdal_nodate} (\href{http://gdal.org/java/}{http://gdal.\\org/java/}) lists them all.
 Among them there are the classes: Driver, DataSource, Layer, Geometry and Feature. In order to handle vector geodata with OGR, we need to understand how the geospatial information is organized in OGR. The spatial vector data is stored in a data source (for example a shapefile, a GeoJSON file, or a SpatiaLite or PostGIS database). This data source object can have one or more layers, one for each dataset contained in the data source. Many vector formats, such as shapefiles can only contain one dataset, thus have one layer, but others like SpatiaLite can contain multiple datasets, thus have multiple layers. Each layer contains a collection of features, which holds the geometries (like for example points, lines, polygons) and their attributes  \cite{garrard_geoprocessing_2016}. \\
\\
The first step in accessing any vector data is to open the data source. For this you need to use a driver specific to the data format. Each vector data format has its own driver, which is used to read and write a particular format \cite{garrard_geoprocessing_2016}.\\
In order to make the configured OGR drivers available we call the RegisterAll() function at the beginning of the analysis. The RegisterAll() function is placed in the package OGR of the GDAL library, in the class ogr, so we need to call it using org.gdal.ogr.ogr.RegisterAll() (or, we can also import the class to save typing, but it remains unclear where the function resides inside GDAL).                     
\paragraph{ Code snippet 1: accessing a shapefile using OGR in Scala} 
\\
You can find a shapefile on the internet at one of the sources indicated under \href{http://gisgeography.com/best-free-gis-data-sources-raster-vector/}{http://gisgeography.com/best-free-gis-data-sources-raster-vector/} and try the following snippet with your shapefile using the Scala REPL in SBT while you are in the Scala project's directory: \\
\\
org.gdal.ogr.ogr.RegisterAll() \\
\\
val dataSource = org.gdal.ogr.ogr.Open("example.shp")\\  
dataSource: org.gdal.org.DataSource = org.gdal.ogr.DataSource@305c6b70 \\
\\
dataSource.GetLayerCount \\
res1: Int = 1 \\
\\
val lyr = dataSource.GetLayer(0) \\
lyr: org.gdal.ogr.Layer = org.gdal.ogr.Layer@305ca330 \\ 
\\
lyr.GetName \\
res2: String = example \\
\\
lyr.GetFeatureCount \\
res3: Long = 927 \\
\\
val feat0 = lyr.GetFeature(0) \\
feat0 : org.gdal.ogr.Feature = org.gdal.ogr.Feature@3164b9a0\\
\\
dataSource.delete() \\

\paragraph {Code snippet 1: explanation}
\\
In order to access the vector geodata, we make the OGR drivers available with RegisterAll(). 
Then, we create a variable called dataSource in which we store the DataSource object. We obtain it by opening the shapefile (or any other OGR file format) with Open(). 
We check how many layers (i.e. datasets) are available in the DataSource object by calling GetLayerCount on it. 
Further, we retrieve the first layer (which has the index 0), with GetLayer(0), obtaining a variable called lyr in which we store it. 
You can check its name or the number of features it contains, with GetName or GetFeatureCount. You can see the available functions on the lyr with the help of autocompletion. Autocompletion works for example by typing lyr. followed by a $<$TAB$>$. This lists all the methods available for that object. 
We continue, by retrieving the first feature (which has the index 0) of the layer called lyr with GetFeature(0). You can check with autocompletion the methods available on it.  
At the end of the code snippet we close the data source.      
\\
\\
Geodata would actually be "normal" data without georeferencing. In the next subsection, we learn how to deal with spatial reference systems of already georeferenced features, and how to construct our own geometries and features and how to georeference them. 

   

\subsection {Georeferencing data}      

- investigate georeferenced data\\
- construct new geometries and features\\
- georeference new features\\
In order to be able to locate some coordinates on a map, you need to know what spatial reference system is used for the coordinates and what spatial reference system uses the map. If they are not the same, you need to perform transformations from one spatial reference system to another. Georeferencing the data means adding the information regarding the spatial reference system used when defining the features.\\
A spatial reference system is made of three components \cite{garrard_geoprocessing_2016}: \begin{itemize}
\item a coordinate system,
\item a datum and,
\item a projection.
\end{itemize}
The set of coordinates is provided by a coordinate system, the datum specifies the model used to represent the curvature of the earth and a projection is used to transform the three-dimensional globe to a two-dimensional map. 
A set of coordinates is represented as set of two pieces of information: the latitude and the longitude. Positive latitude values are north of the equator, and positive longitudes are east of the prime meridian. Multiple methods exist for specifying latitude and longitude coordinates: decimal degrees (DD), degrees decimal minutes (DM) and degrees minutes seconds (DMS) \cite{garrard_geoprocessing_2016}. But, if you don't specify the datum used, the same set of latitude and longitude coordinates can refer to slightly different locations, because different datums represent different ellipsoids of different shapes.
 One of the most widely used datums is the World Geodetic System, last revised in 1984. This datum, also called WGS84, is also used by the Global Positioning System (GPS). WGS84 has a global coverage. But most datums model the curvature of the earth in a more localized area (a continent or a country). A datum designed for an area will not work well elsewhere \cite{garrard_geoprocessing_2016}. Sometimes the difference between two datums can be of hundreds of meters for the same set of coordinates.
\\
 Projections convert the coordinates of a point on the globe to the coordinates of a point on a two-dimensional plane. In doing so, it creates distortions. The type of distortion depends on how the conversion is done. If you would like to preserve local shapes, you should use conformal projections, like for example Universal Transverse Mercator (UTM) \cite{garrard_geoprocessing_2016}. To keep the amount of area the same, you should use equal-area projections, like for example the Lambert equal-area or Gall-Peters projections. Thus, sometimes using geographic coordinates (lat/lon), is not appropriate, depending on the aims of your analysis, and you need to choose a projection instead. Also, note that projections are not tied to specific datums, so knowing the projection of your data is not enough. You also have to know the datum used.           
\\
You can search for spatial reference systems on the epsg.io website under \href{http://epsg.io/}{http://\\epsg.io/}. The SRSs for Romania for example can be found under the link: \href{http://epsg.io/?q=Romania}{http://epsg.io/?q=Romania}.

\subsubsection{Spatial reference systems in OGR}

OGR provides ways of storing and converting the information regarding the spatial reference system (SRS) used for vector data in its package called OGR Spatial Reference (OSR).   
You can find out the SRS used by a georeferenced layer, by calling the GetSpatialRef function on it. If the layer is not georeferenced it returns null.  
\\
\\
lyr.GetSpatialRef \\
res10: org.gdal.osr.SpatialReference = \\
GEOGCS["GCS\underline{\space}WGS\underline{\space}1984",\\
\hspace*{2mm}DATUM["WGS\underline{\space}1984",\\
\hspace*{4mm}SPHEROID["WGS\underline{\space}84",6378137,298.257223563]],\\
\hspace*{2mm}PRIMEM["Greenwich",0],\\
\hspace*{2mm}UNIT["Degree",0.017453292519943295],\\
\hspace*{2mm}AUTHORITY["EPSG","4326"]] \\
\\
\\
lyr.GetSpatialRef \\
res14: org.gdal.osr.SpatialReference = \\
PROJCS["ETRS\underline{\space}1989\underline{\space}LAEA", \\
\hspace*{2mm} GEOGCS["GCS\underline{\space}ETRS\underline{\space}1989",\\
\hspace*{4mm} DATUM["European\underline{\space}Terrestrial\underline{\space}Reference\underline{\space}System\underline{\space}1989",\\
\hspace*{6mm} SPHEROID["GRS\underline{\space}1980",6378137.0,298.257222101]],\\
\hspace*{4mm} PRIMEM["Greenwich",0.0],\\
\hspace*{4mm} UNIT["Degree",0.0174532925199433]],\\
\hspace*{2mm} PROJECTION["Lambert\underline{\space}Azimuthal\underline{\space}Equal\underline{\space}Area"],\\
 \hspace*{2mm}   PARAMETER["False\underline{\space}Easting",4321000.0],\\
 \hspace*{2mm}   PARAMETER["False\underline{\space}Northing",3210000.0],\\
 \hspace*{2mm}   PARAMETER["longitude\underline{\space}of\underline{\space}center",10.0],\\
 \hspace*{2mm}   PARAMETER["latitude\underline{\space}of\underline{\space}center",52.0],\\
 \hspace*{2mm}   UNIT["Meter",1.0]]\\
\\
\\
The first spatial reference from above is not a projected SRS, because it has a GEOCS entry only, without a PROJCS one. But, we can still see that the datum used is WGS1984, the spheroid used is WGS84, the unit used for the set of coordinates is degree and the authority giving the ID code is EPSG (short for European Petroleum Survey Group).  
The second spatial reference from above is a projected one. It has a PROJCS entry, the projection used is the LAEA (Lambert Azimuthal Equal-Area projection). The datum is ETRS 1989 (European Terrestrial Reference System 1989). The SRS is thus the ETRS1989/LAEA. The unit of measure is 1.0 m. 
\\
\\
The function GetSpatialRef called on a layer returns a SpatialReference object. Georeferenced data already have such an object defined, if not the GetSpatialRef function returns null. In order to create a SpatialReference object for your layers and geometries you need to firstly create an empty SpatialReference object, then you have to import into the empty SpatialReference object the information on the SRS you want to use, turning it into a valid SpatialReference object.        
 
\paragraph {Code snippet 2: creating a SpatialReference object using OGR in Scala}
\\
In this code I will use the ETRS1989/LAEA, the Pulkovo1942(58)/ Stereo70 and the WGS84/Pseudo-Mercator SRS. The first one is the SRS for all Europe and it is used for statistical mapping at all scales and other purposes where true area representation is required (\href{http://spatialreference.org/ref/epsg/3035/}{http://spatialreference.org/ref/epsg/\\3035/}), the second SRS is for Romania and is used in large and medium scale topographic mapping and engineering surveys (\href{http://spatialreference.org/ref/epsg/3844/}{http://spatialreference.org/ref/eps\\g/3844/}), and the third is used for rendering maps in GoogleMaps, OpenStreetMap, Bing a.o. (\href{http://epsg.io/3857}{http://epsg.io/3857}). 
Google Earth uses WGS84 with geographic coordinates (lat/lon), unprojected, with EPSG code 4326 (\href{https://gis.stackexchange.com}{https://gis.s\\tackexchange.com}) (see the first SRS example at page 7, section 2.3.1). 
\\
\\
val newSR = new org.gdal.osr.SpatialReference()\\
newSR: org.gdal.osr.SpatialReference = \\
\\
newSR.ImportFromEPSG(3035) \\
res1: Int = 0 \\
\\
newSR \\
res2: org.gdal.osr.SpatialReference = \\
PROJCS["ETRS89 / LAEA Europe",\\
\hspace*{2mm} GEOGCS["ETRS89",\\
\hspace*{4mm} DATUM["European\underline{\space}Terrestrial\underline{\space}Reference\underline{\space}System\underline{\space}1989",\\
\hspace*{6mm} SPHEROID["GRS 1980",6378137,298.257222101,\\
\hspace*{8mm} AUTHORITY["EPSG","7019"]],\\
\hspace*{6mm} TOWGS84[0,0,0,0,0,0,0],\\
\hspace*{8mm} AUTHORITY["EPSG","6258"]],\\
\hspace*{4mm} PRIMEM["Greenwich",0], \\
\hspace*{8mm} AUTHORITY["EPSG","8901"]], \\
\hspace*{4mm} UNIT["degree",0.0174532925199433,\\
\hspace*{8mm} AUTHORITY["EPSG","9122"]],\\
\hspace*{4mm} AUTHORITY["EPSG","4258"]],\\
\hspace*{2mm}PROJECTION["Lambert\underline{\space}Azimuthal\underline{\space}Equal\underline{\space}Area"],\\
\hspace*{2mm} PARAMETER["latitude\underline{\space}of\underline{\space}center",52],\\
\hspace*{2mm} PARAMETER["longitude\underline{\space}of\underline{\space}center",10],\\
\hspace*{2mm} PARAMETER["false\underline{\space}easting",4321000],\\
\hspace*{2mm} PARAMETER["false\underline{\space}northing",3210000],\\
\hspace*{2mm} UNIT["metre",1,\\
\hspace*{4mm} AUTHORITY["EPSG","9001"]],\\
\hspace*{2mm} AUTHORITY["EPSG","30...\\
\\
val newSR2 = new ogr.gdal.osr.SpatialReference() \\
newSR2: org.gdal.osr.SpatialReference = \\
\\
newSR2.ImportFromProj4("+proj=laea +lat\underline{\space}0=52 +lon\underline{\space}0=10 +x\underline{\space}0=4321000 +y\underline{\space}0=3210000 +ellps=GRS80 +units=m +no\underline{\space}defs ") \\
res3: Int = 0 \\
\\
newSR2 \\
res4: org.gdal.osr.SpatialReference= \\
PROJCS["unnamed", \\
\hspace*{2mm} GEOGCS["GRS 1980(IUGG, 1980)", \\
\hspace*{4mm} DATUM["unknown", \\
\hspace*{6mm} SPHEROID["GRS80",6378137,298.257222101],\\
\hspace*{6mm} TOWGS84[0,0,0,0,0,0,0]], \\
\hspace*{4mm} PRIMEM["Greenwich",0], \\
\hspace*{4mm} UNIT["degree",0.0174532925199433]],\\
\hspace*{2mm} PROJECTION["Lambert\underline{\space}Azimuthal\underline{\space}Equal\underline{\space}Area"],\\
\hspace*{2mm} PARAMETER["latitude\underline{\space}of\underline{\space}center",52],\\
\hspace*{2mm} PARAMETER["longitude\underline{\space}of\underline{\space}center",10],\\
\hspace*{2mm} PARAMETER["false\underline{\space}easting",4321000],\\
\hspace*{2mm} PARAMETER["false\underline{\space}northing",3210000],\\
\hspace*{2mm} UNIT["Meter",1]]\\
\\
val newSR3 = new org.gdal.osr.SpatialReference() \\
newSR3: org.gdal.osr.SpatialReference = \\
\\
newSR3.ImportFromWkt("""PROJCS["ETRS89 / ETRS-LAEA",\\
     |    \hspace*{4mm} GEOGCS["ETRS89", \\
     |    \hspace*{6mm} DATUM["European\underline{\space}Terrestrial\underline{\space}Reference\underline{\space}System\underline{\space}1989",\\
     |     \hspace*{8mm} SPHEROID["GRS 1980",6378137,298.257222101,\\
     |     \hspace*{10mm} AUTHORITY["EPSG","7019"]],\\
     |     \hspace*{8mm} AUTHORITY["EPSG","6258"]],\\
     |     \hspace*{6mm} PRIMEM["Greenwich",0,\\
     |     \hspace*{8mm} AUTHORITY["EPSG","8901"]],\\
     |     \hspace*{6mm} UNIT["degree",0.01745329251994328,\\
     |     \hspace*{8mm} AUTHORITY["EPSG","9122"]],\\
     |     \hspace*{6mm} AUTHORITY["EPSG","4258"]],\\
     |     \hspace*{4mm} UNIT["metre",1,\\
     |     \hspace*{6mm} AUTHORITY["EPSG","9001"]],\\
     |     \hspace*{4mm} PROJECTION["Lambert\underline{\space}Azimuthal\underline{\space}Equal\underline{\space}Area"],\\
     |     \hspace*{4mm} PARAMETER["latitude\underline{\space}of\underline{\space}center",52],\\
     |     \hspace*{4mm} PARAMETER["longitude\underline{\space}of\underline{\space}center",10],\\
     |     \hspace*{4mm} PARAMETER["false\underline{\space}easting",4321000],\\
     |     \hspace*{4mm} PARAMETER["false\underline{\space}northing",3210000],\\
     |     \hspace*{4mm} AUTHORITY["EPSG","3035"],\\
     |     \hspace*{4mm} AXIS["X",EAST],\\
     |     \hspace*{4mm} AXIS["Y",NORTH]]""")\\
res9: Int = 0\\
\\
\\
newSR3\\
res10: org.gdal.osr.SpatialReference =\\
PROJCS["ETRS89 / ETRS-LAEA",\\
\hspace*{2mm} GEOGCS["ETRS89",\\
\hspace*{4mm} DATUM["European\underline{\space}Terrestrial\underline{\space}Reference\underline{\space}System\underline{\space}1989",\\
\hspace*{6mm} SPHEROID["GRS 1980",6378137,298.257222101,\\
\hspace*{8mm} AUTHORITY["EPSG","7019"]],\\
\hspace*{6mm} AUTHORITY["EPSG","6258"]],\\
\hspace*{4mm} PRIMEM["Greenwich",0,\\
\hspace*{6mm} AUTHORITY["EPSG","8901"]],\\
\hspace*{4mm} UNIT["degree",0.01745329251994328,\\
\hspace*{6mm} AUTHORITY["EPSG","9122"]],\\
\hspace*{4mm} AUTHORITY["EPSG","4258"]],\\
\hspace*{2mm} UNIT["metre",1,\\
\hspace*{4mm} AUTHORITY["EPSG","9001"]],\\
\hspace*{2mm} PROJECTION["Lambert\underline{\space}Azimuthal\underline{\space}Equal\underline{\space}Area"],\\
\hspace*{2mm} PARAMETER["latitude\underline{\space}of\underline{\space}center",52],\\
\hspace*{2mm} PARAMETER["longitude\underline{\space}of\underline{\space}center",10],\\
\hspace*{2mm} PARAMETER["false\underline{\space}easting",4321000],\\
\hspace*{2mm} PARAMETER["false\underline{\space}northing",3210000],\\
\hspace*{2mm} AUTHORITY["EPSG","3035"],\\
\hspace*{2mm} AXIS["X",EAST],\\
\hspace*{2mm} AXIS["...\\
\\
val roSR1 = new org.gdal.osr.SpatialReference()\\
roSR1: org.gdal.osr.SpatialReference = \\
\\
roSR1.ImportFromEPSG(3844) \\
res11: Int = 0 \\
\\
roSR1\\
res12: org.gdal.osr.SpatialReference = \\
PROJCS["Pulkovo 1942(58) / Stereo70",\\
\hspace*{2mm} GEOGCS["Pulkovo 1942(58)",\\
\hspace*{4mm} DATUM["Pulkovo\underline{\space}1942\underline{\space}58",\\
\hspace*{6mm} SPHEROID["Krassowsky 1940",6378245,298.3,\\
\hspace*{8mm} AUTHORITY["EPSG","7024"]],\\
\hspace*{6mm} TOWGS84[2.329,-147.042,-92.08,0.309,-0.325,-0.497,5.69],\\
\hspace*{6mm} AUTHORITY["EPSG","6179"]],\\
\hspace*{4mm} PRIMEM["Greenwich",0,\\
\hspace*{6mm} AUTHORITY["EPSG","8901"]],\\
\hspace*{4mm} UNIT["degree",0.0174532925199433,\\
\hspace*{6mm} AUTHORITY["EPSG","9122"]],\\
\hspace*{4mm} AUTHORITY["EPSG","4179"]],\\
\hspace*{2mm} PROJECTION["Oblique\underline{\space}Stereographic"],\\
\hspace*{2mm} PARAMETER["latitude\underline{\space}of\underline{\space}origin",46],\\
\hspace*{2mm} PARAMETER["central\underline{\space}meridian",25],\\
\hspace*{2mm} PARAMETER["scale\underline{\space}factor",0.99975],\\
\hspace*{2mm} PARAMETER["false\underline{\space}easting",500000],\\
\hspace*{2mm} PARAMETER["false\underline{\space}northing",500000],\\
\hspace*{2mm} UNIT["metre",1,\\
\hspace*{2mm} A...\\
\\
val roSR2 = new org.gdal.osr.SpatialReference() \\
roSR2: org.gdal.osr.SpatialReference = \\
\\
roSR2.ImportFromWkt("""PROJCS["Pulkovo 1942(58) / Stereo70",\\
 |\hspace*{2mm} GEOGCS["Pulkovo 1942(58)",\\
 |\hspace*{4mm} DATUM["Pulkovo 1942(58)",\\
 |\hspace*{6mm} SPHEROID["Krassowsky 1940",6378245.0,298.3,\\
 |\hspace*{8mm} AUTHORITY["EPSG","7024"]],\\
 |\hspace*{6mm} TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.17326243724756094],\\
 |\hspace*{6mm} AUTHORITY["EPSG","6179"]],\\
 |\hspace*{4mm} PRIMEM["Greenwich",0.0,\\
 |\hspace*{6mm} AUTHORITY["EPSG","8901"]],\\
 |\hspace*{4mm} UNIT["degree",0.017453292519943295],\\
 |\hspace*{4mm} AXIS["Geodetic latitude",NORTH],\\
 |\hspace*{4mm} AXIS["Geodetic longitude",EAST],\\
 |\hspace*{4mm} AUTHORITY["EPSG","4179"]],\\
 |\hspace*{2mm} PROJECTION["Oblique Stereographic",\\
 |\hspace*{4mm} AUTHORITY["EPSG","9809"]],\\
 |\hspace*{2mm} PARAMETER["central\underline{\space}meridian",25.0],\\
 |\hspace*{2mm} PARAMETER["latitude\underline{\space}of\underline{\space}origin",46.0],\\
 |\hspace*{2mm} PARAMETER["scale\underline{\space}factor",0.99975],\\
 |\hspace*{2mm} PARAMETER["false\underline{\space}easting",500000.0],\\
 |\hspace*{2mm} PARAMETER["false\underline{\space}northing",500000.0],\\
 |\hspace*{2mm} UNIT["m",1.0],\\
 |\hspace*{2mm} AXIS["Northing",NORTH],\\
 |\hspace*{2mm} AXIS["Easting",EAST],\\
 |\hspace*{2mm} AUTHORITY["EPSG","3844"]]""")\\
res16: Int = 0\\
\\
roSR2\\
res17: org.gdal.osr.SpatialReference =\\
PROJCS["Pulkovo 1942(58) / Stereo70",\\
\hspace*{2mm} GEOGCS["Pulkovo 1942(58)",\\
\hspace*{4mm} DATUM["Pulkovo 1942(58)",\\
\hspace*{6mm} SPHEROID["Krassowsky 1940",6378245.0,298.3,\\
\hspace*{8mm} AUTHORITY["EPSG","7024"]],\\
\hspace*{6mm} TOWGS84[33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.17326243724756094],\\
\hspace*{6mm} AUTHORITY["EPSG","6179"]],\\
\hspace*{4mm} PRIMEM["Greenwich",0.0,\\
\hspace*{6mm} AUTHORITY["EPSG","8901"]],\\
\hspace*{4mm} UNIT["degree",0.017453292519943295],\\
\hspace*{4mm} AXIS["Geodetic latitude",NORTH],\\
\hspace*{4mm} AXIS["Geodetic longitude",EAST],\\
\hspace*{4mm} AUTHORITY["EPSG","4179"]],\\
\hspace*{2mm} PROJECTION["Oblique Stereographic",\\
\hspace*{4mm} AUTHORITY["EPSG","9809"]],\\
\hspace*{2mm} PARAMETER["central\underline{\space}meridian",25.0],\\
\hspace*{2mm} PARAMETER["latitude\underline{\space}of\underline{\space}origin",46.0],\\
\hspace*{2mm} PARAMETER["scale\underline{\space}factor",0.99975],\\
\hspace*{4mm} PAR...\\
\\
val googleMapsSR = new org.gdal.osr.SpatialReference()\\
googleSR: org.gdal.osr.SpatialReference = \\
\\
googleMapsSR.ImportFromEPSG(3857) \\
res18: Int = 0 \\
\\
googleMapsSR \\
res19: org.gdal.osr.SpatialReference = \\
PROJCS["WGS 84 / Pseudo-Mercator",\\
\hspace*{2mm} GEOGCS["WGS 84",\\
\hspace*{4mm} DATUM["WGS\underline{\space}1984",\\
\hspace*{6mm} SPHEROID["WGS 84",6378137,298.257223563,\\
\hspace*{8mm} AUTHORITY["EPSG","7030"]],\\
\hspace*{6mm} AUTHORITY["EPSG","6326"]],\\
\hspace*{4mm} PRIMEM["Greenwich",0,\\
\hspace*{6mm} AUTHORITY["EPSG","8901"]],\\
\hspace*{4mm} UNIT["degree",0.0174532925199433,\\
\hspace*{6mm} AUTHORITY["EPSG","9122"]],\\
\hspace*{4mm} AUTHORITY["EPSG","4326"]],\\
\hspace*{2mm} PROJECTION["Mercator\underline{\space}1SP"],\\
\hspace*{2mm} PARAMETER["central\underline{\space}meridian",0],\\
\hspace*{2mm} PARAMETER["scale\underline{\space}factor",1],\\
\hspace*{2mm} PARAMETER["false\underline{\space}easting",0],\\
\hspace*{2mm} PARAMETER["false\underline{\space}northing",0],\\
\hspace*{2mm} UNIT["metre",1,\\
\hspace*{4mm} AUTHORITY["EPSG","9001"]],\\
\hspace*{2mm} AXIS["X",EAST],\\
\hspace*{2mm} AXIS["Y",NORTH],\\
\hspace*{2mm} EXTENSION["PROJ4","+proj=merc +a=6378137 +b=6378137 +lat\underline{\space}ts=0.0 +lon\underline{\space}0=0.0 +x\underline{\space}0=0.0 +y...\\
\\
\paragraph{Code snippet 2: explanation}
In code snippet 2 we've created new empty SpatialReference objects, in which we've imported information on the used SRS using more sources: the EPSG code, the PROJ4 string, and the WKT string. There are also more ways of importing. You can inspect them with autocompletion on an empty SpatialReference object. 
\\
\\
In this section we've seen it is important to know the SRS used for your geodata. You can create a SRS using an empty SpatialReference object and importing the information needed using its EPSG code, WKT or PROJ4 string.
 The important fact to know, if your data comes from the GPS, is that this system uses WGS84 unprojected (EPSG code 4326). If you use Google Earth (EPSG code 4326) and try to map them on Google Maps (EPSG code 3857) you don't have the same SRS. You need to be able to make transformations between different SRSs. We will do this in the following sections, after we learn how to create individual geometries and entire layers.

\subsubsection {Creating OGR geometries and vector layers}

In this section I will use points looked up on Google Maps (so, using WGS84 / Pseudo-Mercator) and stored in a .csv file to create OGR geometries like Points, Lines or Polygons and their multi-versions. 
Then I will create a new empty georeferenced vector layer by means of a driver which will create the data source in which the empty vector layer will be stored. 
Then I will create the attribute fields for the empty layer, which will be stored in the layer definition.
 Then, I will create the features which will contain the previously created geometries and their attribute fields.
Finally, I will insert the features into the new layer. 

\paragraph {Code snippet 3: Reading point coordinates from a .csv file}

Suppose you have looked up your point coordinates on Google Maps or Google Earth and know what features you will have and what geometries you should use for your project. 
You should now create a .csv file (from converting either an EXCEL or a LIBRE OFFICE CALC file with "Save As" and choosing .csv format), in which you have three columns: the first one is the longitute (E/W), the second one is the latitude (N/S), and the third one represents the ID number of your feaures (from 1 to the last feature).
 I've created such a file for this code snippet. You can inspect it at \href{https://github.com/RoxanaTesileanu/multivariate_analyses/blob/master/DeepLearning/pointcoord.csv}{https://github.com/RoxanaTesileanu/multivariate\underline{\space}analyses/blob\\/master/DeepLearning/pointcoord.csv}. Now, according to the point coordinates in the pointcoord.csv file, we're going to create 8 features for our project:
\begin{itemize} 
\item the first group of points (ID 1) is for the first polygon which will be the representation of the first habitat patch (habitatPatch1) and is the Tampa Hill in Brasov,
\item the second group of points (ID 2) is for the first road which will be the representation of a road in Racadau Area in Brasov,
\item the third group of points (ID 3) is for the second road which will be the representation of a road in Carpatilor Area in Brasov,
\item the fourth group of points (ID 4) is for the third road which will be the representation of a road in Noua Quarter in Brasov,
\item the fifth group of points (ID 5) is for the second polygon which will be the representation of the second habitat patch (habitatPatch2) and is the Noua Forest Area,
\item the sixth group of points (ID 6) is for the represenation of a GPS-track for an imaginary radio-collared bear individual,
\item the seventh group of points (ID 7) is for a polygon which will be the representation of a third habitat patch (habitatPatch3) toward Postavaru Peak in Poiana Brasov,
\item the eigth group of points (ID 8) is for the fourth polygon which will be the representation for our study area. 
\end {itemize}
Of course, these features are created for educational purposes. I haven't included as many points as necessary for a detailed representation of the items. Also, if you include more features (additional roads, more GPS-tracks, more habitat patches, etc.) then the results should be useful for further research purposes. The aim of this tutorial is to show how you can construct your features from point coordinates and how to perform spatial analyses on them whatever number of features you consider appropriate for your own purposes and whatever number of point coordinates you use for their representation.      
\\
\\
After this general presentation of the data we're going to use, we can continue and read the points into Scala (parse them):
\\
\\
import scala.io.\underline{\space} \\
val source = Source.fromFile("pointcoord.csv")\\
val data = source.getLines.map(\underline{\space}.split(",")).toArray\\
val dataHP1 = data.filter(\underline{\space}(2) == "1")\\
dataHP1.length\\
val dataRoad1 = data.filter(\underline{\space}(2) == "2")\\
dataRoad1.length\\
val dataRoad2 = data.filter(\underline{\space}(2) == "3")\\
dataRoad2.length\\
val dataRoad3 = data.filter(\underline{\space}(2) == "4")\\
dataRoad3.length\\
val dataHP2 = data.filter(\underline{\space}(2) == "5")\\
dataHP2.length\\
val dataGPSTrack = data.filter(\underline{\space}(2) == "6")\\
dataGPSTrack.length\\
val dataHP3 = data.filter(\underline{\space}(2) == "7")\\
dataHP3.length\\
val dataStArea =  data.filter(\underline{\space}(2) == "8")\\
dataStArea.length\\
val pointsHP1 = dataHP1.map(i => (i(0).toDouble, i(1).toDouble))\\
pointsHP1.length\\
val pointsRoad1 = dataRoad1.map(i => (i(0).toDouble, i(1).toDouble))\\
val pointsRoad2 = dataRoad2.map(i => (i(0).toDouble, i(1).toDouble))\\
val pointsRoad3 = dataRoad3.map(i => (i(0).toDouble, i(1).toDouble))\\
val pointsHP2 = dataHP2.map(i => (i(0).toDouble, i(1).toDouble))\\
val pointsHP3 = dataHP3.mao(i => (i(0).toDouble, i(1).toDouble)) \\
val pointsGPSTrack = dataGPSTrack.map(i => (i(0).toDouble, i(1).toDouble))\\
val pointsStArea = dataStArea.map(i => (i(0).toDouble, i(1).toDouble))\\
\\
\\
\paragraph{ Code snippet 3: explanation}
We read files in Scala with scala.io.Source. Because of that we import scala.io.\underline{\space} at the beginning of the parsing code. We then creat a value called source to store the data source into. Then, we create a value called data in which we access the lines of the .csv file. Each row of the .csv is a line. Because the .csv file is comma delimited, we split each line at "," and then we transform each line to an Array of strings. 
For each group of points we create a value in which we store them (i.e. dataHP1, dataRoad1). This is done by means of applying a filter on the whole data, to get only the points with the ID number we want. 
We then check the lenght of each group of data calling length on it (which shows how many Arrays (i.e. point coordinates) it contains.       
Because the data is provided as Array[String] we must convert the groups of data to Array[Double], which is done using the map function.
 If you encounter big problems in following this code snippet you can grasp to the book of Jason Swartz "Learning Scala" \cite{swartz_learning_2015} and then build up your skills with the book of Marc Lewis "Introduction into Programming and Problem Solving Using Scala" \cite{lewis_introduction_2017} which is also accompanied by videos on youtube (\href{https://www.youtube.com/playlist?list=PLLMXbkbDbVt9MIJ9DV4ps-_trOzWtphYO}{https://www.youtube.com/playlist?list=PLLMXbkbDbVt9MIJ9DV4ps-\underline{\space}trOz\\WtphYO}.   
\\
\\


\subsubsection {Reprojecting OGR geometries and vector layers} 

\subsection {Overlay analyses}

\subsection {Proximity analyses}

\subsection {Writing vector data}

\subsection {Reading raster data}

\subsection {Pixels resizing}

\subsection {Moving window analyses}

\subsection {Map algebra}



\section {Geostatistics using Geotrellis}

\section* {Note}
This document is "under construction". The current version is available on my GitHub profile under the multivariate\underline{\space}analyses project repository: \href{https://github.com/RoxanaTesileanu/multivariate_analyses/blob/master/literature_analysis/geospatial_scala/geospatial_scala.pdf}{https://githu\\b.com/RoxanaTesileanu/multivariate\underline{\space}analyses/blob/master/literature\underline{\space}analysis/\\geospatial\underline{\space}scala/geospatial\underline{\space}scala.pdf}.
%\section* {References}
\bibliography {MyLibrary}
\bibliographystyle {IEEEtran}


\end {document}

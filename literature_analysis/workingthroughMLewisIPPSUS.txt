Working through "Introduction to Programming and Problem Solving Using Scala" of Mark Lewis
https://www.youtube.com/playlist?list=PLLMXbkbDbVt9MIJ9DV4ps-_trOzWtphYO


scala> val age = 34
age: Int = 34

scala> val response = if (age >=18) "Come in" else "Get lost"
response: String = Come in

scala> //an expression returns a value

scala> var response2 = " "
response2: String = " "

scala> if (age >= 18) {
     | response2 = "come in"
     | } else {
     | response2 = "get lost"
     | }

scala> response2
res1: String = come in

scala> // a statement returns a reassigned var or the return of a println call

scala> // a statement makes something happen (like a side effect), whereas an expression returns a value which we can use later.

scala> if (age >= 18) {
     | println ("come in")
     | } else {
     | println ("get lost")
     | }
come in

scala> // Code blocks

scala> // code blocks are expressions and they have the value of the last thing that is in them

scala> {
     | println ("Giving back the 6")
     | 6
     | }
Giving back the 6
res3: Int = 6

scala> import scala.io.StdIn._
import scala.io.StdIn._

scala> println("How old are you?")
How old are you?

scala> val age = readInt
age: Int = 34

scala> val response = if (age >= 18) {
     | "old enough"
     | } else {
     | println ("too young")
     | "for too much coffee"
     | }
response: String = old enough

scala> // if and code blocks are used together if you want an output and a value 

scala> // this is because you can have only one expression inside the true or false parts.

scala> 

scala> //Comparison operators

scala> // ==     != (bang equal)   CHECK FOR EQUALITY

scala> // CHECK FOR IDENTITY: are the two objects the same object?

scala> // you use: s1 eq s2 instead of ==

scala> 

scala> 

scala> //Boolean logic

scala> // && AND     || INCLUSIVE OR     ^ EXCLUSIVE OR

scala> // ! NOT

scala> val age = readInt
age: Int = 19

scala> // val cost = 8 OR 12 based upon age

scala> val cost = if (age < 13 || age >=55) 8 else 12
cost: Int = 12

scala> val cost2 = if (age >= 13 && age < 55) 12 else 8
cost2: Int = 12

scala> // && and || are short-circuit operations

scala> // for && is the first is true it continues evaluating and if it's false it stops evaluating

scala> // for || if the first is false it continues evaluating

scala> // SHORT-CIRCUIT MEANS THAT IF THE VALUE CAN BE DETERMINED FROM THE FIRST PART WE WON'T EVALUATE THE SECOND ONE.

scala> val n = 2
n: Int = 2

scala> val d = 0
d: Int = 0

scala> val frac = n/d > 10
java.lang.ArithmeticException: / by zero
  ... 33 elided

scala> val frac = d>0 && n/d>10
frac: Boolean = false

scala> // we don't get the exception anymore

scala> // because if the first part is false, the second part never gets evaluated 

scala> 

scala> 

scala> // Operator precedence

scala> // * / %, + -, :, = !, < >, &, ^, |

scala> // other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment

scala> val operatorPrecendece = "// other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment"
operatorPrecendece: String = // other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment

scala> 

scala> 

scala> // Nesting ifs

scala> val order = readline
<console>:10: error: not found: value readline
       val order = readline
                   ^

scala> val order = readLine
order: String = drink

scala> val size = readLine
size: String = s

scala> val price = if (order == "food") {
     | if (size.toLowerCase.startsWith("s")) {
     | 1.0
     | } else if (size.toLowerCase.startsWith("m")) {
     | 1.5
     | } else if (size.toLowerCase.startsWith("l")) {
     | 2.0
     | }
     | } else if (order == "drink") { 
     | if (size.toLowerCase.startsWith("s")) {
     | 0.5
     | } else if (size.toLowerCase.startsWith("m")) {
     | 0.7
     | } else if (size.toLowerCase.startsWith("l")) {
     | 0.9
     | }
     | } else if (order == "combo") {
     | if (size.toLowerCase.startsWith("s")) {
     | 1.5
     | } else if (size.toLowerCase.startsWith("m")) {
     | 2.5
     | } else if (size.toLowerCase.startsWith("l")) {
     | 3.0
     | }
     | }
price: AnyVal = 0.5

scala> \\ great comments on Unit and AnyVal types! 
     | 
     | 
You typed two blank lines.  Starting a new command.

scala> // read "=>" as "rocket"

scala> // Higher Order Functions

scala> //functions that you pass functions into

scala> // they can return functions

scala> // THE KEY IS TO PASS THE FUNCTION YOU WANT TO USE IN THE PARAMETER LIST OF THE HOF. 

scala> // YOU PASS IN THE FUNCTION AS LAMBDA EXPRESSION.

scala> // YOU CAN ALSO USE UNDERSCORES

scala> 

scala> 

scala> // Recursion

scala> // the function is written in such a way that it depends upon itself.

scala> // you keep moving towards the base case.

scala> // in such a way that you change the current return value. 

scala> // Note: in a recursive function you have to specify the return type!

scala> def factorial (n: Int) : Int = if (n<2) 1 else n*factorial(n-1)
factorial: (n: Int)Int

scala> // we have an if-expression that produces the different cases!

scala> factorial(5)
res5: Int = 120

scala> factorial(10)
res6: Int = 3628800

scala> factorial(16)
res7: Int = 2004189184

scala> factorial(17)
res8: Int = -288522240

scala> // this is where Ints are at their limit. 

scala> def factorial (n: Long) : Long = if (n< 2) 1 else n*factorial(n-1)
factorial: (n: Long)Long

scala> factorial(17)
res9: Long = 355687428096000

scala> // for very large numbers: use Long!!!!

scala> factorial(20)
res10: Long = 2432902008176640000

scala> factorial(30)
res11: Long = -8764578968847253504

scala> // now we should use BigInt:

scala> def factorial (n: BigInt) : BigInt = if (n<2) 1 else n*(n-1)
factorial: (n: BigInt)BigInt

scala> // the BigInt type can store any-size number!

scala> factorial(30)
res12: BigInt = 870

scala> factorial(30)
res13: BigInt = 870

scala> //oops! some external effect.... 

scala> def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSume(n-1)
<console>:11: error: not found: value squareSume
       def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSume(n-1)
                                                          ^
scala> def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSum(n-1)
squareSum: (n: Int)Int

scala> squareSum(2)
res14: Int = 5

scala> squareSum(3)
res15: Int = 14

scala> squareSum(4)
res16: Int = 30

scala> squareSum(14)
res17: Int = 1015

scala> squareSum(140)
res18: Int = 924490

scala> def countDown (n:Int) : Unit = {
     | if (n>0) {
     | println(n)
     | countdown(n-1)
     | }
     | }
<console>:14: error: not found: value countdown
       countdown(n-1)
       ^

scala> def countDown (n:Int) : Unit = {
     | if (n>0) {
     | println(n)
     | countDown(n-1)
     | }
     | }
countDown: (n: Int)Unit

scala> countDown(10)
10
9
8
7
6
5
4
3
2
1

scala> def countFromTo (from: Int, to: Int) : Unit = {
     | if (from <= to) {
     | println(from)
     | countFromTo(from+1, to)
     | }
     | }
countFromTo: (from: Int, to: Int)Unit

scala> countFromTo(1,12_
<console>:1: error: Invalid literal number
       countFromTo(1,12_
                     ^

scala> countFromTo(1,12)
1
2
3
4
5
6
7
8
9
10
11
12



scala> 

_______________________ new REPL session _______________________________

scala> // Going through a program line by line in order to figure out what it is doing is called tracing

scala> // in case of sequential execution is easy.

scala> // tracing recursive functions is a little bit harder

scala> def fact (n:Int) :Int = if (n<2) 1 else n*fact(n-1)
fact: (n: Int)Int

scala> fact(5)
res3: Int = 120

scala> // a call on 5 takes us to 4 (there still is a "5*" waiting there to be executed. The callstack remembers where you are when you call functions, so when the function is done it returns to that point and does whatever is waiting there.   

scala> // the fact(4) is going to give a value to be multiplied with 5.

scala> // and so on. 

scala> // until we hit out base case.

scala> // so, the recursions are calling themselves going down the callstack, waiting and remembering values and the operations what need to be done, and the values are returned back-up to give us the end result. 

_______________________ new REPL session _______________________________

Tracing by Substitution: for pure functions (no prints, no reads, no assignments to vars) 

Example: 
def fact (n:Int) : Int = if (n<2) 1 else n*fact(n-1)

fact(5)
if (5<2) 1 else 5*fact(5-1)
5*fact(5-1)
5*fact(4)
5*(if(4<2) 1 else 4*fact(4-1))
5*(4*fact(4-1))
5*4*fact(3)
5*4*(if (3<2) 1 else 3*fact(3-1))
5*4*3*fact(2)
5*4*3* (if (2<2) 1 else 2*fact(1))
5*4*3*2*fact(1)
5*4*3*2* (if (1<2) 1 else 1*fact(0))
5*4*3*2*1

____________________________________________________________________

Recursion and User Input

scala> import io.StdIn._
import io.StdIn._

scala> def sum (n:Int) : Int = { 
     | if (n<1) 0
     | else {
     | val input = readInt
     | input + sum(n-1)
     | }
     | }
sum: (n: Int)Int

scala> sum(3)
res0: Int = 18

scala> // 5,6,7

scala> sum(3)
res1: Int = 16

scala> //5, 10, 1

scala> //you add up readInts

scala> 

scala> def sumPositive() : Int = {
     | val input = readInt
     | if(input >=0) {
     | input  + sumPositive()
     | } else 0
     | }
sumPositive: ()Int

scala> // when we call the function we are not passing anything because we only use the user input!! 

scala> sumPositive()
res2: Int = 9

scala> //8, 1,-1

scala> 

scala> // we don't pass any arguments,thus, we don't have something to count down towards the base case; our base case comes from the user input.

scala> def sumUntilQuit () : Int = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") 0
     | else input.toInt + sumUntilQuit()
     | }
sumUntilQuit: ()Int

scala> sumUntilQuit()
res3: Int = 15

scala> // 5,5,5, quit

scala> def sumAndCount () : (Int, Int) = {
     | val imput = readLine.toLowerCase.trim
     | if (input == "quit") (0.0)
     | else sumAndCount(input.toInt + sum, count +0)
     | }
<console>:17: error: not found: value input
       if (input == "quit") (0.0)
           ^
<console>:17: error: type mismatch;
 found   : Double(0.0)
 required: (Int, Int)
       if (input == "quit") (0.0)
                             ^
<console>:18: error: too many arguments for method sumAndCount: ()(Int, Int)
       else sumAndCount(input.toInt + sum, count +0)
                       ^

scala> //ok, it can't take any arguments. it can only have return values.

scala> //this is the trick by recursion with  user input. 

scala> def sumAndCount () : (Int, Int) = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") (0,0)
     | else {
     | val (sum, count) = sumAndCount()
     | (input.toInt + sum, count +1)
     | }
     | }
sumAndCount: ()(Int, Int)

scala> //so you assign the return values of sumAndCount() to some vals and then you add up user input to the sum accumulator and 1 to the count accumulator.

scala> sumAndCount()
res4: (Int, Int) = (4,2)

scala> // 1,3,quit

scala> val (s,c) = sumAndCount()
s: Int = 25
c: Int = 4

scala> println(s/4.toDouble)
6.25

scala> 

scala> //Abstracting Recursion

scala> def multAndCount () : (Int, Int) = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") (1,0) 
     | else {
     | val (prod, count) = multAndCount()
     | (input.toInt*prod, count +1)
     | }
     | }
multAndCount: ()(Int, Int)

scala> val (s,c) = multAndCount()
s: Int = 60
c: Int = 3

scala> // 2,6,5, quit

scala> // now we're going to write the HOF which can be used for both operations! 

scala> // the key is to ABSTRACT THE THINGS THAT CHANGE. These are the base and the operations done. 

scala> def inputAndCount (base: Int, op: (Int, Int) => Int) : (Int, Int) = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") (base, 0)
     | else {
     | val (value, count) = inputAndCount(base, op)
     | ( op(input.toInt, value), count +1 )
     | }
     | }
inputAndCount: (base: Int, op: (Int, Int) => Int)(Int, Int)

scala> val (s,c) = inputAndCount(0, _ + _)
s: Int = 9
c: Int = 2

scala> val (s,c) = inputAndCount(1, _ * _)
s: Int = 30
c: Int = 2

scala> // for the minimum, the base value is some large value which cannot be the min.

scala> val (s,c) = inputAndCount( Int.MaxValue, _ min _)
s: Int = 3
c: Int = 7

scala> val (s,c) = inputAndCount( Int.MaxValue, _ min _)
s: Int = 2147483647
c: Int = 0

scala> // expr match { } inside we have cases of patterns.

scala> /* expr match {
     | case pattern1 => ...
     | case pattern2 => ...
     | ....
     | }
     | */
     | 
     | 
You typed two blank lines.  Starting a new command.

scala> 

scala> // expression -> returns a value; statement -> side effects

scala> // we can have as many cases we want. firstly, the expr is evaluated, then it compares the expr. to each of the patterns and the first pattern which matches is the one that will be used.

scala> // example: convert fact with match

scala> def fact2 (n:Int) : Int = n match {
     | case 0 => 1
     | case _ => n*fact2(n-1)
     | }
fact2: (n: Int)Int

scala> def countDown2 (n:Int) : Unit = n match {
     | case 0 =>    // we do nothing  
     | case _ => 
     | println(n)
     | countDown2(n-1)
     | }
countDown2: (n: Int)Unit

scala> countDown2(5)
5
4
3
2
1

scala> 
scala> (readInt, readInt) match {
     | case (0,0) => "zero, zero"
     | case (1,0) => "one, zero"
     | case (_, _) => "something, something"
     | case (1,1) => "one, one"
     | }
<console>:19: warning: unreachable code
       case (1,1) => "one, one"
                     ^
java.lang.NumberFormatException: For input string: ""
  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
  at java.lang.Integer.parseInt(Integer.java:592)
  at java.lang.Integer.parseInt(Integer.java:615)
  at scala.collection.immutable.StringLike$class.toInt(StringLike.scala:273)
  at scala.collection.immutable.StringOps.toInt(StringOps.scala:29)
  at scala.io.StdIn$class.readInt(StdIn.scala:110)
  at scala.io.StdIn$.readInt(StdIn.scala:229)
  ... 47 elided

scala> (readInt, readInt) match {
     | case (0,0) => "zero, zero"
     | case (1,0) => "one, zero"
     | case (1,1) => "one, one"
     | case (_, _) => "something, something"
     | }
res14: String = something, something

scala> def fizzBuzz (i: Int) : Unit = {
     | if ( i<=100) {
     | (i%3, i%5) match {
     | case (0,0) => "fizzbuzz"
     | case (0, _) => "fizz"
     | case (_, 0) => "buzz"
     | case _ => i
     | }
     | fizzBuzz(i+1)
     | }
     | }
fizzBuzz: (i: Int)Unit

scala> fizzBuzz(90)
fizzbuzz
91
92
fizz
94
buzz
fizz
97
98
fizz
buzz

scala> // The try/catch construct (used as expression or statement)

scala> val i = try {
     | readInt 
     | } catch {
     | case e: NumberFormatException => 0
     | }
i: Int = 8

scala> readInt
java.lang.NumberFormatException: For input string: "a"
  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
  at java.lang.Integer.parseInt(Integer.java:580)
  at java.lang.Integer.parseInt(Integer.java:615)
  at scala.collection.immutable.StringLike$class.toInt(StringLike.scala:273)
  at scala.collection.immutable.StringOps.toInt(StringOps.scala:29)
  at scala.io.StdIn$class.readInt(StdIn.scala:110)
  at scala.io.StdIn$.readInt(StdIn.scala:229)
  ... 42 elided

scala> 

scala> def safeReadInt :Int = {
     | try {
     | readInt
     | } catch {
     | case e: NumberFormatException => 
     | println ("This wasn's a valid input. Please try again.")
     | safeReadInt
     | }
     | }
safeReadInt: Int

scala> // this shows how you use recursion until you get an input which doesn't throws a NumberFormatException.

scala> safeReadInt
This wasn's a valid input. Please try again.
res21: Int = 8

scala> // this type of try/catch constructs catch possible exceptions which make a program crash. So, when you believe a possible exception might be caused by a wrong type you should use it. 


Arrays

scala> Array(3,4,4,6,7)
res22: Array[Int] = Array(3, 4, 4, 6, 7)

scala> Array[Double](3,4,4,6,7)
res23: Array[Double] = Array(3.0, 4.0, 4.0, 6.0, 7.0)

scala> val arr = re22
<console>:14: error: not found: value re22
       val arr = re22
                 ^

scala> val arr = res22
arr: Array[Int] = Array(3, 4, 4, 6, 7)

scala> arr.length
res24: Int = 5

scala> arr.size
res25: Int = 5

scala> // arrays are mutable!!!

scala> arr(2)
res26: Int = 4

scala> arr(2) = 99

scala> arr(2)
res28: Int = 99

scala> arr
res29: Array[Int] = Array(3, 4, 99, 6, 7)

scala> // the size cannot be modified, just its elements. If the size is modified, a new array is created.

scala> // In general we use arrays when we know upfront how many elements we will have in that array. 

scala> // Arrays Functions

scala> def setArray (arr: Array[Int], v:Int, i:Int) : Unit = {} // returns Unit because the only thing that it does is that it mutates the array.
setArray: (arr: Array[Int], v: Int, i: Int)Unit

scala> arr(100)
java.lang.ArrayIndexOutOfBoundsException: 100
  ... 42 elided

scala> def setArray (arr: Array[Int], v:Int, i:Int) : Unit = {
     | if (i < arr.length) {
     | arr(i) = v
     | setArray(arr, v, i+1)
     | }
     | }
setArray: (arr: Array[Int], v: Int, i: Int)Unit

scala> val arr2 = setArray(arr, 99, 0)
arr2: Unit = ()

scala> println (setArray(arr, 99, 0))
()

scala> setArray(arr, 99, 0)

scala> arr
res33: Array[Int] = Array(99, 99, 99, 99, 99)

_____________________ new REPL session _________________________________


Array functions 2
Combine the elements of an array (reduce)

scala> def operateOnArray( arr: Array[Int], i: Int, f: (Int, Int) => Int) : Int = {
     | if (i<arr.length -1) {
     | f( arr(i), operateOnArray(arr, i+1, f))
     | } else {
     | arr(i)
     | }
     | }
operateOnArray: (arr: Array[Int], i: Int, f: (Int, Int) => Int)Int

scala> val nums = Array(1,2,3,4,5,6)
nums: Array[Int] = Array(1, 2, 3, 4, 5, 6)

scala> operateOnArray(nums, 0, _+_)
res0: Int = 21

scala> // we used recursion and the index to move across the array. 

scala> operateOnArray(nums, 0, _*_)
res1: Int = 720

scala> 

scala> // Lists 

scala> //lists are immutable!!

scala> List(5,3,8,2)
res2: List[Int] = List(5, 3, 8, 2)

scala> //lists allow you to very efficiently add elements in front of them.

scala> val lst = List(6,8,3,5)
lst: List[Int] = List(6, 8, 3, 5)

scala> // cons operator prepends elements in front of the list:

scala> 1 :: lst
res3: List[Int] = List(1, 6, 8, 3, 5)

scala> // read as "one cons list"

scala> // our old list is still there, this created a new list

scala> // the list with no elements: Nil!

scala> Nil
res4: scala.collection.immutable.Nil.type = List()

scala> 1::2::3::4::Nil
res5: List[Int] = List(1, 2, 3, 4)

scala> // this is one way to create lists

scala> lst
res6: List[Int] = List(6, 8, 3, 5)

scala> lst(2)
res7: Int = 3

scala> // lists are immutable so we cannot update the values of elements

scala> lst(2) =99
<console>:13: error: value update is not a member of List[Int]
       lst(2) =99
       ^

scala> // exercise: function which builds up a list:

scala> import io.StdIn._
import io.StdIn._

scala> // lists work very well when you don't know how many elements the list will have:

scala> def inputList (n: Int) : List[Int] = {
     | if (n<1) Nil
     | else readInt :: inputList(n-1)
     | }
inputList: (n: Int)List[Int]

scala> val list2 = inputList(4)
list2: List[Int] = List(2, 4, 7, 6)

scala> // THE ARRAY IS BEST WHEN YOU DO KNOW HOW MANY THINGS YOU HAVE AND IT ALLOWS YOU TO MUTATE THEM.

scala> // LISTS WORK VERY WELL IF YOU DON'T KNOW HOW MANY INPUTS YOU HAVE (e.g. functions which work with quit).

scala> // Methods that we can call on Lists

scala> lst
res9: List[Int] = List(6, 8, 3, 5)

scala> lst.head
res10: Int = 6

scala> lst.tail
res11: List[Int] = List(8, 3, 5)

scala> def operateOnList (lst: List[Int], base: Int, f: (Int, Int) => Int) : Int = {
     | if (lst == Nil) base 
     | else f(lst.head, operateOnList(lst.tail, base, f))
     | }
operateOnList: (lst: List[Int], base: Int, f: (Int, Int) => Int)Int

scala> operateOnList(lst, 0, _ + _)
res12: Int = 22

scala> def operateOnList2 (lst : List[Int], base :Int, f: (Int, Int) => Int) : Int = lst match {
     | case Nil => base
     | case h :: t => f( h, operateOnList2(t, base, f))
     | }
operateOnList2: (lst: List[Int], base: Int, f: (Int, Int) => Int)Int

scala> operateOnList2(lst, 0, _ + _)
res13: Int = 22

scala> // if we need to express head and tail in the case pattern we use h::t (something cons something).

scala> // you can use head and tail to go through the recursion.

scala> // and pull a list apart.

scala> 

scala> Array.fill(10)(5)
res14: Array[Int] = Array(5, 5, 5, 5, 5, 5, 5, 5, 5, 5)

scala> val zeros = Array.fill(5)(0)
zeros: Array[Int] = Array(0, 0, 0, 0, 0)

scala> val ones = Array.fill(7)(1)
ones: Array[Int] = Array(1, 1, 1, 1, 1, 1, 1)


 
















 










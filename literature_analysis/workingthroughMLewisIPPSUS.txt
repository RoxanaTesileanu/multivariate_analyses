Working through "Introduction to Programming and Problem Solving Using Scala" of Mark Lewis
https://www.youtube.com/playlist?list=PLLMXbkbDbVt9MIJ9DV4ps-_trOzWtphYO


scala> val age = 34
age: Int = 34

scala> val response = if (age >=18) "Come in" else "Get lost"
response: String = Come in

scala> //an expression returns a value

scala> var response2 = " "
response2: String = " "

scala> if (age >= 18) {
     | response2 = "come in"
     | } else {
     | response2 = "get lost"
     | }

scala> response2
res1: String = come in

scala> // a statement returns a reassigned var or the return of a println call

scala> // a statement makes something happen (like a side effect), whereas an expression returns a value which we can use later.

scala> if (age >= 18) {
     | println ("come in")
     | } else {
     | println ("get lost")
     | }
come in

scala> // Code blocks

scala> // code blocks are expressions and they have the value of the last thing that is in them

scala> {
     | println ("Giving back the 6")
     | 6
     | }
Giving back the 6
res3: Int = 6

scala> import scala.io.StdIn._
import scala.io.StdIn._

scala> println("How old are you?")
How old are you?

scala> val age = readInt
age: Int = 34

scala> val response = if (age >= 18) {
     | "old enough"
     | } else {
     | println ("too young")
     | "for too much coffee"
     | }
response: String = old enough

scala> // if and code blocks are used together if you want an output and a value 

scala> // this is because you can have only one expression inside the true or false parts.

scala> 

scala> //Comparison operators

scala> // ==     != (bang equal)   CHECK FOR EQUALITY

scala> // CHECK FOR IDENTITY: are the two objects the same object?

scala> // you use: s1 eq s2 instead of ==

scala> 

scala> 

scala> //Boolean logic

scala> // && AND     || INCLUSIVE OR     ^ EXCLUSIVE OR

scala> // ! NOT

scala> val age = readInt
age: Int = 19

scala> // val cost = 8 OR 12 based upon age

scala> val cost = if (age < 13 || age >=55) 8 else 12
cost: Int = 12

scala> val cost2 = if (age >= 13 && age < 55) 12 else 8
cost2: Int = 12

scala> // && and || are short-circuit operations

scala> // for && is the first is true it continues evaluating and if it's false it stops evaluating

scala> // for || if the first is false it continues evaluating

scala> // SHORT-CIRCUIT MEANS THAT IF THE VALUE CAN BE DETERMINED FROM THE FIRST PART WE WON'T EVALUATE THE SECOND ONE.

scala> val n = 2
n: Int = 2

scala> val d = 0
d: Int = 0

scala> val frac = n/d > 10
java.lang.ArithmeticException: / by zero
  ... 33 elided

scala> val frac = d>0 && n/d>10
frac: Boolean = false

scala> // we don't get the exception anymore

scala> // because if the first part is false, the second part never gets evaluated 

scala> 

scala> 

scala> // Operator precedence

scala> // * / %, + -, :, = !, < >, &, ^, |

scala> // other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment

scala> val operatorPrecendece = "// other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment"
operatorPrecendece: String = // other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment

scala> 

scala> 

scala> // Nesting ifs

scala> val order = readline
<console>:10: error: not found: value readline
       val order = readline
                   ^

scala> val order = readLine
order: String = drink

scala> val size = readLine
size: String = s

scala> val price = if (order == "food") {
     | if (size.toLowerCase.startsWith("s")) {
     | 1.0
     | } else if (size.toLowerCase.startsWith("m")) {
     | 1.5
     | } else if (size.toLowerCase.startsWith("l")) {
     | 2.0
     | }
     | } else if (order == "drink") { 
     | if (size.toLowerCase.startsWith("s")) {
     | 0.5
     | } else if (size.toLowerCase.startsWith("m")) {
     | 0.7
     | } else if (size.toLowerCase.startsWith("l")) {
     | 0.9
     | }
     | } else if (order == "combo") {
     | if (size.toLowerCase.startsWith("s")) {
     | 1.5
     | } else if (size.toLowerCase.startsWith("m")) {
     | 2.5
     | } else if (size.toLowerCase.startsWith("l")) {
     | 3.0
     | }
     | }
price: AnyVal = 0.5

scala> \\ great comments on Unit and AnyVal types! 
     | 
     | 
You typed two blank lines.  Starting a new command.

scala> // read "=>" as "rocket"

scala> // Higher Order Functions

scala> //functions that you pass functions into

scala> // they can return functions

scala> // THE KEY IS TO PASS THE FUNCTION YOU WANT TO USE IN THE PARAMETER LIST OF THE HOF. 

scala> // YOU PASS IN THE FUNCTION AS LAMBDA EXPRESSION.

scala> // YOU CAN ALSO USE UNDERSCORES

scala> 

scala> 

scala> // Recursion

scala> // the function is written in such a way that it depends upon itself.

scala> // you keep moving towards the base case.

scala> // in such a way that you change the current return value. 

scala> // Note: in a recursive function you have to specify the return type!

scala> def factorial (n: Int) : Int = if (n<2) 1 else n*factorial(n-1)
factorial: (n: Int)Int

scala> // we have an if-expression that produces the different cases!

scala> factorial(5)
res5: Int = 120

scala> factorial(10)
res6: Int = 3628800

scala> factorial(16)
res7: Int = 2004189184

scala> factorial(17)
res8: Int = -288522240

scala> // this is where Ints are at their limit. 

scala> def factorial (n: Long) : Long = if (n< 2) 1 else n*factorial(n-1)
factorial: (n: Long)Long

scala> factorial(17)
res9: Long = 355687428096000

scala> // for very large numbers: use Long!!!!

scala> factorial(20)
res10: Long = 2432902008176640000

scala> factorial(30)
res11: Long = -8764578968847253504

scala> // now we should use BigInt:

scala> def factorial (n: BigInt) : BigInt = if (n<2) 1 else n*(n-1)
factorial: (n: BigInt)BigInt

scala> // the BigInt type can store any-size number!

scala> factorial(30)
res12: BigInt = 870

scala> factorial(30)
res13: BigInt = 870

scala> //oops! some external effect.... 

scala> def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSume(n-1)
<console>:11: error: not found: value squareSume
       def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSume(n-1)
                                                          ^
scala> def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSum(n-1)
squareSum: (n: Int)Int

scala> squareSum(2)
res14: Int = 5

scala> squareSum(3)
res15: Int = 14

scala> squareSum(4)
res16: Int = 30

scala> squareSum(14)
res17: Int = 1015

scala> squareSum(140)
res18: Int = 924490

scala> def countDown (n:Int) : Unit = {
     | if (n>0) {
     | println(n)
     | countdown(n-1)
     | }
     | }
<console>:14: error: not found: value countdown
       countdown(n-1)
       ^

scala> def countDown (n:Int) : Unit = {
     | if (n>0) {
     | println(n)
     | countDown(n-1)
     | }
     | }
countDown: (n: Int)Unit

scala> countDown(10)
10
9
8
7
6
5
4
3
2
1

scala> def countFromTo (from: Int, to: Int) : Unit = {
     | if (from <= to) {
     | println(from)
     | countFromTo(from+1, to)
     | }
     | }
countFromTo: (from: Int, to: Int)Unit

scala> countFromTo(1,12_
<console>:1: error: Invalid literal number
       countFromTo(1,12_
                     ^

scala> countFromTo(1,12)
1
2
3
4
5
6
7
8
9
10
11
12



scala> 

_______________________ new REPL session _______________________________

scala> // Going through a program line by line in order to figure out what it is doing is called tracing

scala> // in case of sequential execution is easy.

scala> // tracing recursive functions is a little bit harder

scala> def fact (n:Int) :Int = if (n<2) 1 else n*fact(n-1)
fact: (n: Int)Int

scala> fact(5)
res3: Int = 120

scala> // a call on 5 takes us to 4 (there still is a "5*" waiting there to be executed. The callstack remembers where you are when you call functions, so when the function is done it returns to that point and does whatever is waiting there.   

scala> // the fact(4) is going to give a value to be multiplied with 5.

scala> // and so on. 

scala> // until we hit out base case.

scala> // so, the recursions are calling themselves going down the callstack, waiting and remembering values and the operations what need to be done, and the values are returned back-up to give us the end result. 

_______________________ new REPL session _______________________________

Tracing by Substitution: for pure functions (no prints, no reads, no assignments to vars) 

Example: 
def fact (n:Int) : Int = if (n<2) 1 else n*fact(n-1)

fact(5)
if (5<2) 1 else 5*fact(5-1)
5*fact(5-1)
5*fact(4)
5*(if(4<2) 1 else 4*fact(4-1))
5*(4*fact(4-1))
5*4*fact(3)
5*4*(if (3<2) 1 else 3*fact(3-1))
5*4*3*fact(2)
5*4*3* (if (2<2) 1 else 2*fact(1))
5*4*3*2*fact(1)
5*4*3*2* (if (1<2) 1 else 1*fact(0))
5*4*3*2*1

____________________________________________________________________

Recursion and User Input

scala> import io.StdIn._
import io.StdIn._

scala> def sum (n:Int) : Int = { 
     | if (n<1) 0
     | else {
     | val input = readInt
     | input + sum(n-1)
     | }
     | }
sum: (n: Int)Int

scala> sum(3)
res0: Int = 18

scala> // 5,6,7

scala> sum(3)
res1: Int = 16

scala> //5, 10, 1

scala> //you add up readInts

scala> 

scala> def sumPositive() : Int = {
     | val input = readInt
     | if(input >=0) {
     | input  + sumPositive()
     | } else 0
     | }
sumPositive: ()Int

scala> // when we call the function we are not passing anything because we only use the user input!! 

scala> sumPositive()
res2: Int = 9

scala> //8, 1,-1

scala> 

scala> // we don't pass any arguments,thus, we don't have something to count down towards the base case; our base case comes from the user input.

scala> def sumUntilQuit () : Int = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") 0
     | else input.toInt + sumUntilQuit()
     | }
sumUntilQuit: ()Int

scala> sumUntilQuit()
res3: Int = 15

scala> // 5,5,5, quit

scala> def sumAndCount () : (Int, Int) = {
     | val imput = readLine.toLowerCase.trim
     | if (input == "quit") (0.0)
     | else sumAndCount(input.toInt + sum, count +0)
     | }
<console>:17: error: not found: value input
       if (input == "quit") (0.0)
           ^
<console>:17: error: type mismatch;
 found   : Double(0.0)
 required: (Int, Int)
       if (input == "quit") (0.0)
                             ^
<console>:18: error: too many arguments for method sumAndCount: ()(Int, Int)
       else sumAndCount(input.toInt + sum, count +0)
                       ^

scala> //ok, it can't take any arguments. it can only have return values.

scala> //this is the trick by recursion with  user input. 

scala> def sumAndCount () : (Int, Int) = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") (0,0)
     | else {
     | val (sum, count) = sumAndCount()
     | (input.toInt + sum, count +1)
     | }
     | }
sumAndCount: ()(Int, Int)

scala> //so you assign the return values of sumAndCount() to some vals and then you add up user input to the sum accumulator and 1 to the count accumulator.

scala> sumAndCount()
res4: (Int, Int) = (4,2)

scala> // 1,3,quit

scala> val (s,c) = sumAndCount()
s: Int = 25
c: Int = 4

scala> println(s/4.toDouble)
6.25

scala> 

scala> //Abstracting Recursion

scala> def multAndCount () : (Int, Int) = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") (1,0) 
     | else {
     | val (prod, count) = multAndCount()
     | (input.toInt*prod, count +1)
     | }
     | }
multAndCount: ()(Int, Int)

scala> val (s,c) = multAndCount()
s: Int = 60
c: Int = 3

scala> // 2,6,5, quit

scala> // now we're going to write the HOF which can be used for both operations! 

scala> // the key is to ABSTRACT THE THINGS THAT CHANGE. These are the base and the operations done. 

scala> def inputAndCount (base: Int, op: (Int, Int) => Int) : (Int, Int) = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") (base, 0)
     | else {
     | val (value, count) = inputAndCount(base, op)
     | ( op(input.toInt, value), count +1 )
     | }
     | }
inputAndCount: (base: Int, op: (Int, Int) => Int)(Int, Int)

scala> val (s,c) = inputAndCount(0, _ + _)
s: Int = 9
c: Int = 2

scala> val (s,c) = inputAndCount(1, _ * _)
s: Int = 30
c: Int = 2

scala> // for the minimum, the base value is some large value which cannot be the min.

scala> val (s,c) = inputAndCount( Int.MaxValue, _ min _)
s: Int = 3
c: Int = 7

scala> val (s,c) = inputAndCount( Int.MaxValue, _ min _)
s: Int = 2147483647
c: Int = 0

scala> // expr match { } inside we have cases of patterns.

scala> /* expr match {
     | case pattern1 => ...
     | case pattern2 => ...
     | ....
     | }
     | */
     | 
     | 
You typed two blank lines.  Starting a new command.

scala> 

scala> // expression -> returns a value; statement -> side effects

scala> // we can have as many cases we want. firstly, the expr is evaluated, then it compares the expr. to each of the patterns and the first pattern which matches is the one that will be used.

scala> // example: convert fact with match

scala> def fact2 (n:Int) : Int = n match {
     | case 0 => 1
     | case _ => n*fact2(n-1)
     | }
fact2: (n: Int)Int

scala> def countDown2 (n:Int) : Unit = n match {
     | case 0 =>    // we do nothing  
     | case _ => 
     | println(n)
     | countDown2(n-1)
     | }
countDown2: (n: Int)Unit

scala> countDown2(5)
5
4
3
2
1

scala> 
scala> (readInt, readInt) match {
     | case (0,0) => "zero, zero"
     | case (1,0) => "one, zero"
     | case (_, _) => "something, something"
     | case (1,1) => "one, one"
     | }
<console>:19: warning: unreachable code
       case (1,1) => "one, one"
                     ^
java.lang.NumberFormatException: For input string: ""
  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
  at java.lang.Integer.parseInt(Integer.java:592)
  at java.lang.Integer.parseInt(Integer.java:615)
  at scala.collection.immutable.StringLike$class.toInt(StringLike.scala:273)
  at scala.collection.immutable.StringOps.toInt(StringOps.scala:29)
  at scala.io.StdIn$class.readInt(StdIn.scala:110)
  at scala.io.StdIn$.readInt(StdIn.scala:229)
  ... 47 elided

scala> (readInt, readInt) match {
     | case (0,0) => "zero, zero"
     | case (1,0) => "one, zero"
     | case (1,1) => "one, one"
     | case (_, _) => "something, something"
     | }
res14: String = something, something





 










scala> val age = 34
age: Int = 34

scala> val response = if (age >=18) "Come in" else "Get lost"
response: String = Come in

scala> //an expression returns a value

scala> var response2 = " "
response2: String = " "

scala> if (age >= 18) {
     | response2 = "come in"
     | } else {
     | response2 = "get lost"
     | }

scala> response2
res1: String = come in

scala> // a statement returns a reassigned var or the return of a println call

scala> // a statement makes something happen (like a side effect), whereas an expression returns a value which we can use later.

scala> if (age >= 18) {
     | println ("come in")
     | } else {
     | println ("get lost")
     | }
come in

scala> // Code blocks

scala> // code blocks are expressions and they have the value of the last thing that is in them

scala> {
     | println ("Giving back the 6")
     | 6
     | }
Giving back the 6
res3: Int = 6

scala> import scala.io.StdIn._
import scala.io.StdIn._

scala> println("How old are you?")
How old are you?

scala> val age = readInt
age: Int = 34

scala> val response = if (age >= 18) {
     | "old enough"
     | } else {
     | println ("too young")
     | "for too much coffee"
     | }
response: String = old enough

scala> // if and code blocks are used together if you want an output and a value 

scala> // this is because you can have only one expression inside the true or false parts.

scala> 

scala> //Comparison operators

scala> // ==     != (bang equal)   CHECK FOR EQUALITY

scala> // CHECK FOR IDENTITY: are the two objects the same object?

scala> // you use: s1 eq s2 instead of ==

scala> 

scala> 

scala> //Boolean logic

scala> // && AND     || INCLUSIVE OR     ^ EXCLUSIVE OR

scala> // ! NOT

scala> val age = readInt
age: Int = 19

scala> // val cost = 8 OR 12 based upon age

scala> val cost = if (age < 13 || age >=55) 8 else 12
cost: Int = 12

scala> val cost2 = if (age >= 13 && age < 55) 12 else 8
cost2: Int = 12

scala> // && and || are short-circuit operations

scala> // for && is the first is true it continues evaluating and if it's false it stops evaluating

scala> // for || if the first is false it continues evaluating

scala> // SHORT-CIRCUIT MEANS THAT IF THE VALUE CAN BE DETERMINED FROM THE FIRST PART WE WON'T EVALUATE THE SECOND ONE.

scala> val n = 2
n: Int = 2

scala> val d = 0
d: Int = 0

scala> val frac = n/d > 10
java.lang.ArithmeticException: / by zero
  ... 33 elided

scala> val frac = d>0 && n/d>10
frac: Boolean = false

scala> // we don't get the exception anymore

scala> // because if the first part is false, the second part never gets evaluated 

scala> 

scala> 

scala> // Operator precedence

scala> // * / %, + -, :, = !, < >, &, ^, |

scala> // other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment

scala> val operatorPrecendece = "// other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment"
operatorPrecendece: String = // other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment

scala> 

scala> 

scala> // Nesting ifs

scala> val order = readline
<console>:10: error: not found: value readline
       val order = readline
                   ^

scala> val order = readLine
order: String = drink

scala> val size = readLine
size: String = s

scala> val price = if (order == "food") {
     | if (size.toLowerCase.startsWith("s")) {
     | 1.0
     | } else if (size.toLowerCase.startsWith("m")) {
     | 1.5
     | } else if (size.toLowerCase.startsWith("l")) {
     | 2.0
     | }
     | } else if (order == "drink") { 
     | if (size.toLowerCase.startsWith("s")) {
     | 0.5
     | } else if (size.toLowerCase.startsWith("m")) {
     | 0.7
     | } else if (size.toLowerCase.startsWith("l")) {
     | 0.9
     | }
     | } else if (order == "combo") {
     | if (size.toLowerCase.startsWith("s")) {
     | 1.5
     | } else if (size.toLowerCase.startsWith("m")) {
     | 2.5
     | } else if (size.toLowerCase.startsWith("l")) {
     | 3.0
     | }
     | }
price: AnyVal = 0.5

scala> \\ great comments on Unit and AnyVal types! 
     | 
     | 
You typed two blank lines.  Starting a new command.

scala> // read "=>" as "rocket"

scala> // Higher Order Functions

scala> //functions that you pass functions into

scala> // they can return functions

scala> // THE KEY IS TO PASS THE FUNCTION YOU WANT TO USE IN THE PARAMETER LIST OF THE HOF. 

scala> // YOU PASS IN THE FUNCTION AS LAMBDA EXPRESSION.

scala> // YOU CAN ALSO USE UNDERSCORES

scala> 

scala> 

scala> // Recursion

scala> // the function is written in such a way that it depends upon itself.

scala> // you keep moving towards the base case.

scala> // in such a way that you change the current return value. 

scala> // Note: in a recursive function you have to specify the return type!

scala> def factorial (n: Int) : Int = if (n<2) 1 else n*factorial(n-1)
factorial: (n: Int)Int

scala> // we have an if-expression that produces the different cases!

scala> factorial(5)
res5: Int = 120

scala> factorial(10)
res6: Int = 3628800

scala> factorial(16)
res7: Int = 2004189184

scala> factorial(17)
res8: Int = -288522240

scala> // this is where Ints are at their limit. 

scala> def factorial (n: Long) : Long = if (n< 2) 1 else n*factorial(n-1)
factorial: (n: Long)Long

scala> factorial(17)
res9: Long = 355687428096000

scala> // for very large numbers: use Long!!!!

scala> factorial(20)
res10: Long = 2432902008176640000

scala> factorial(30)
res11: Long = -8764578968847253504

scala> // now we should use BigInt:

scala> def factorial (n: BigInt) : BigInt = if (n<2) 1 else n*(n-1)
factorial: (n: BigInt)BigInt

scala> // the BigInt type can store any-size number!

scala> factorial(30)
res12: BigInt = 870

scala> factorial(30)
res13: BigInt = 870

scala> //oops! some external effect.... 

scala> def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSume(n-1)
<console>:11: error: not found: value squareSume
       def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSume(n-1)
                                                          ^
scala> def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSum(n-1)
squareSum: (n: Int)Int

scala> squareSum(2)
res14: Int = 5

scala> squareSum(3)
res15: Int = 14

scala> squareSum(4)
res16: Int = 30

scala> squareSum(14)
res17: Int = 1015

scala> squareSum(140)
res18: Int = 924490

scala> def countDown (n:Int) : Unit = {
     | if (n>0) {
     | println(n)
     | countdown(n-1)
     | }
     | }
<console>:14: error: not found: value countdown
       countdown(n-1)
       ^

scala> def countDown (n:Int) : Unit = {
     | if (n>0) {
     | println(n)
     | countDown(n-1)
     | }
     | }
countDown: (n: Int)Unit

scala> countDown(10)
10
9
8
7
6
5
4
3
2
1

scala> def countFromTo (from: Int, to: Int) : Unit = {
     | if (from <= to) {
     | println(from)
     | countFromTo(from+1, to)
     | }
     | }
countFromTo: (from: Int, to: Int)Unit

scala> countFromTo(1,12_
<console>:1: error: Invalid literal number
       countFromTo(1,12_
                     ^

scala> countFromTo(1,12)
1
2
3
4
5
6
7
8
9
10
11
12



scala> 




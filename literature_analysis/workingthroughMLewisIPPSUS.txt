Working through "Introduction to Programming and Problem Solving Using Scala" of Mark Lewis
https://www.youtube.com/playlist?list=PLLMXbkbDbVt9MIJ9DV4ps-_trOzWtphYO


scala> val age = 34
age: Int = 34

scala> val response = if (age >=18) "Come in" else "Get lost"
response: String = Come in

scala> //an expression returns a value

scala> var response2 = " "
response2: String = " "

scala> if (age >= 18) {
     | response2 = "come in"
     | } else {
     | response2 = "get lost"
     | }

scala> response2
res1: String = come in

scala> // a statement returns a reassigned var or the return of a println call

scala> // a statement makes something happen (like a side effect), whereas an expression returns a value which we can use later.

scala> if (age >= 18) {
     | println ("come in")
     | } else {
     | println ("get lost")
     | }
come in

scala> // Code blocks

scala> // code blocks are expressions and they have the value of the last thing that is in them

scala> {
     | println ("Giving back the 6")
     | 6
     | }
Giving back the 6
res3: Int = 6

scala> import scala.io.StdIn._
import scala.io.StdIn._

scala> println("How old are you?")
How old are you?

scala> val age = readInt
age: Int = 34

scala> val response = if (age >= 18) {
     | "old enough"
     | } else {
     | println ("too young")
     | "for too much coffee"
     | }
response: String = old enough

scala> // if and code blocks are used together if you want an output and a value 

scala> // this is because you can have only one expression inside the true or false parts.

scala> 

scala> //Comparison operators

scala> // ==     != (bang equal)   CHECK FOR EQUALITY

scala> // CHECK FOR IDENTITY: are the two objects the same object?

scala> // you use: s1 eq s2 instead of ==

scala> 

scala> 

scala> //Boolean logic

scala> // && AND     || INCLUSIVE OR     ^ EXCLUSIVE OR

scala> // ! NOT

scala> val age = readInt
age: Int = 19

scala> // val cost = 8 OR 12 based upon age

scala> val cost = if (age < 13 || age >=55) 8 else 12
cost: Int = 12

scala> val cost2 = if (age >= 13 && age < 55) 12 else 8
cost2: Int = 12

scala> // && and || are short-circuit operations

scala> // for && is the first is true it continues evaluating and if it's false it stops evaluating

scala> // for || if the first is false it continues evaluating

scala> // SHORT-CIRCUIT MEANS THAT IF THE VALUE CAN BE DETERMINED FROM THE FIRST PART WE WON'T EVALUATE THE SECOND ONE.

scala> val n = 2
n: Int = 2

scala> val d = 0
d: Int = 0

scala> val frac = n/d > 10
java.lang.ArithmeticException: / by zero
  ... 33 elided

scala> val frac = d>0 && n/d>10
frac: Boolean = false

scala> // we don't get the exception anymore

scala> // because if the first part is false, the second part never gets evaluated 

scala> 

scala> 

scala> // Operator precedence

scala> // * / %, + -, :, = !, < >, &, ^, |

scala> // other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment

scala> val operatorPrecendece = "// other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment"
operatorPrecendece: String = // other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment

scala> 

scala> 

scala> // Nesting ifs

scala> val order = readline
<console>:10: error: not found: value readline
       val order = readline
                   ^

scala> val order = readLine
order: String = drink

scala> val size = readLine
size: String = s

scala> val price = if (order == "food") {
     | if (size.toLowerCase.startsWith("s")) {
     | 1.0
     | } else if (size.toLowerCase.startsWith("m")) {
     | 1.5
     | } else if (size.toLowerCase.startsWith("l")) {
     | 2.0
     | }
     | } else if (order == "drink") { 
     | if (size.toLowerCase.startsWith("s")) {
     | 0.5
     | } else if (size.toLowerCase.startsWith("m")) {
     | 0.7
     | } else if (size.toLowerCase.startsWith("l")) {
     | 0.9
     | }
     | } else if (order == "combo") {
     | if (size.toLowerCase.startsWith("s")) {
     | 1.5
     | } else if (size.toLowerCase.startsWith("m")) {
     | 2.5
     | } else if (size.toLowerCase.startsWith("l")) {
     | 3.0
     | }
     | }
price: AnyVal = 0.5

scala> \\ great comments on Unit and AnyVal types! 
     | 
     | 
You typed two blank lines.  Starting a new command.

scala> // read "=>" as "rocket"

scala> // Higher Order Functions

scala> //functions that you pass functions into

scala> // they can return functions

scala> // THE KEY IS TO PASS THE FUNCTION YOU WANT TO USE IN THE PARAMETER LIST OF THE HOF. 

scala> // YOU PASS IN THE FUNCTION AS LAMBDA EXPRESSION.

scala> // YOU CAN ALSO USE UNDERSCORES

scala> 

scala> 

scala> // Recursion

scala> // the function is written in such a way that it depends upon itself.

scala> // you keep moving towards the base case.

scala> // in such a way that you change the current return value. 

scala> // Note: in a recursive function you have to specify the return type!

scala> def factorial (n: Int) : Int = if (n<2) 1 else n*factorial(n-1)
factorial: (n: Int)Int

scala> // we have an if-expression that produces the different cases!

scala> factorial(5)
res5: Int = 120

scala> factorial(10)
res6: Int = 3628800

scala> factorial(16)
res7: Int = 2004189184

scala> factorial(17)
res8: Int = -288522240

scala> // this is where Ints are at their limit. 

scala> def factorial (n: Long) : Long = if (n< 2) 1 else n*factorial(n-1)
factorial: (n: Long)Long

scala> factorial(17)
res9: Long = 355687428096000

scala> // for very large numbers: use Long!!!!

scala> factorial(20)
res10: Long = 2432902008176640000

scala> factorial(30)
res11: Long = -8764578968847253504

scala> // now we should use BigInt:

scala> def factorial (n: BigInt) : BigInt = if (n<2) 1 else n*(n-1)
factorial: (n: BigInt)BigInt

scala> // the BigInt type can store any-size number!

scala> factorial(30)
res12: BigInt = 870

scala> factorial(30)
res13: BigInt = 870

scala> //oops! some external effect.... 

scala> def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSume(n-1)
<console>:11: error: not found: value squareSume
       def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSume(n-1)
                                                          ^
scala> def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSum(n-1)
squareSum: (n: Int)Int

scala> squareSum(2)
res14: Int = 5

scala> squareSum(3)
res15: Int = 14

scala> squareSum(4)
res16: Int = 30

scala> squareSum(14)
res17: Int = 1015

scala> squareSum(140)
res18: Int = 924490

scala> def countDown (n:Int) : Unit = {
     | if (n>0) {
     | println(n)
     | countdown(n-1)
     | }
     | }
<console>:14: error: not found: value countdown
       countdown(n-1)
       ^

scala> def countDown (n:Int) : Unit = {
     | if (n>0) {
     | println(n)
     | countDown(n-1)
     | }
     | }
countDown: (n: Int)Unit

scala> countDown(10)
10
9
8
7
6
5
4
3
2
1

scala> def countFromTo (from: Int, to: Int) : Unit = {
     | if (from <= to) {
     | println(from)
     | countFromTo(from+1, to)
     | }
     | }
countFromTo: (from: Int, to: Int)Unit

scala> countFromTo(1,12_
<console>:1: error: Invalid literal number
       countFromTo(1,12_
                     ^

scala> countFromTo(1,12)
1
2
3
4
5
6
7
8
9
10
11
12



scala> 

_______________________ new REPL session _______________________________

scala> // Going through a program line by line in order to figure out what it is doing is called tracing

scala> // in case of sequential execution is easy.

scala> // tracing recursive functions is a little bit harder

scala> def fact (n:Int) :Int = if (n<2) 1 else n*fact(n-1)
fact: (n: Int)Int

scala> fact(5)
res3: Int = 120

scala> // a call on 5 takes us to 4 (there still is a "5*" waiting there to be executed. The callstack remembers where you are when you call functions, so when the function is done it returns to that point and does whatever is waiting there.   

scala> // the fact(4) is going to give a value to be multiplied with 5.

scala> // and so on. 

scala> // until we hit out base case.

scala> // so, the recursions are calling themselves going down the callstack, waiting and remembering values and the operations what need to be done, and the values are returned back-up to give us the end result. 

_______________________ new REPL session _______________________________

Tracing by Substitution: for pure functions (no prints, no reads, no assignments to vars) 

Example: 
def fact (n:Int) : Int = if (n<2) 1 else n*fact(n-1)

fact(5)
if (5<2) 1 else 5*fact(5-1)
5*fact(5-1)
5*fact(4)
5*(if(4<2) 1 else 4*fact(4-1))
5*(4*fact(4-1))
5*4*fact(3)
5*4*(if (3<2) 1 else 3*fact(3-1))
5*4*3*fact(2)
5*4*3* (if (2<2) 1 else 2*fact(1))
5*4*3*2*fact(1)
5*4*3*2* (if (1<2) 1 else 1*fact(0))
5*4*3*2*1

____________________________________________________________________

Recursion and User Input

scala> import io.StdIn._
import io.StdIn._

scala> def sum (n:Int) : Int = { 
     | if (n<1) 0
     | else {
     | val input = readInt
     | input + sum(n-1)
     | }
     | }
sum: (n: Int)Int

scala> sum(3)
res0: Int = 18

scala> // 5,6,7

scala> sum(3)
res1: Int = 16

scala> //5, 10, 1

scala> //you add up readInts

scala> 

scala> def sumPositive() : Int = {
     | val input = readInt
     | if(input >=0) {
     | input  + sumPositive()
     | } else 0
     | }
sumPositive: ()Int

scala> // when we call the function we are not passing anything because we only use the user input!! 

scala> sumPositive()
res2: Int = 9

scala> //8, 1,-1

scala> 

scala> // we don't pass any arguments,thus, we don't have something to count down towards the base case; our base case comes from the user input.

scala> def sumUntilQuit () : Int = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") 0
     | else input.toInt + sumUntilQuit()
     | }
sumUntilQuit: ()Int

scala> sumUntilQuit()
res3: Int = 15

scala> // 5,5,5, quit

scala> def sumAndCount () : (Int, Int) = {
     | val imput = readLine.toLowerCase.trim
     | if (input == "quit") (0.0)
     | else sumAndCount(input.toInt + sum, count +0)
     | }
<console>:17: error: not found: value input
       if (input == "quit") (0.0)
           ^
<console>:17: error: type mismatch;
 found   : Double(0.0)
 required: (Int, Int)
       if (input == "quit") (0.0)
                             ^
<console>:18: error: too many arguments for method sumAndCount: ()(Int, Int)
       else sumAndCount(input.toInt + sum, count +0)
                       ^

scala> //ok, it can't take any arguments. it can only have return values.

scala> //this is the trick by recursion with  user input. 

scala> def sumAndCount () : (Int, Int) = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") (0,0)
     | else {
     | val (sum, count) = sumAndCount()
     | (input.toInt + sum, count +1)
     | }
     | }
sumAndCount: ()(Int, Int)

scala> //so you assign the return values of sumAndCount() to some vals and then you add up user input to the sum accumulator and 1 to the count accumulator.

scala> sumAndCount()
res4: (Int, Int) = (4,2)

scala> // 1,3,quit

scala> val (s,c) = sumAndCount()
s: Int = 25
c: Int = 4

scala> println(s/4.toDouble)
6.25

scala> 

scala> //Abstracting Recursion

scala> def multAndCount () : (Int, Int) = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") (1,0) 
     | else {
     | val (prod, count) = multAndCount()
     | (input.toInt*prod, count +1)
     | }
     | }
multAndCount: ()(Int, Int)

scala> val (s,c) = multAndCount()
s: Int = 60
c: Int = 3

scala> // 2,6,5, quit

scala> // now we're going to write the HOF which can be used for both operations! 

scala> // the key is to ABSTRACT THE THINGS THAT CHANGE. These are the base and the operations done. 

scala> def inputAndCount (base: Int, op: (Int, Int) => Int) : (Int, Int) = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") (base, 0)
     | else {
     | val (value, count) = inputAndCount(base, op)
     | ( op(input.toInt, value), count +1 )
     | }
     | }
inputAndCount: (base: Int, op: (Int, Int) => Int)(Int, Int)

scala> val (s,c) = inputAndCount(0, _ + _)
s: Int = 9
c: Int = 2

scala> val (s,c) = inputAndCount(1, _ * _)
s: Int = 30
c: Int = 2

scala> // for the minimum, the base value is some large value which cannot be the min.

scala> val (s,c) = inputAndCount( Int.MaxValue, _ min _)
s: Int = 3
c: Int = 7

scala> val (s,c) = inputAndCount( Int.MaxValue, _ min _)
s: Int = 2147483647
c: Int = 0

scala> // expr match { } inside we have cases of patterns.

scala> /* expr match {
     | case pattern1 => ...
     | case pattern2 => ...
     | ....
     | }
     | */
     | 
     | 
You typed two blank lines.  Starting a new command.

scala> 

scala> // expression -> returns a value; statement -> side effects

scala> // we can have as many cases we want. firstly, the expr is evaluated, then it compares the expr. to each of the patterns and the first pattern which matches is the one that will be used.

scala> // example: convert fact with match

scala> def fact2 (n:Int) : Int = n match {
     | case 0 => 1
     | case _ => n*fact2(n-1)
     | }
fact2: (n: Int)Int

scala> def countDown2 (n:Int) : Unit = n match {
     | case 0 =>    // we do nothing  
     | case _ => 
     | println(n)
     | countDown2(n-1)
     | }
countDown2: (n: Int)Unit

scala> countDown2(5)
5
4
3
2
1

scala> 
scala> (readInt, readInt) match {
     | case (0,0) => "zero, zero"
     | case (1,0) => "one, zero"
     | case (_, _) => "something, something"
     | case (1,1) => "one, one"
     | }
<console>:19: warning: unreachable code
       case (1,1) => "one, one"
                     ^
java.lang.NumberFormatException: For input string: ""
  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
  at java.lang.Integer.parseInt(Integer.java:592)
  at java.lang.Integer.parseInt(Integer.java:615)
  at scala.collection.immutable.StringLike$class.toInt(StringLike.scala:273)
  at scala.collection.immutable.StringOps.toInt(StringOps.scala:29)
  at scala.io.StdIn$class.readInt(StdIn.scala:110)
  at scala.io.StdIn$.readInt(StdIn.scala:229)
  ... 47 elided

scala> (readInt, readInt) match {
     | case (0,0) => "zero, zero"
     | case (1,0) => "one, zero"
     | case (1,1) => "one, one"
     | case (_, _) => "something, something"
     | }
res14: String = something, something

scala> def fizzBuzz (i: Int) : Unit = {
     | if ( i<=100) {
     | (i%3, i%5) match {
     | case (0,0) => "fizzbuzz"
     | case (0, _) => "fizz"
     | case (_, 0) => "buzz"
     | case _ => i
     | }
     | fizzBuzz(i+1)
     | }
     | }
fizzBuzz: (i: Int)Unit

scala> fizzBuzz(90)
fizzbuzz
91
92
fizz
94
buzz
fizz
97
98
fizz
buzz

scala> // The try/catch construct (used as expression or statement)

scala> val i = try {
     | readInt 
     | } catch {
     | case e: NumberFormatException => 0
     | }
i: Int = 8

scala> readInt
java.lang.NumberFormatException: For input string: "a"
  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
  at java.lang.Integer.parseInt(Integer.java:580)
  at java.lang.Integer.parseInt(Integer.java:615)
  at scala.collection.immutable.StringLike$class.toInt(StringLike.scala:273)
  at scala.collection.immutable.StringOps.toInt(StringOps.scala:29)
  at scala.io.StdIn$class.readInt(StdIn.scala:110)
  at scala.io.StdIn$.readInt(StdIn.scala:229)
  ... 42 elided

scala> 

scala> def safeReadInt :Int = {
     | try {
     | readInt
     | } catch {
     | case e: NumberFormatException => 
     | println ("This wasn's a valid input. Please try again.")
     | safeReadInt
     | }
     | }
safeReadInt: Int

scala> // this shows how you use recursion until you get an input which doesn't throws a NumberFormatException.

scala> safeReadInt
This wasn's a valid input. Please try again.
res21: Int = 8

scala> // this type of try/catch constructs catch possible exceptions which make a program crash. So, when you believe a possible exception might be caused by a wrong type you should use it. 


Arrays

scala> Array(3,4,4,6,7)
res22: Array[Int] = Array(3, 4, 4, 6, 7)

scala> Array[Double](3,4,4,6,7)
res23: Array[Double] = Array(3.0, 4.0, 4.0, 6.0, 7.0)

scala> val arr = re22
<console>:14: error: not found: value re22
       val arr = re22
                 ^

scala> val arr = res22
arr: Array[Int] = Array(3, 4, 4, 6, 7)

scala> arr.length
res24: Int = 5

scala> arr.size
res25: Int = 5

scala> // arrays are mutable!!!

scala> arr(2)
res26: Int = 4

scala> arr(2) = 99

scala> arr(2)
res28: Int = 99

scala> arr
res29: Array[Int] = Array(3, 4, 99, 6, 7)

scala> // the size cannot be modified, just its elements. If the size is modified, a new array is created.

scala> // In general we use arrays when we know upfront how many elements we will have in that array. 

scala> // Arrays Functions

scala> def setArray (arr: Array[Int], v:Int, i:Int) : Unit = {} // returns Unit because the only thing that it does is that it mutates the array.
setArray: (arr: Array[Int], v: Int, i: Int)Unit

scala> arr(100)
java.lang.ArrayIndexOutOfBoundsException: 100
  ... 42 elided

scala> def setArray (arr: Array[Int], v:Int, i:Int) : Unit = {
     | if (i < arr.length) {
     | arr(i) = v
     | setArray(arr, v, i+1)
     | }
     | }
setArray: (arr: Array[Int], v: Int, i: Int)Unit

scala> val arr2 = setArray(arr, 99, 0)
arr2: Unit = ()

scala> println (setArray(arr, 99, 0))
()

scala> setArray(arr, 99, 0)

scala> arr
res33: Array[Int] = Array(99, 99, 99, 99, 99)

_____________________ new REPL session _________________________________


Array functions 2
Combine the elements of an array (reduce)

scala> def operateOnArray( arr: Array[Int], i: Int, f: (Int, Int) => Int) : Int = {
     | if (i<arr.length -1) {
     | f( arr(i), operateOnArray(arr, i+1, f))
     | } else {
     | arr(i)
     | }
     | }
operateOnArray: (arr: Array[Int], i: Int, f: (Int, Int) => Int)Int

scala> val nums = Array(1,2,3,4,5,6)
nums: Array[Int] = Array(1, 2, 3, 4, 5, 6)

scala> operateOnArray(nums, 0, _+_)
res0: Int = 21

scala> // we used recursion and the index to move across the array. 

scala> operateOnArray(nums, 0, _*_)
res1: Int = 720

scala> 

scala> // Lists 

scala> //lists are immutable!!

scala> List(5,3,8,2)
res2: List[Int] = List(5, 3, 8, 2)

scala> //lists allow you to very efficiently add elements in front of them.

scala> val lst = List(6,8,3,5)
lst: List[Int] = List(6, 8, 3, 5)

scala> // cons operator prepends elements in front of the list:

scala> 1 :: lst
res3: List[Int] = List(1, 6, 8, 3, 5)

scala> // read as "one cons list"

scala> // our old list is still there, this created a new list

scala> // the list with no elements: Nil!

scala> Nil
res4: scala.collection.immutable.Nil.type = List()

scala> 1::2::3::4::Nil
res5: List[Int] = List(1, 2, 3, 4)

scala> // this is one way to create lists

scala> lst
res6: List[Int] = List(6, 8, 3, 5)

scala> lst(2)
res7: Int = 3

scala> // lists are immutable so we cannot update the values of elements

scala> lst(2) =99
<console>:13: error: value update is not a member of List[Int]
       lst(2) =99
       ^

scala> // exercise: function which builds up a list:

scala> import io.StdIn._
import io.StdIn._

scala> // lists work very well when you don't know how many elements the list will have:

scala> def inputList (n: Int) : List[Int] = {
     | if (n<1) Nil
     | else readInt :: inputList(n-1)
     | }
inputList: (n: Int)List[Int]

scala> val list2 = inputList(4)
list2: List[Int] = List(2, 4, 7, 6)

scala> // THE ARRAY IS BEST WHEN YOU DO KNOW HOW MANY THINGS YOU HAVE AND IT ALLOWS YOU TO MUTATE THEM.

scala> // LISTS WORK VERY WELL IF YOU DON'T KNOW HOW MANY INPUTS YOU HAVE (e.g. functions which work with quit).

scala> // Methods that we can call on Lists

scala> lst
res9: List[Int] = List(6, 8, 3, 5)

scala> lst.head
res10: Int = 6

scala> lst.tail
res11: List[Int] = List(8, 3, 5)

scala> def operateOnList (lst: List[Int], base: Int, f: (Int, Int) => Int) : Int = {
     | if (lst == Nil) base 
     | else f(lst.head, operateOnList(lst.tail, base, f))
     | }
operateOnList: (lst: List[Int], base: Int, f: (Int, Int) => Int)Int

scala> operateOnList(lst, 0, _ + _)
res12: Int = 22

scala> def operateOnList2 (lst : List[Int], base :Int, f: (Int, Int) => Int) : Int = lst match {
     | case Nil => base
     | case h :: t => f( h, operateOnList2(t, base, f))
     | }
operateOnList2: (lst: List[Int], base: Int, f: (Int, Int) => Int)Int

scala> operateOnList2(lst, 0, _ + _)
res13: Int = 22

scala> // if we need to express head and tail in the case pattern we use h::t (something cons something).

scala> // you can use head and tail to go through the recursion.

scala> // and pull a list apart.

scala> 

scala> Array.fill(10)(5)
res14: Array[Int] = Array(5, 5, 5, 5, 5, 5, 5, 5, 5, 5)

scala> val zeros = Array.fill(5)(0)
zeros: Array[Int] = Array(0, 0, 0, 0, 0)

scala> val ones = Array.fill(7)(1)
ones: Array[Int] = Array(1, 1, 1, 1, 1, 1, 1)

scala> val randomArr = Array.fill(10)(Math.random)
randomArr: Array[Double] = Array(0.3840458302727937, 0.18531876116607027, 0.40188798438581586, 0.8813083321922234, 0.8483406976447233, 0.23323373087375598, 0.769075009059168, 0.7098601334456789, 0.7922765871511024, 0.6774729303710884)

scala> // the second argument of Array.fill()() is PASSED BY VALUE!

scala> // PASSED BY NAME AND PASSED BY VALUE

scala> // when it's passed by name it's not evaluated until it's needed.

scala> // when it's passed by value it's evaluated over and over again every time it is used.

scala> var i = 0
i: Int = 0

scala> Array.fill(10)({i += 1; i})
res15: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> // the power of the Array.fill method is that whatever you pass in the second argument list is evaluated however many times you do this (the code happens 10 times -> the i value goes from 0 to 10)

scala> Array.fill(5)(readInt)
res16: Array[Int] = Array(6, 4, 8, 9, 10)

scala> 

scala> // The tabulate Method

scala> // the second argument that is used is not a passed by value argument but actually a function.

scala> // you can apply the function based upon the index within the array.

scala> Array.tabulate(10)(i => i)
res17: Array[Int] = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> Array.tabulate(10)(i => i+1)
res18: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> Array.tabulate(10)(i => i*3)
res19: Array[Int] = Array(0, 3, 6, 9, 12, 15, 18, 21, 24, 27)

scala> Array.tabulate(10)(_*3)
res20: Array[Int] = Array(0, 3, 6, 9, 12, 15, 18, 21, 24, 27)

scala> Array.tabulate(10)(i => 1)
res21: Array[Int] = Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)

scala> Array.tabulate(10)(i => Math.random)
res22: Array[Double] = Array(0.20191398398631388, 0.6265324706044582, 0.48655836432577704, 0.7116700805114097, 0.6609740626109651, 0.19503212412721582, 0.22931306287334907, 0.7324552123193775, 0.01191449330197314, 0.6359747030068716)

scala> Array.tabulate(10)(i => 0)
res23: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

scala> Array.tabulate(10)(i => 7)
res24: Array[Int] = Array(7, 7, 7, 7, 7, 7, 7, 7, 7, 7)

scala> 

scala> // Collection Methods

scala> 

scala> // slicing

scala> // drop -> drops off that many elements given in the argument:

scala> val a = Array(5,2,9,3,1,8,6)
a: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.drop(2)
res25: Array[Int] = Array(9, 3, 1, 8, 6)

scala> // Drop drops elements from left!

scala> a.init
res26: Array[Int] = Array(5, 2, 9, 3, 1, 8)

scala> // init leaves out the last element

scala> a.last
res27: Int = 6

scala> a.slice(2,4)
res28: Array[Int] = Array(9, 3)

scala> // slice is inclusive on the first index and exclusive on the second index.

scala> a.splitAt(3)
res29: (Array[Int], Array[Int]) = (Array(5, 2, 9),Array(3, 1, 8, 6))

scala> // with splitAt I get a tuple of two arrays. 

scala> // the argument indicates how many values go into the first collection. 

scala> a.take(3)
res30: Array[Int] = Array(5, 2, 9)

scala> // take the first 3 elements

scala> a
res31: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.dropRight(3)
res32: Array[Int] = Array(5, 2, 9, 3)

scala> // drops off the last 3 elements

scala> a.takeRight(3)
res33: Array[Int] = Array(1, 8, 6)

scala> // takeRight gives you the last 3 elements

scala> 

scala> // Methods that do Boolean tests and searching inside collections

scala> 

scala> a
res34: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.contains(3)
res35: Boolean = true

scala> a.contains(99)
res36: Boolean = false

scala> a.endsWith(Array(1,8,6))
res37: Boolean = true

scala> a.endsWith(Array(1,8,4))
res38: Boolean = false

scala> a.endsWith(List(1,8,6))
res39: Boolean = true

scala> a.isEmpty
res40: Boolean = false

scala> a.nonEmpty
res41: Boolean = true

scala> a.startsWith((Array(5,2,9))
     | )
res42: Boolean = true

scala> a.indexOf(9)
res43: Int = 2

scala> a.indexOf(99)
res44: Int = -1

scala> //returns a -1 when the element is not found.

scala> a.lastIndexOf(1)
res45: Int = 4

scala> a.indexOf(1,5)
res46: Int = -1

scala> // finding ones starting with index 5

 
scala> 

scala> // Multiset difference:

scala> a
res47: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.diff(Array(2,9,6,8))
res48: Array[Int] = Array(5, 3, 1)

scala> // finds the elements present in a and not present in the other collection.

scala> a.diff(Array(2,7,6,8))
res49: Array[Int] = Array(5, 9, 3, 1)

scala> a.distinct
res50: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> // gives back a collection with no duplicates in it.

scala> Array(1,1,1,6,5,5,7,7,72,3,1).distinct
res51: Array[Int] = Array(1, 6, 5, 7, 72, 3)

scala> println(a)
[I@5572d111

scala> a.mkString
res53: String = 5293186

scala> a.mkString(",")
res54: String = 5,2,9,3,1,8,6

scala> a.mkString("(",",", ")"))
<console>:1: error: ';' expected but ')' found.
a.mkString("(",",", ")"))
                        ^

scala> a.mkString("(",",", ")")
res55: String = (5,2,9,3,1,8,6)

scala> a
res56: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> // take some subset from an array and replace it with something else

scala> a.patch(2,Nil, 3)
res57: Array[Int] = Array(5, 2, 8, 6)

scala> // removing with Nil

scala> a.patch(2,Array(77,88,99), 3)
res58: Array[Int] = Array(5, 2, 77, 88, 99, 8, 6)

scala> // patch(location, what you put in that place, how many things you want to replace)

scala> a.reverse
res59: Array[Int] = Array(6, 8, 1, 3, 9, 2, 5)

scala> a.toList
res60: List[Int] = List(5, 2, 9, 3, 1, 8, 6)

scala> res60.toArray
res61: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> // zip 

scala> val lst2 = List("one", "two", "three", "four")
lst2: List[String] = List(one, two, three, four)

scala> a.zip(lst2)
res62: Array[(Int, String)] = Array((5,one), (2,two), (9,three), (3,four))

scala> // WHEN ONE COLLECTION ENDS, THEN THE zip METHOD ENDS!

scala> // zip pairs together the two collections in form of tuples.

scala> lst2.zip(a)
res63: List[(String, Int)] = List((one,5), (two,2), (three,9), (four,3))

scala> // it takes over the type of the first argument!!!

scala> a.zipWithIndex
res64: Array[(Int, Int)] = Array((5,0), (2,1), (9,2), (3,3), (1,4), (8,5), (6,6))

scala> lst2.zipWithIndex
res65: List[(String, Int)] = List((one,0), (two,1), (three,2), (four,3))

scala> a.min
res66: Int = 1

scala> lst2.min
res67: String = four

scala> a.max
res68: Int = 9

scala> a.sum
res69: Int = 34

scala> lst.sum
res70: Int = 22

scala> lst2.sum
<console>:19: error: could not find implicit value for parameter num: Numeric[String]
       lst2.sum
            ^

scala> a.product
res72: Int = 12960

scala> // min, max, sum , product for NUMERIC VALUES!!

scala> a.sum/a.length
res73: Int = 4

scala> a.sum/a.length.toDoub
<console>:19: error: value toDoub is not a member of Int
       a.sum/a.length.toDoub
                      ^

scala> a.sum/a.length.toDouble
res75: Double = 4.857142857142857

scala> 

scala> // HIGHER-ORDER METHODS (map and filter)

scala>

scala> a
res76: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.map(_ *2)
res77: Array[Int] = Array(10, 4, 18, 6, 2, 16, 12)

scala> //map returns a new collection

scala> a.map(_ * _)
<console>:19: error: missing parameter type for expanded function ((x$1, x$2) => x$1.$times(x$2))
       a.map(_ * _)
             ^
<console>:19: error: missing parameter type for expanded function ((x$1: <error>, x$2) => x$1.$times(x$2))
       a.map(_ * _)
                 ^

scala> a.map(_ /0.5)
res79: Array[Double] = Array(10.0, 4.0, 18.0, 6.0, 2.0, 16.0, 12.0)

scala> 

scala> // filter: passes in a predicate to filter 

scala> a.filter( i => i%2 ==1)
res80: Array[Int] = Array(5, 9, 3, 1)

scala> a.filter( i => i%2 ==1).map(_ *2)
res81: Array[Int] = Array(10, 18, 6, 2)

scala> 

scala> a.count( _%2 ==0)
res82: Int = 3

scala> a.dropWhile(_<9)
res83: Array[Int] = Array(9, 3, 1, 8, 6)

scala> // dropWhile drops things until it meets a 9 and is less than 9

scala> a.dropWhile(_<1)
res84: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.dropWhile(_ >1)
res85: Array[Int] = Array(1, 8, 6)

scala> a.exists(_ %7 ==0)
res86: Boolean = false

scala> a.exists(_ %4 ==0)
res87: Boolean = true

scala> 

scala> //flatmap

scala> val arr3 = Array(Array(1,2,3,4), Array(5,6,7,8))
arr3: Array[Array[Int]] = Array(Array(1, 2, 3, 4), Array(5, 6, 7, 8))

scala> arr3.flatMap(i=> i)
res90: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8)

scala> a.forall(_< 7)
res98: Boolean = false

scala> a.forall(_< 70)
res99: Boolean = true

scala> a.foreach(println)
5
2
9
3
1
8
6

scala> //foreach more for sife effects

scala> a.indexWhere(_ % 2 == 0)
res101: Int = 1

scala> a
res102: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)


scala> // find the index where some predicate is satisfied

scala> a.indexWhere( _ == 8)
res103: Int = 5

scala> //does the same thing as indexOf!

scala> a.lastIndexWhere(_ ==8)
res104: Int = 5

scala> a.lastIndexWhere( _ %3 ==0)
res105: Int = 6

scala> a.partition( _ %2==0)
res106: (Array[Int], Array[Int]) = (Array(2, 8, 6),Array(5, 9, 3, 1))

scala> // partition returns a tuple of two collections: the first which satisfies a predicate and the second with elements which don't satisfy a predicate.

scala> val (evens, odds) = a.partition(_%2 ==0)
evens: Array[Int] = Array(2, 8, 6)
odds: Array[Int] = Array(5, 9, 3, 1)

scala> //takeWhile

scala> a.takeWhile(_ %3 !=0)
res107: Array[Int] = Array(5, 2)

scala> a
res108: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> 

scala> // reduce and fold

scala> 

scala> a.reduceLeft(_ + _)
res109: Int = 34

scala> a.sum
res110: Int = 34

scala> a.reduceLeft((a,b) => {println(a+","+b); a+b})
5,2
7,9
16,3
19,1
20,8
28,6
res111: Int = 34

scala> a
res112: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.reduceRight((a,b) => {println(a+","+b); a+b})
8,6
1,14
3,15
9,18
2,27
5,29
res113: Int = 34

scala> a.reduceLeft((a,b) => {println(a+","+b); a-b})
5,2
3,9
-6,3
-9,1
-10,8
-18,6
res114: Int = -24

scala> a.reduceRight((a,b) => {println(a+","+b); a-b})
8,6
1,2
3,-1
9,4
2,5
5,-3
res115: Int = 8

scala> // depending on the operation we do, the reduceRight and reduceLeft might deliver different results.

scala> 

scala> // fold -> for more flexibility regarding types used

scala> a.foldLeft(0)(_ + _) //tekes two arguments: 1st is the accumulator and the 2nd is the function used in folding
res116: Int = 34

scala> a.foldLeft("")(_+_)
res117: String = 5293186

scala> //concatencates values to string.

scala> a.foldLeft("")(_+_+",")
res118: String = 5,2,9,3,1,8,6,

scala> // reduceLeft takes a function with two arguments!

scala> // foldLeft takes two lists of parameters: acc and function with two param.

scala> 

scala> // Combinatorial/Iterator Methods

scala> 

scala> var i = 0
i: Int = 0

scala> val nums = Array.fill(5)({i+=1;i})
nums: Array[Int] = Array(1, 2, 3, 4, 5)

An iterator is much like a collection, except that as you go through the values they are consumed. The advantage is that large collections don't consume that much memory.  

scala> nums.combinations(3)
res0: Iterator[Array[Int]] = non-empty iterator

scala> //an iterator of arrays

scala> //you don't want to create all those combinations at once and fill the memory of the computer

scala> //we can go through them one at the time and throw them away  when we are done. 

scala> nums.combinations(3).foreach(println)
[I@567387f0
[I@62cf019b
[I@d440e4b
[I@17a8f94a
[I@5d2eb048
[I@4777b1af
[I@6aecd95c
[I@3ade0fe2
[I@12da4401
[I@68da753c

scala> nums.combinations(3).foreach( a => println(a.mkString(",") )
     | )
1,2,3
1,2,4
1,2,5
1,3,4
1,3,5
1,4,5
2,3,4
2,3,5
2,4,5
3,4,5

scala> res0
res3: Iterator[Array[Int]] = non-empty iterator

scala> res0.next
res4: Array[Int] = Array(1, 2, 3)

scala> res0.next
res5: Array[Int] = Array(1, 2, 4)

scala> res0.next
res6: Array[Int] = Array(1, 2, 5)

scala> res0.next
res7: Array[Int] = Array(1, 3, 4)

scala> res0.next
res8: Array[Int] = Array(1, 3, 5)

scala> res0.next
res9: Array[Int] = Array(1, 4, 5)

scala> res0.next
res10: Array[Int] = Array(2, 3, 4)

scala> res0.next
res11: Array[Int] = Array(2, 3, 5)

scala> res0.next
res12: Array[Int] = Array(2, 4, 5)

scala> res0.next
res13: Array[Int] = Array(3, 4, 5)

scala> res0.next
java.util.NoSuchElementException: next on empty iterator
  at scala.collection.Iterator$$anon$2.next(Iterator.scala:39)
  at scala.collection.Iterator$$anon$2.next(Iterator.scala:37)
  at scala.collection.SeqLike$CombinationsItr.next(SeqLike.scala:219)
  ... 42 elided

scala> res0.hasNext
res15: Boolean = false

scala> // -> the combinations method give back an iterator

scala> // Another method that gives back an iterator is grouped.

scala> Array.tabulate(15)(i=>i)
res16: Array[Int] = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)

scala> Array.tabulate(15)(i=>i).grouped(3)
res17: Iterator[Array[Int]] = non-empty iterator

scala> Array.tabulate(15)(i=>i).grouped(3).foreach( a => println( a.mkString(",")))
0,1,2
3,4,5
6,7,8
9,10,11
12,13,14

scala> Array.tabulate(15)(i=>i).grouped(4).foreach( a => println( a.mkString(",")))
0,1,2,3
4,5,6,7
8,9,10,11
12,13,14

scala> // the inits method returns an interator and the iterator is all of the initial calls that you would get if you were to go through the collection.

scala> nums.init
res20: Array[Int] = Array(1, 2, 3, 4)

scala> nums.inits
res21: Iterator[Array[Int]] = non-empty iterator

scala> nums.inits.foreach( a => println( a.mkString(",")))
1,2,3,4,5
1,2,3,4
1,2,3
1,2
1


scala> nums.init
res23: Array[Int] = Array(1, 2, 3, 4)

scala> nums.permutations.foreach( a => println( a.mkString(",")))
1,2,3,4,5
1,2,3,5,4
1,2,4,3,5
1,2,4,5,3
1,2,5,3,4
1,2,5,4,3
1,3,2,4,5
1,3,2,5,4
1,3,4,2,5
1,3,4,5,2
1,3,5,2,4
1,3,5,4,2
1,4,2,3,5
1,4,2,5,3
1,4,3,2,5
1,4,3,5,2
1,4,5,2,3
1,4,5,3,2
1,5,2,3,4
1,5,2,4,3
1,5,3,2,4
1,5,3,4,2
1,5,4,2,3
1,5,4,3,2
2,1,3,4,5
2,1,3,5,4
2,1,4,3,5
2,1,4,5,3
2,1,5,3,4
2,1,5,4,3
2,3,1,4,5
2,3,1,5,4
2,3,4,1,5
2,3,4,5,1
2,3,5,1,4
2,3,5,4,1
2,4,1,3,5
2,4,1,5,3
2,4,3,1,5
2,4,3,5,1
2,4,5,1,3
2,4,5,3,1
2,5,1,3,4
2,5,1,4,3
2,5,3,1,4
2,5,3,4,1
2,5,4,1,3
2,5,4,3,1
3,1,2,4,5
3,1,2,5,4
3,1,4,2,5
3,1,4,5,2
3,1,5,2,4
3,1,5,4,2
3,2,1,4,5
3,2,1,5,4
3,2,4,1,5
3,2,4,5,1
3,2,5,1,4
3,2,5,4,1
3,4,1,2,5
3,4,1,5,2
3,4,2,1,5
3,4,2,5,1
3,4,5,1,2
3,4,5,2,1
3,5,1,2,4
3,5,1,4,2
3,5,2,1,4
3,5,2,4,1
3,5,4,1,2
3,5,4,2,1
4,1,2,3,5
4,1,2,5,3
4,1,3,2,5
4,1,3,5,2
4,1,5,2,3
4,1,5,3,2
4,2,1,3,5
4,2,1,5,3
4,2,3,1,5
4,2,3,5,1
4,2,5,1,3
4,2,5,3,1
4,3,1,2,5
4,3,1,5,2
4,3,2,1,5
4,3,2,5,1
4,3,5,1,2
4,3,5,2,1
4,5,1,2,3
4,5,1,3,2
4,5,2,1,3
4,5,2,3,1
4,5,3,1,2
4,5,3,2,1
5,1,2,3,4
5,1,2,4,3
5,1,3,2,4
5,1,3,4,2
5,1,4,2,3
5,1,4,3,2
5,2,1,3,4
5,2,1,4,3
5,2,3,1,4
5,2,3,4,1
5,2,4,1,3
5,2,4,3,1
5,3,1,2,4
5,3,1,4,2
5,3,2,1,4
5,3,2,4,1
5,3,4,1,2
5,3,4,2,1
5,4,1,2,3
5,4,1,3,2
5,4,2,1,3
5,4,2,3,1
5,4,3,1,2
5,4,3,2,1

scala> nums.sliding(3).foreach( a => println( a.mkString(",")))
1,2,3
2,3,4
3,4,5

scala> // groups of 3 but each one has an overleaf

scala> // groups of 3 but each one has an overleft

scala> // sliding advances one element at the time

scala> // is like a frame that slides down through our collection and the frame is of size 3.

scala> //running window 

scala> nums.tails.foreach( a => println( a.mkString(",")))
1,2,3,4,5
2,3,4,5
3,4,5
4,5
5


scala> // returns all possible tails after moving across the collection

scala> nums.tails.toList
res27: List[Array[Int]] = List(Array(1, 2, 3, 4, 5), Array(2, 3, 4, 5), Array(3, 4, 5), Array(4, 5), Array(5), Array())

scala> 

scala> // different useful methods like permutations, combinations. 

scala> 

scala> "1 2 3 4 5".split(" ").map(_.toInt)
res28: Array[Int] = Array(1, 2, 3, 4, 5)

scala> 

 
scala> // collections give us the ability to store and manipulate large amounts of data.


Playing with data:
- create arrays with Array.fill(34009)(readline) SUPER TIP!!!
- then filter the arrays on different variables (like year or gender or name).
- then map through the elements of those new subsets and extract information with counting the occurences and finding max or min values, etc.. 


_____________________ new REPL session ________________________________

The Option Type

- represents something that may or may not have a value
- it's used broadly so that the type system can help you find errors. If something doesn't have a value instead of causing an error, you are forced to deal with it.

Using the find method (for lists and arrays and passes a predicate) to give an example of Option use:

scala> val lst = List(1,2,3,4,5)
lst: List[Int] = List(1, 2, 3, 4, 5)

scala> lst.find(_ >6)
res0: Option[Int] = None

scala> // the Option type can either be None or Some.

scala> lst.find(_ >3)
res1: Option[Int] = Some(4)

scala> lst.find(_ >3).get
res2: Int = 4

scala> // use get to access the value

scala> lst.find(_>6).get
java.util.NoSuchElementException: None.get
  at scala.None$.get(Option.scala:347)
  at scala.None$.get(Option.scala:345)
  ... 42 elided

scala> // in the case of None, get throws an error!!!

scala> // you can get the value or you have a default for the case when you have such an error.

scala> // for this there is the getOrELse method.

scala> lst.find(_ > 3).getOrElse(0)
res4: Int = 4

scala> lst.find(_ > 6).getOrElse(0)
res5: Int = 0

scala> // getOrElse sets the default value for false cases.

scala> // You can safely use getOrElse for many cases to get the value for Some or get some default value for None. 

scala> // You can also use map and flatmap (which are defined also for Option)

scala> lst.find(_ > 6).map(_*2)
res6: Option[Int] = None

scala> lst.find(_ > 3).map(_*2)
res7: Option[Int] = Some(8)

scala> // map functions like in the normal case for arrays and lists if there is a Some, or returns a None for the case of a missing value (i.e. None).

scala> // You can also use match:

scala> lst.find(_ >3) match {
     | case Some(n) => n*5
     | case None => 0
     | }
res8: Int = 20

scala> // You can also work with if:

scala> val result = lst.find(_>3)
result: Option[Int] = Some(4)

scala> if(result.nonEmpty) result.get*5 else 0
res9: Int = 20

scala> // Parametric functions

scala> def ident[A](o:A):A = o
ident: [A](o: A)A

scala> ident(1)
res10: Int = 1

scala> ident(1.0)
res11: Double = 1.0

scala> // type abstraction

scala> def makeTuple[A,B] (a:A, b:B):(A,B) = (a,b)
makeTuple: [A, B](a: A, b: B)(A, B)

scala> makeTuple(1,2.2)
res12: (Int, Double) = (1,2.2)

scala> makeTuple(0.1, 1.4)
res13: (Double, Double) = (0.1,1.4)

scala> def threeList[A] (a1:A, a2:A, a3:A) : List[A] = List(a1,a2,a3)
threeList: [A](a1: A, a2: A, a3: A)List[A]

scala> threeList(1,2,3)
res14: List[Int] = List(1, 2, 3)

scala> threeList(1.0,2.0,3.0)
res15: List[Double] = List(1.0, 2.0, 3.0)

scala> def ourFold [A, B] (lst:List[A], base:B) (f:(A,B)=> B) :B =lst match {
     | case Nil => base
     | case h::t => f(h, ourFold(t, base)(f))
     | }
ourFold: [A, B](lst: List[A], base: B)(f: (A, B) => B)B

scala> ourFold(List(1,2,3,4,5), 0)(_ + _)
res17: Int = 15

scala> 

scala> // Subtyping

scala> 

scala> // one type can be a subtype of another. You can use the subtype in any place where a supertype is needed. 

scala> List(5, true)
res18: List[AnyVal] = List(5, true)

scala> // scala chooses a type that is above both!

scala> List("hi", Some(5))
res19: List[java.io.Serializable] = List(hi, Some(5))

scala> List("hi", List(2,3))
res20: List[java.io.Serializable] = List(hi, List(2, 3))

scala> List("hi",2,3)
res21: List[Any] = List(hi, 2, 3)

scala> // Null is a subtype of everything under AnyRef

scala> // we try to avoid it! 

scala> // type Nothing. Under everything

scala> // Nothing has no value. You cannot make anything of type Nothing.

scala> List()
res22: List[Nothing] = List()

scala> // we can build it up with everything that's above it!!!

scala> 

scala> // Variable no. of arguments! (varargs)

scala> 

scala> def average (n:Double*) : Double = if (n.length>0) n.sum/n.length else 0
average: (n: Double*)Double

scala> average(1,2,3)
res23: Double = 2.0

scala> val nums = List(94.0, 95, 97, 99)
nums: List[Double] = List(94.0, 95.0, 97.0, 99.0)

scala> average(nums:_*)
res24: Double = 96.25

scala> 

scala> // Mutability and Aliasing

scala> 

scala> // mutable types can also imply aliasing.

scala> 

_____________________ new REPL session _____________________________


Currying

- several argument lists
- having a function that returns a function (the idea is that you can partially apply these functions)
- example: def add(x: Int) : Int => Int = y => x+y

scala> def add (x: Int): Int => Int = y => x+y
add: (x: Int)Int => Int

scala> add(5)
res0: Int => Int = <function1>

scala> add(5)(7)
res1: Int = 12

scala> def add2(x:Int)(y:Int) : Int = x+y
add2: (x: Int)(y: Int)Int

scala> add2(5)(7)
res2: Int = 12

scala> add2(5)
<console>:13: error: missing argument list for method add2
Unapplied methods are only converted to functions when a function type is expected.
You can make this conversion explicit by writing `add2 _` or `add2(_)(_)` instead of `add2`.
       add2(5)
           ^

scala> add2(5)_
res4: Int => Int = <function1>

scala> res4(7)
res5: Int = 12

scala> def courseAverage (tests: Int*)(assgns: Int*)(quizzes: Int*) = {
     | 0.4*tests.sum/tests.length + 0.4*assgns.sum/assgns.length + 0.2*quizzes.sum/quizzes.length
     | }
courseAverage: (tests: Int*)(assgns: Int*)(quizzes: Int*)Double

scala> courseAverage(90, 80)(100, 96)(50, 32)
res6: Double = 81.4

scala> add2{5}{6}
res7: Int = 11

scala> add2{
     | println("hi")
     | 5
     | }{
     | println("there")
     | 6
     | }
hi
there
res8: Int = 11

scala> 

scala> // By Name 

scala> def incrByName (i: => Int): Int = {
     | println("Start incrbn")
     | i+1
     | }
incrByName: (i: => Int)Int

scala> // i is a by name param that gives back an Int, and every time that we use i it's supposed to be evaluated.

scala> // when we have it in the body function, all stuff before i is evaluated firstly, then the code associated with tne param is evaluated.

scala> // you can use currying just to use a by name parameter within curly braaces (so, within a code block) that gets evaluated each time the param is used. 

scala> // when you use a by name parameter, you can pass an argument within a code block for the function using it, and depending what in that code happens it evaluates the parameter each time it is used. 

scala> 

scala> // USE Array.fill(r,c)(i) to create a matrix with r rows and c columns, filled with i:

scala> Array.fill(3,5)(0)
res9: Array[Array[Int]] = Array(Array(0, 0, 0, 0, 0), Array(0, 0, 0, 0, 0), Array(0, 0, 0, 0, 0))

scala> Array.tabulate(10, 10)((i,j) => i*j)
res10: Array[Array[Int]] = Array(Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0), Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9), Array(0, 2, 4, 6, 8, 10, 12, 14, 16, 18), Array(0, 3, 6, 9, 12, 15, 18, 21, 24, 27), Array(0, 4, 8, 12, 16, 20, 24, 28, 32, 36), Array(0, 5, 10, 15, 20, 25, 30, 35, 40, 45), Array(0, 6, 12, 18, 24, 30, 36, 42, 48, 54), Array(0, 7, 14, 21, 28, 35, 42, 49, 56, 63), Array(0, 8, 16, 24, 32, 40, 48, 56, 64, 72), Array(0, 9, 18, 27, 36, 45, 54, 63, 72, 81))

scala> Array.tabulate(10, 10)((i,j) => s"$i $j"
     | )
res15: Array[Array[String]] = Array(Array(0 0, 0 1, 0 2, 0 3, 0 4, 0 5, 0 6, 0 7, 0 8, 0 9), Array(1 0, 1 1, 1 2, 1 3, 1 4, 1 5, 1 6, 1 7, 1 8, 1 9), Array(2 0, 2 1, 2 2, 2 3, 2 4, 2 5, 2 6, 2 7, 2 8, 2 9), Array(3 0, 3 1, 3 2, 3 3, 3 4, 3 5, 3 6, 3 7, 3 8, 3 9), Array(4 0, 4 1, 4 2, 4 3, 4 4, 4 5, 4 6, 4 7, 4 8, 4 9), Array(5 0, 5 1, 5 2, 5 3, 5 4, 5 5, 5 6, 5 7, 5 8, 5 9), Array(6 0, 6 1, 6 2, 6 3, 6 4, 6 5, 6 6, 6 7, 6 8, 6 9), Array(7 0, 7 1, 7 2, 7 3, 7 4, 7 5, 7 6, 7 7, 7 8, 7 9), Array(8 0, 8 1, 8 2, 8 3, 8 4, 8 5, 8 6, 8 7, 8 8, 8 9), Array(9 0, 9 1, 9 2, 9 3, 9 4, 9 5, 9 6, 9 7, 9 8, 9 9))

scala> // to get the position of element a_ij within a matrix.

scala> // VERY USEFUL COMMENTS!

scala> 

scala> // Classifying Bugs

scala> 

scala> import io.StdIn._
import io.StdIn._

scala> def fact (n:Int) : Int = if (n<2) 1 else (n*fact(n-1))
fact: (n: Int)Int

scala> fact(5)
res17: Int = 120

- syntax errors
- runtime errors: e.g. NumberFormatException, ArrayIndexOutOfBoundsException, the infinite recursion 
(they show where it crashes, not what went wrong)
- the logic error: no error messages, only that we know the result is not right. 
(use print statements across the code, to check if the logic is right)

___________________________new REPL session ____________________________

 The while Loop

while (cond) {
	body
}

Uses vars!!

scala> var i = 0
i: Int = 0

scala> while (i<10) {
     | println (i)
     | i+=1
     | }
0
1
2
3
4
5
6
7
8
9

scala> def readInts : List[Int] = {
     | var input = readLine
     | var lst = List[Int]()
     | while (input != "quit") {
     | lst = input.toInt :: lst
     | }
     | lst
     | }
readInts: List[Int]

-> CAUSES AN INFINITE LOOP ->  java.lang.StackOverflowError

I HAVE TO SET THE INPUT TO READLINE AGAIN BECAUSE IT KEEPS APPENDING THE SAME LINE OVER AND OVER AGAIN WITHOUT STOPPING.

scala> def readInts : List[Int] = {
     | var input = readLine
     | var lst = List[Int]()
     | while ( input != "quit" ) {
     | lst ::= input.toInt
     | input = readLine
     | }
     | lst.reverse
     | }
readInts: List[Int]

scala> readInts
java.lang.NumberFormatException: For input string: "6 6 6 6 quit"
  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
  at java.lang.Integer.parseInt(Integer.java:580)
  at java.lang.Integer.parseInt(Integer.java:615)
  at scala.collection.immutable.StringLike$class.toInt(StringLike.scala:273)
  at scala.collection.immutable.StringOps.toInt(StringOps.scala:29)
  at .readInts(<console>:18)
  ... 42 elided

scala> readInts
res4: List[Int] = List(6789)

scala> readInts
res8: List[Int] = List(6, 7, 8, 9)



The do-while Loop

do {

body

} while (cond)


The for Loops

for (i <- 0 to 9) println(i)

foreach equiv.

_________________________ new REPL session _____________________________

Ranges:

scala> 0 to 9
res0: scala.collection.immutable.Range.Inclusive = Range(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> 0 until 10
res1: scala.collection.immutable.Range = Range(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> 0.to(9)
res2: scala.collection.immutable.Range.Inclusive = Range(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> // methods for Ints

scala> val lst = List(6,9,2,7,8,1,3)
lst: List[Int] = List(6, 9, 2, 7, 8, 1, 3)

scala> for (i <- lst) println(i)
6
9
2
7
8
1
3

 
scala> Array(1,2,3,4,5).indices
res5: scala.collection.immutable.Range = Range(0, 1, 2, 3, 4)

scala> 'a' to 'z'
res6: scala.collection.immutable.NumericRange.Inclusive[Char] = NumericRange(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)

scala> 1L to 10L
res7: scala.collection.immutable.NumericRange.Inclusive[Long] = NumericRange(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> 1.0 to 2.0
res8: Range.Partial[Double,scala.collection.immutable.NumericRange[Double]] = scala.collection.immutable.Range$Partial@c0907f3

scala> 1.0 to 2.0 by 0.1
res9: scala.collection.immutable.NumericRange[Double] = NumericRange(1.0, 1.1, 1.2000000000000002, 1.3000000000000003, 1.4000000000000004, 1.5000000000000004, 1.6000000000000005, 1.7000000000000006, 1.8000000000000007, 1.9000000000000008, 2.000000000000001)

scala> 10 to 1 by 1
res10: scala.collection.immutable.Range = Range()

scala> 10 to 1 by -1
res11: scala.collection.immutable.Range = Range(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)

scala> 10 to 1 by -2
res12: scala.collection.immutable.Range = Range(10, 8, 6, 4, 2)

scala> // using steps

scala>
 
scala> // yield

scala> 

scala> for (i <- 1 to 10) yield i
res13: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> for (i <- 1 to 10) yield i*i
res14: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)

scala> def evalPolyYield (coeffs: Array[Double], x:Double) : Double = {
     | (for (i<- coeffs.indices) yield {
     | coeffs(i)*math.pow(x, coeffs.length -1 -i) 
     | }).sum
     | }
evalPolyYield: (coeffs: Array[Double], x: Double)Double

scala> evalPolyYield(Array(3,2,-5), 1))
<console>:1: error: ';' expected but ')' found.
evalPolyYield(Array(3,2,-5), 1))
                               ^

scala> evalPolyYield(Array(3,2,-5), 1)
res15: Double = 0.0

scala> // this evalPoly version has no vars -> no mutations 

scala> // our for is producing values and we are using those values that for produces

scala> 

scala> // if Guards

scala> 

scala> for (i <- 1 to 10 ; if i%2==0) yield (i*i)
res17: scala.collection.immutable.IndexedSeq[Int] = Vector(4, 16, 36, 64, 100)


scala> for {
     | i <- 1 to 10
     | if i%2==0
     | } yield i*i
res18: scala.collection.immutable.IndexedSeq[Int] = Vector(4, 16, 36, 64, 100)

scala> 

scala> // Multiple Generators

scala> 

scala> // similar to tabulate of yesterday with ij

scala> for (i <- 1 to 10; j <- 1 to 10) yield (i,j)
res20: scala.collection.immutable.IndexedSeq[(Int, Int)] = Vector((1,1), (1,2), (1,3), (1,4), (1,5), (1,6), (1,7), (1,8), (1,9), (1,10), (2,1), (2,2), (2,3), (2,4), (2,5), (2,6), (2,7), (2,8), (2,9), (2,10), (3,1), (3,2), (3,3), (3,4), (3,5), (3,6), (3,7), (3,8), (3,9), (3,10), (4,1), (4,2), (4,3), (4,4), (4,5), (4,6), (4,7), (4,8), (4,9), (4,10), (5,1), (5,2), (5,3), (5,4), (5,5), (5,6), (5,7), (5,8), (5,9), (5,10), (6,1), (6,2), (6,3), (6,4), (6,5), (6,6), (6,7), (6,8), (6,9), (6,10), (7,1), (7,2), (7,3), (7,4), (7,5), (7,6), (7,7), (7,8), (7,9), (7,10), (8,1), (8,2), (8,3), (8,4), (8,5), (8,6), (8,7), (8,8), (8,9), (8,10), (9,1), (9,2), (9,3), (9,4), (9,5), (9,6), (9,7), (9,8), (9,9), (9,10), (10,1), (10,2), (10,3), (10,4), (10,5), (10,6), (10,7), (10,8), (10,9), (10,10))

scala> Array.tabulate(10, 10) ((i,j) => (i,j))
res21: Array[Array[(Int, Int)]] = Array(Array((0,0), (0,1), (0,2), (0,3), (0,4), (0,5), (0,6), (0,7), (0,8), (0,9)), Array((1,0), (1,1), (1,2), (1,3), (1,4), (1,5), (1,6), (1,7), (1,8), (1,9)), Array((2,0), (2,1), (2,2), (2,3), (2,4), (2,5), (2,6), (2,7), (2,8), (2,9)), Array((3,0), (3,1), (3,2), (3,3), (3,4), (3,5), (3,6), (3,7), (3,8), (3,9)), Array((4,0), (4,1), (4,2), (4,3), (4,4), (4,5), (4,6), (4,7), (4,8), (4,9)), Array((5,0), (5,1), (5,2), (5,3), (5,4), (5,5), (5,6), (5,7), (5,8), (5,9)), Array((6,0), (6,1), (6,2), (6,3), (6,4), (6,5), (6,6), (6,7), (6,8), (6,9)), Array((7,0), (7,1), (7,2), (7,3), (7,4), (7,5), (7,6), (7,7), (7,8), (7,9)), Array((8,0), (8,1), (8,2), (8,3), (8,4), (8,5), (8,6), (8,7), (8,8), (8,9)), Array((9,0), (9,1), (9,2), (9,3), (9,4), (9,5), (9,6), (9,7), (9..

scala> Array.tabulate(10, 10) ((i,j) => (i,j, j*i))
res25: Array[Array[(Int, Int, Int)]] = Array(Array((0,0,0), (0,1,0), (0,2,0), (0,3,0), (0,4,0), (0,5,0), (0,6,0), (0,7,0), (0,8,0), (0,9,0)), Array((1,0,0), (1,1,1), (1,2,2), (1,3,3), (1,4,4), (1,5,5), (1,6,6), (1,7,7), (1,8,8), (1,9,9)), Array((2,0,0), (2,1,2), (2,2,4), (2,3,6), (2,4,8), (2,5,10), (2,6,12), (2,7,14), (2,8,16), (2,9,18)), Array((3,0,0), (3,1,3), (3,2,6), (3,3,9), (3,4,12), (3,5,15), (3,6,18), (3,7,21), (3,8,24), (3,9,27)), Array((4,0,0), (4,1,4), (4,2,8), (4,3,12), (4,4,16), (4,5,20), (4,6,24), (4,7,28), (4,8,32), (4,9,36)), Array((5,0,0), (5,1,5), (5,2,10), (5,3,15), (5,4,20), (5,5,25), (5,6,30), (5,7,35), (5,8,40), (5,9,45)), Array((6,0,0), (6,1,6), (6,2,12), (6,3,18), (6,4,24), (6,5,30), (6,6,36), (6,7,42), (6,8,48), (6,9,54)), Array((7,0,0), (7,1,7), (7,2,14), (7,3,...

scala> //if you want to obtain 3 tuples (i,j,i*j)

scala> 

scala> // generate grid points:

scala> for (x<- -1.0 to 1.0 by 0.1; y<- -1.0 to 1.0 by 0.1) yield (x,y)
res26: scala.collection.immutable.IndexedSeq[(Double, Double)] = Vector((-1.0,-1.0), (-1.0,-0.9), (-1.0,-0.8), (-1.0,-0.7000000000000001), (-1.0,-0.6000000000000001), (-1.0,-0.5000000000000001), (-1.0,-0.40000000000000013), (-1.0,-0.30000000000000016), (-1.0,-0.20000000000000015), (-1.0,-0.10000000000000014), (-1.0,-1.3877787807814457E-16), (-1.0,0.09999999999999987), (-1.0,0.19999999999999987), (-1.0,0.2999999999999999), (-1.0,0.3999999999999999), (-1.0,0.4999999999999999), (-1.0,0.5999999999999999), (-1.0,0.6999999999999998), (-1.0,0.7999999999999998), (-1.0,0.8999999999999998), (-1.0,0.9999999999999998), (-0.9,-1.0), (-0.9,-0.9), (-0.9,-0.8), (-0.9,-0.7000000000000001), (-0.9,-0.6000000000000001), (-0.9,-0.5000000000000001), (-0.9,-0.40000000000000013), (-0.9,-0.30000000000000016), (...

scala> 

scala> // Patterns in for Loops

scala> List((1,2),(3,4), (1,7), (6,5), (0,3), (1,9))
res27: List[(Int, Int)] = List((1,2), (3,4), (1,7), (6,5), (0,3), (1,9))

scala> val tuples = res27
tuples: List[(Int, Int)] = List((1,2), (3,4), (1,7), (6,5), (0,3), (1,9))

scala> for ((n1,n2) <- tuples) println(n1+" "+n2)
1 2
3 4
1 7
6 5
0 3
1 9

scala> val grid = res26
grid: scala.collection.immutable.IndexedSeq[(Double, Double)] = Vector((-1.0,-1.0), (-1.0,-0.9), (-1.0,-0.8), (-1.0,-0.7000000000000001), (-1.0,-0.6000000000000001), (-1.0,-0.5000000000000001), (-1.0,-0.40000000000000013), (-1.0,-0.30000000000000016), (-1.0,-0.20000000000000015), (-1.0,-0.10000000000000014), (-1.0,-1.3877787807814457E-16), (-1.0,0.09999999999999987), (-1.0,0.19999999999999987), (-1.0,0.2999999999999999), (-1.0,0.3999999999999999), (-1.0,0.4999999999999999), (-1.0,0.5999999999999999), (-1.0,0.6999999999999998), (-1.0,0.7999999999999998), (-1.0,0.8999999999999998), (-1.0,0.9999999999999998), (-0.9,-1.0), (-0.9,-0.9), (-0.9,-0.8), (-0.9,-0.7000000000000001), (-0.9,-0.6000000000000001), (-0.9,-0.5000000000000001), (-0.9,-0.40000000000000013), (-0.9,-0.30000000000000016), (-...
scala> 

scala> for ((x,y) <- grid) println(x+" "+y)
-1.0 -1.0
-1.0 -0.9
-1.0 -0.8
-1.0 -0.7000000000000001
........

scala> tuples
res30: List[(Int, Int)] = List((1,2), (3,4), (1,7), (6,5), (0,3), (1,9))

scala> for ((1,n2) <- tuples) yield n2
res32: List[Int] = List(2, 7, 9)

scala> // only matches stuff that has a 1 as the first element 

scala> val h::t = tuples
h: (Int, Int) = (1,2)
t: List[(Int, Int)] = List((3,4), (1,7), (6,5), (0,3), (1,9))

scala> val List(t1, t2, t3, t4, t5, t6) = tuples
t1: (Int, Int) = (1,2)
t2: (Int, Int) = (3,4)
t3: (Int, Int) = (1,7)
t4: (Int, Int) = (6,5)
t5: (Int, Int) = (0,3)
t6: (Int, Int) = (1,9)

scala> "1,2,3".split(",")
res35: Array[String] = Array(1, 2, 3)

scala> "1,2,3".split(",").map(_.toInt)
res36: Array[Int] = Array(1, 2, 3)

scala> val Array(a,b,c) = "1,2,3".split(",").map(_.toInt)
a: Int = 1
b: Int = 2
c: Int = 3

scala> // a very convenient way to get values out of a string.

scala> val inRange = for((x,y) <- grid; mag = math.sqrt(x*x +y*y); if mag > 0.5 && mag <1.0) yield (x,y, mag)
inRange: scala.collection.immutable.IndexedSeq[(Double, Double, Double)] = Vector((-0.9,-0.40000000000000013,0.9848857801796106), (-0.9,-0.30000000000000016,0.9
........


FOREACH:

scala> (1 to 10).foreach( i => println(i) )
1
2
3
4
5
6
7
8
9
10

scala> (1 to 10).map(i => i*i)
res41: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)

 
For loop: foreach, map, filter, flatmap (for multiple generators to get a single collection). The for loop for any type of collection (also for own types), to get the same syntactic benefits from the for loop. 

You can use a for loop on some other types too, like Options or Futures.   
 


Multidimensional for Loops:

scala> for (i <- 1 to 10) yield {
     | for (j<- 1 to 10) yield i*j
     | }
res42: scala.collection.immutable.IndexedSeq[scala.collection.immutable.IndexedSeq[Int]] = Vector(Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20), Vector(3, 6, 9, 12, 15, 18, 21, 24, 27, 30), Vector(4, 8, 12, 16, 20, 24, 28, 32, 36, 40), Vector(5, 10, 15, 20, 25, 30, 35, 40, 45, 50), Vector(6, 12, 18, 24, 30, 36, 42, 48, 54, 60), Vector(7, 14, 21, 28, 35, 42, 49, 56, 63, 70), Vector(8, 16, 24, 32, 40, 48, 56, 64, 72, 80), Vector(9, 18, 27, 36, 45, 54, 63, 72, 81, 90), Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100))

Similar to Array.fill and Array.tabulate!
To produce multidimensional collections.


Parallel for Loops:

Multiple cores of a machine. It can do multiple things at one time.
You should be doing multiple tasks at a time in order to fully utilize the power of your hardware.

- multithreading (more complex)
- par method (for loops become parallel with the par method of collections)
 
scala> (1 to 10).par
res43: scala.collection.parallel.immutable.ParRange = ParRange(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> 

scala> // Parallel for Loops

scala> 

scala> (1 to 10).par
res43: scala.collection.parallel.immutable.ParRange = ParRange(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> res43.
++                 head                         scanLeft        
+:                 headOption                   scanRight       
/:                 indexOf                      segmentLength   
:+                 indexWhere                   seq             
:\                 init                         size            
BuilderOps         intersect                    slice           
ParRangeIterator   isDefinedAt                  span            
SSCTask            isEmpty                      splitAt         
SignallingOps      isStrictSplitterCollection   splitter        
TaskOps            isTraversableAgain           startsWith      
aggregate          iterator                     stringPrefix    
apply              last                         sum             
canEqual           lastIndexOf                  tail            
collect            lastIndexWhere               take            
companion          lastOption                   takeWhile       
copyToArray        length                       tasksupport     
corresponds        map                          tasksupport_=   
count              max                          to              
debugBuffer        maxBy                        toArray         
diff               min                          toBuffer        
distinct           minBy                        toIndexedSeq    
drop               mkString                     toIterable      
dropWhile          nonEmpty                     toIterator      
endsWith           padTo                        toList          
equals             par                          toMap           
exists             partition                    toSeq           
filter             patch                        toSet           
filterNot          prefixLength                 toStream        
find               product                      toString        
flatMap            range                        toTraversable   
flatten            reduce                       toVector        
fold               reduceLeft                   transpose       
foldLeft           reduceLeftOption             union           
foldRight          reduceOption                 unzip           
forall             reduceRight                  unzip3          
foreach            reduceRightOption            updated         
genericBuilder     repr                         view            
genericCombiner    reverse                      withFilter      
groupBy            reverseMap                   zip             
hasDefiniteSize    sameElements                 zipAll          
hashCode           scan                         zipWithIndex    

scala> //  methods on ParRange like map, filter, foreach and flatmap but they will happen in parallel istead of sequentially! 

DISTRIBUTE THE WORK ACROSS MULTIPLE CORES.
If you have something that requires an intensive processing (for slow tasks).
DON'T USE A var IN PARRALEL TASKS OR IN MUTABLE TYPES LIKE ARRAYS (if you have assignments in arrays) !!!!!

PARALLEL -> USE IMMUTABLE TYPES!!!



Testing:

- use inputs that you previously know the answer: test extreme value inputs (with 0s, division by 0, cases with empty elements, more items than you firstly think of).

- test functional coverage: if we have functions, we have a test that runs every function, 

- statement coverage: is every statement executed?

-  decision and condition coverage: every decision for every condition (true and false covered?)

- loop coverage

- path coverage: we would want to have one test for every possible option in  a code. SOMETIMES IMPOSSIBLE!


Views:

- this issue relates to collections and efficiency
- there can be different efficiencies for things

scala> val nums = Array.fill(100)(math.random)
nums: Array[Double] = Array(0.9348582405438207, 0.7806144993681594, 0.49511850023224246, 0.7103288441586966, 0.9850843843950307, 0.937631980961062, 0.2701335191093954, 0.19699883889992664, 0.09443708766225722, 0.061348069594531984, 0.25000690035148343, 0.5212891710906765, 0.4476220058583912, 0.666394798634026, 0.4292083737441883, 0.9329629040871764, 0.6193671274835053, 0.7765055190768271, 0.016460652863749203, 0.859412198708654, 0.868823187188621, 0.18930331745645612, 0.2827407515713263, 0.5165469048443904, 0.344945445256833, 0.505929051717592, 0.7082171263205812, 0.18383041294618685, 0.2446349579091377, 0.2653842686804788, 0.19304577050651606, 0.663513026312617, 0.8570200638233261, 0.6416264871305056, 0.004175149075816842, 0.2029016889326728, 0.6001089344202843, 0.8108698278438302, 0.8...

Add up the squres for all of the values where the square is less than 0.25:

scala> nums.map(i=> i*i).filter(_<0.25)
res49: Array[Double] = Array(0.24514232927222507, 0.07297211814642611, 0.03880854252791925, 0.008918363526128856, 0.00376358564297554, 0.06250345022335657, 0.20036546012868958, 0.18421982809213083, 2.7095309270085485E-4, 0.035835746000019805, 0.07994233259911844, 0.11898736020343478, 0.03379362072396558, 0.05984626263120557, 0.07042881006307257, 0.037266669510454466, 1.743186980529423E-5, 0.041169095371731114, 0.07684375064875827, 0.032172294177934616, 0.024518496711789926, 0.002421934726787044, 0.12560263451789414, 0.09335865647738713, 0.09765547850878888, 1.0134171684285514E-4, 0.0822907628475321, 0.1283355551927424, 0.24613208125993596, 0.07136392917973546, 0.04680341647416697, 0.009492826791969194, 0.07837071267967248, 0.036285785026337274, 0.17000369603132906, 0.005463482886192469,...

scala> nums.map(i=> i*i).filter(_<0.25).sum
res50: Double = 3.1603968826934032

MAP CREATES A NEW ARRAY!
FILTER CREATES A NEW ARRAY!
-> in a certain way inefficient
Standard Scala collections are strict (i.e. every time we call such a method we are actually creating a new collection there on the spot).

-> we can get the same answer in a more efficient way by using views.

BY CALLING VIEW ON A COLLECTION RETURNS A NON-STRICT WRAPPER AROUND THE ORIGINAL COLLECTION, THEN MAP GIVES BACK A VIEW NOT AN ENTIRE COLLECTION. AND THEN WHEN WE CALL FILTER WE GET ANOTHER VIEW AND IT'S NOT UNTIL WE CALL SUM THAT IT DOES THE CALCULATION. 

It makes the code run faster. 



scala> nums.view.map(i=> i*i)
res52: scala.collection.SeqView[Double,Array[Double]] = SeqViewM(...)

scala> nums.view.map(i=> i*i).filter(_<0.25)
res53: scala.collection.SeqView[Double,Array[Double]] = SeqViewMF(...)

scala> nums.view.map(i=> i*i).filter(_<0.25).sum
res54: Double = 3.1603968826934032


__________________________ new REPL session __________________________
 
Files and I/O Redirection:

1) Read input for a script's function from file:

$ scala redirect.scala < fiveNums.txt

to use the 5 numbers for the script:

import io.StdIn._

val nums = Array.fil(5)(readInt)
println(nums.sum.toDouble/nums.length)


The readInt takes the input of the .txt file instead of the keyboard input. 

Also useful for putting in the test cases while testing.

2) Write output from a script to a file:

$ scala redirect.scala < fiveNums.txt > average.txt

It sends the output to the average.txt instead of the screen.

Not a solution when user input is needed!


When we would like to interact with the files directly.
The purpose of files is to store information in between runs. 



Packages and Import Statements:

- the reason of deprecation warning messages!!!!

- imports can have a scope:

	scala> {
import scala.io.Source
	}


-> you can do imports in a reduced scope if needed.

  

Reading File with io.Source:

import scala.io.Source

val source = Source.fromFile("fiveNums.txt")

You get a BufferedSource, a non-empty iterator. 
(useful for large files).

scala> source.hasNext
scala>source.next 
It returns a character, the 4 from the file. 

If you consume all the chars from the file, you then have an empty iterator! 
scala> source
res14: scala.io.BufferedSource = empty iterator

REMEMBER TO CLOSE FILES!

scala> source.close

New example:

val source2 = source.reset // it uses the same file but the file was previously altered, so it contains other numbers.

Go through the file with source2.next until it is consumed. 

Close the source with close. 

New example:

val source = Source.fromFile("fiveNums.txt")
IF YOU WANT TO READ WHOLE LINES: getLines

val lines = source.getLines
You get an Iterator of Strings.

lines.next to check it.

source.close

New script example:

import scala.io.Source

val source = Source.fromFile("fiveNums.txt")
val lines = source.getLines  // returns a bunch of Strings

val nums = lines.filter(_.nonEmpty).map(_.toInt) // filter out the empty lines 							   before transf. them to Ints

println(nums.sum)

source.close

If you don't filter empty lines out, you get a 'NumberFormatException: For input string: ""'!


!!! NOTE !!! 
BECAUSE WE DEAL WITH AN ITERATOR, AFTER GETTING THE SUM IT IS CONSUMED. IF I WANT TO USE IT MULTIPLE TIMES I HAVE TO TRANSFORM IT TO AN ARRAY OR LIST SO THAT I CAN USE IT AFTER CLOSING THE SOURCE:
-> val nums = lines.filter(_.nonEmpty).map(_.toInt).toArray

!!!! IF IT'S IN ITERATOR FORM AND YOU CLOSE THE SOURCE YOU DON'T GET TO USE IT !!!

!!! IF YOU WANT THE WHOLE DATA CONVERT IT TO AN ARRAY !!!


Files and Exceptions:

- files have their own exceptions

scala> import scala.io.Source
import scala.io.Source

scala> val source = Source.fromFile("aaa.txt")
java.io.FileNotFoundException: aaa.txt (No such file or directory)
  at java.io.FileInputStream.open0(Native Method)
  at java.io.FileInputStream.open(FileInputStream.java:195)
  at java.io.FileInputStream.<init>(FileInputStream.java:138)
  at scala.io.Source$.fromFile(Source.scala:91)
  at scala.io.Source$.fromFile(Source.scala:76)
  at scala.io.Source$.fromFile(Source.scala:54)
  ... 42 elided

  
scala> try {
     | val source = Source.fromFile("aaa.txt")
     | println(source.mkString) // turn the entire file into a string
     | } catch {
     | case ex:FileNotFoundException => println( "That file doesn't exist" )
     | }
<console>:17: error: not found: type FileNotFoundException
       case ex:FileNotFoundException => println( "That file doesn't exist" )
               ^

scala> try {
     | val source = Source.fromFile("aaa.txt")
     | println(source.mkString) // turn the entire file into a string
     | } catch {
     | case ex:java.io.FileNotFoundException =>  println( "That file doesn't exist.")
     | }
That file doesn't exist.


NOTE: the code related to source is put inside the try block (because of the scope). 
_____________

- make the code robust to type errors (if types in files are not the one expected in the code)

- so put another try/catch to deal with that

- finally keyword: something that is going to happen no matter what, before the code leaves. The reason why we need the finally is that we need to close the source.

- why you need to put finally down there for closing the source: if you have an exception not handled in the try/catch blocks this part of the code will exit without closing the source, BUT USING FINALLY CLOSES THE SOURCE WHETHER OR NOT THERE IS SUCH AN EXCEPTION. 

Script example:

import scala.io.Source
import java.io._

try {
	val source = Source.fromFile("fiveNums.txt")
	try {
		val lines = source.getLines
		val nums = lines.filter(_.nonEmpty).map(_.toInt).toArray
		println(nums.sum)
	} catch {
		case ex: NumberFormatException => println( "The file contained a non-number." )
	} finally {
		source.close
	}
	} catch {
		case ex: FileNotFoundException => println( "The file does not exist." )
}


___________

Web sources:

- reading from web sources

scala> import scala.io.Source
import scala.io.Source

scala> val source = Source.fromURL("http://www.google.com")
source: scala.io.BufferedSource = non-empty iterator

scala> println(source.mkString)
java.nio.charset.MalformedInputException: Input length = 1
  at java.nio.charset.CoderResult.throwException(CoderResult.java:281)
  at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:339)
  at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)
  at java.io.InputStreamReader.read(InputStreamReader.java:184)
  at java.io.BufferedReader.read1(BufferedReader.java:210)
  at java.io.BufferedReader.read(BufferedReader.java:286)
  at java.io.FilterReader.read(FilterReader.java:74)
  at java.io.PushbackReader.read(PushbackReader.java:128)
  at java.io.BufferedReader.read1(BufferedReader.java:210)
  at java.io.BufferedReader.read(BufferedReader.java:286)
  at java.io.Reader.read(Reader.java:140)
  at scala.io.BufferedSource.mkString(BufferedSource.scala:96)
  ... 42 elided

OK, so I get an exception.
I've found in the Scala Standard Library a good hint on fromURL method, namely, there is a method version which can take two parameters, the file name and the encoding as Strings and on stackoverflow.com another hint on how this encoding might look like. And it worked! 

scala> val source = Source.fromURL("http://www.google.com",  "iso-8859-1")
source: scala.io.BufferedSource = non-empty iterator

scala> println(source.mkString)
<!doctype html><html itemscope="" itemtype="http://schema.org/WebPage" lang="ro"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"><meta content="/images/branding/googleg/1x/googleg_standard_color_128dp.png" itemprop="image"><title>Google</title><script>(function(){window.google={kEI:'TnvgWYKjJMXVwALY2pLgAg',kEXPI:'1352261,1352821,1353383,1354277,1354401,1354690,1354915,1355220,1355324,1355782,1355800,1355820,3700307,3700440,3700476,4029815,4031109,4043492,4045841,4048347,4061945,4072775,4076999,4078430,4081038,4081164,4092183,4095910,4096463,4097153,4097922,4097929,4098721,4098728,4098752,4102238,4103475,4103845,4103861,4104258,4104414,4105786,4109316,4109490,4110656,4113217,4116724,4116731,4116926,4116935,4117328,4117980,4118103,4118227,4118798,4119272,4119740,4120414,4120660,4120727,4121035,4121806,4122092,4122354,4124091,4124174,4124411,4124850,4125837,4126203,4126276,4127473,4127555,4127657,4127744,4127775,4127891,4128381,4128586,4128874,4129520,4129555,4129633,4129796,4130559,4130782,4131247,4131834,4132254,4132263,4132314,4132589,4132702,4132987,4133090,4133113,4133229,4133245,4133416,4134054,4134271,4134480,4134488,4134724,4135090,4135300,4135925,4135968,4136133,10200083,19003860,19003861,19003866,19003868,19003870,19003872,19003874,19003875,19003879,19003880',authuser:0,kscs:'c9c918f0_TnvgWYKjJMXVwALY2pLgAg',u:'c9c918f0',kGL:'RO'};google.kHL='ro';})();(function(){google.lc=[];google.li=0;google.getEI=function(a){for(var b;a&&(!a.getAttribute||!(b=a.getAttribute("eid")));)a=a.parentNode;return b||google.kEI};google.getLEI=function(a){for(var b=null;a&&(!a.getAttribute||!(b=a.getAttribute("leid")));)a=a.parentNode;return b};google.https=function(){return"https:"==window.location.protocol};google.ml=function(){return null};google.wl=function(a,b){try{google.ml(Error(a),!1,b)}catch(d){}};google.time=function(){return(new Date).getTime()};google.log=function(a,b,d,c,g){if(a=google.logUrl(a,b,d,c,g)){b=new Image;var e=google.lc,f=google.li;e[f]=b;b.onerror=b.onload=b.onabort=function(){delete e[f]};google.vel&&google.vel.lu&&google.vel.lu(a);b.src=a;google.li=f+1}};google.logUrl=function(a,b,d,c,g){var e="",f=google.ls||"";d||-1!=b.search("&ei=")||(e="&ei="+google.getEI(c),-1==b.search("&lei=")&&(c=google.getLEI(c))&&(e+="&lei="+c));c="";!d&&google.cshid&&-1==b.search("&cshid=")&&(c="&cshid="+google.cshid);a=d||"/"+(g||"gen_204")+"?atyp=i&ct="+a+"&cad="+b+e+f+"&zx="+google.time()+c;/^http:/i.test(a)&&google.https()&&(google.ml(Error("a"),!1,{src:a,glmm:1}),a="");return a};}).call(this);(function(){google.y={};google.x=function(a,b){if(a)var c=a.id;else{do c=Math.random();while(google.y[c])}google.y[c]=[a,b];return!1};google.lm=[];google.plm=function(a){google.lm.push.apply(google.lm,a)};google.lq=[];google.load=function(a,b,c){google.lq.push([[a],b,c])};google.loadAll=function(a,b){google.lq.push([a,b])};}).call(this);google.f={};var a=window.location,b=a.href.indexOf("#");if(0<=b){var c=a.href.substring(b+1);/(^|&)q=/.test(c)&&-1==c.indexOf("#")&&a.replace("/search?"+c.replace(/(^|&)fp=[^&]*/g,"")+"&cad=h")};</script><style>#gbar,#guser{font-size:13px;padding-top:1px !important;}#gbar{height:22px}#guser{padding-bottom:7px !important;text-align:right}.gbh,.gbd{border-top:1px solid #c9d7f1;font-size:1px}.gbh{height:0;position:absolute;top:24px;width:100%}@media all{.gb1{height:22px;margin-right:.5em;vertical-align:top}#gbar{float:left}}a.gb1,a.gb4{text-decoration:underline !important}a.gb1,a.gb4{color:#00c !important}.gbi .gb4{color:#dd8e27 !important}.gbf .gb4{color:#900 !important}
</style><style>body,td,a,p,.h{font-family:arial,sans-serif}body{margin:0;overflow-y:scroll}#gog{padding:3px 8px 0}td{line-height:.8em}.gac_m td{line-height:17px}form{margin-bottom:20px}.h{color:#36c}.q{color:#00c}.ts td{padding:0}.ts{border-collapse:collapse}em{font-weight:bold;font-style:normal}.lst{height:25px;width:496px}.gsfi,.lst{font:18px arial,sans-serif}.gsfs{font:17px arial,sans-serif}.ds{display:inline-box;display:inline-block;margin:3px 0 4px;margin-left:4px}input{font-family:inherit}a.gb1,a.gb2,a.gb3,a.gb4{color:#11c !important}body{background:#fff;color:black}a{color:#11c;text-decoration:none}a:hover,a:active{text-decoration:underline}.fl a{color:#36c}a:visited{color:#551a8b}a.gb1,a.gb4{text-decoration:underline}a.gb3:hover{text-decoration:none}#ghead a.gb2:hover{color:#fff !important}.sblc{padding-top:5px}.sblc a{display:block;margin:2px 0;margin-left:13px;font-size:11px}.lsbb{background:#eee;border:solid 1px;border-color:#ccc #999 #999 #ccc;height:30px}.lsbb{display:block}.ftl,#fll a{display:inline-block;margin:0 12px}.lsb{background:url(/images/nav_logo229.png) 0 -261px repeat-x;border:none;color:#000;cursor:pointer;height:30px;margin:0;outline:0;font:15px arial,sans-serif;vertical-align:top}.lsb:active{background:#ccc}.lst:focus{outline:none}.tiah{width:458px}</style><script></script><link href="/images/branding/product/ico/googleg_lodp.ico" rel="shortcut icon"></head><body bgcolor="#fff"><script>(function(){var src='/images/nav_logo229.png';var iesg=false;document.body.onload = function(){window.n && window.n();if (document.images){new Image().src=src;}
if (!iesg){document.f&&document.f.q.focus();document.gbqf&&document.gbqf.q.focus();}
}
})();</script><div id="mngb"> <div id=gbar><nobr><b class=gb1>Cutare</b> <a class=gb1 href="http://www.google.ro/imghp?hl=ro&tab=wi">Imagini</a> <a class=gb1 href="http://maps.google.ro/maps?hl=ro&tab=wl">Hr&#539;i</a> <a class=gb1 href="http://www.youtube.com/?gl=RO&tab=w1">YouTube</a> <a class=gb1 href="http://news.google.ro/nwshp?hl=ro&tab=wn">&#536;tiri</a> <a class=gb1 href="https://mail.google.com/mail/?tab=wm">Gmail</a> <a class=gb1 href="https://drive.google.com/?tab=wo">Drive</a> <a class=gb1 href="https://www.google.com/calendar?tab=wc">Calendar</a> <a class=gb1 style="text-decoration:none" href="https://www.google.ro/intl/ro/options/"><u>Mai multe</u> &raquo;</a></nobr></div><div id=guser width=100%><nobr><span id=gbn class=gbi></span><span id=gbf class=gbf></span><span id=gbe></span><a href="http://www.google.ro/history/optout?hl=ro" class=gb4>Istoric Web</a> | <a  href="/preferences?hl=ro" class=gb4>Setri</a> | <a target=_top id=gb_70 href="https://accounts.google.com/ServiceLogin?hl=ro&passive=true&continue=http://www.google.ro/%3Fgws_rd%3Dcr%26dcr%3D0%26ei%3DTnvgWeLTHs3NwQLU2JHQAg" class=gb4>Conecta&#539;i-v</a></nobr></div><div class=gbh style=left:0></div><div class=gbh style=right:0></div> </div><center><br clear="all" id="lgpd"><div id="lga"><div style="padding:28px 0 3px"><div style="height:110px;width:276px;background:url(/images/branding/googlelogo/1x/googlelogo_white_background_color_272x92dp.png) no-repeat" title="Google" align="left" id="hplogo" onload="window.lol&&lol()"><div style="color:#777;font-size:16px;font-weight:bold;position:relative;top:70px;left:218px" nowrap="">Romnia</div></div></div><br></div><form action="/search" name="f"><table cellpadding="0" cellspacing="0"><tr valign="top"><td width="25%">&nbsp;</td><td align="center" nowrap=""><input name="ie" value="ISO-8859-2" type="hidden"><input value="ro" name="hl" type="hidden"><input name="source" type="hidden" value="hp"><input name="biw" type="hidden"><input name="bih" type="hidden"><div class="ds" style="height:32px;margin:4px 0"><div style="position:relative;zoom:1"><input style="color:#000;margin:0;padding:5px 8px 0 6px;vertical-align:top;padding-right:38px" autocomplete="off" class="lst tiah" value="" title="Cutare Google" maxlength="2048" name="q" size="57"><img src="/textinputassistant/tia.png" style="position:absolute;cursor:pointer;right:5px;top:4px;z-index:300" onclick="(function(){var src='/textinputassistant/11/ro_tia.js';var s=document.createElement('script');s.src=src;google.dom.append(s);})();" alt="" height="23" width="27"></div></div><br style="line-height:0"><span class="ds"><span class="lsbb"><input class="lsb" value="Cutare Google" name="btnG" type="submit"></span></span><span class="ds"><span class="lsbb"><input class="lsb" value="M simt norocos" name="btnI" onclick="if(this.form.q.value)this.checked=1; else top.location='/doodles/'" type="submit"></span></span></td><td class="fl sblc" align="left" nowrap="" width="25%"><a href="/advanced_search?hl=ro&amp;authuser=0">Cutare avansat</a><a href="/language_tools?hl=ro&amp;authuser=0">Google Unelte lingvistice</a></td></tr></table><input id="gbv" name="gbv" type="hidden" value="1"></form><div id="gac_scont"></div><div style="font-size:83%;min-height:3.5em"><br><div id="als"><style>#als{font-size:small;margin-bottom:24px}#_eEe{display:inline-block;line-height:28px;}#_eEe a{padding:0 3px;}._lEe{display:inline-block;margin:0 2px;white-space:nowrap}._PEe{display:inline-block;margin:0 2px}</style><div id="_eEe">Google.ro oferit n: <a href="/url?q=http://www.google.ro/setprefs%3Fsig%3D0_9DbJpHMvmtxQTEsyioq5ZbIx0Ew%253D%26hl%3Dhu%26source%3Dhomepage&amp;sa=U&amp;ved=0ahUKEwiCgpCMme3WAhXFKlAKHVitBCwQ2ZgBCAU&amp;usg=AOvVaw0eoxsBnwMyDMfllm74rSCD">magyar</a>  <a href="/url?q=http://www.google.ro/setprefs%3Fsig%3D0_9DbJpHMvmtxQTEsyioq5ZbIx0Ew%253D%26hl%3Dde%26source%3Dhomepage&amp;sa=U&amp;ved=0ahUKEwiCgpCMme3WAhXFKlAKHVitBCwQ2ZgBCAY&amp;usg=AOvVaw2VmWr9S4ewSmGxf24aRaIi">Deutsch</a> </div></div></div><span id="footer"><div style="font-size:10pt"><div style="margin:19px auto;text-align:center" id="fll"><a href="/intl/ro/ads/">Programe de publicitate</a><a href="http://www.google.ro/intl/ro/services/">Soluii de afaceri</a><a href="/intl/ro/about.html">Totul despre Google</a><a href="http://www.google.ro/setprefdomain?prefdom=US&amp;sig=__frUQ1loHCUaw22DN9FI-8eI_sTk%3D" id="fehl">Google.com</a></div></div><p style="color:#767676;font-size:8pt">&copy; 2017 - <a href="/intl/ro/policies/privacy/">Confiden&#539;ialitate</a> - <a href="/intl/ro/policies/terms/">Termeni</a></p></span></center><script>(function(){window.google.cdo={height:0,width:0};(function(){var a=window.innerWidth,b=window.innerHeight;if(!a||!b){var c=window.document,d="CSS1Compat"==c.compatMode?c.documentElement:c.body;a=d.clientWidth;b=d.clientHeight}a&&b&&(a!=google.cdo.width||b!=google.cdo.height)&&google.log("","","/client_204?&atyp=i&biw="+a+"&bih="+b+"&ei="+google.kEI);}).call(this);})();</script><div id="xjsd"></div><div id="xjsi"><script>(function(){function c(b){window.setTimeout(function(){var a=document.createElement("script");a.src=b;google.timers&&google.timers.load.t&&google.tick("load",{gen204:"xjsls",clearcut:31});document.getElementById("xjsd").appendChild(a)},0)}google.dljp=function(b,a){google.xjsu=b;c(a)};google.dlj=c;}).call(this);(function(){var r=[];google.plm(r);})();if(!google.xjs){window._=window._||{};window._DumpException=window._._DumpException=function(e){throw e};google.dljp('/xjs/_/js/k\x3dxjs.hp.en_US.Fx_Gdoc7q1A.O/m\x3dsb_he,d/am\x3dADA/rt\x3dj/d\x3d1/t\x3dzcms/rs\x3dACT90oFatZnhkFX_Z5Z8rIdRTxa4192e7A','/xjs/_/js/k\x3dxjs.hp.en_US.Fx_Gdoc7q1A.O/m\x3dsb_he,d/am\x3dADA/rt\x3dj/d\x3d1/t\x3dzcms/rs\x3dACT90oFatZnhkFX_Z5Z8rIdRTxa4192e7A');google.xjs=1;}google.pmc={"sb_he":{"agen":false,"cgen":false,"client":"heirloom-hp","dh":true,"dhqt":true,"ds":"","fl":true,"host":"google.ro","isbh":28,"jam":0,"jsonp":true,"msgs":{"cibl":"&#536;terge&#539;i cutarea","dym":"A&#539;i dorit s scrie&#539;i:","lcky":"M simt norocos","lml":"Afla&#539;i mai multe","oskt":"Instrumente pentru introducere de text","psrc":"Aceast cutare a fost eliminat din \u003Ca href=\"/history\"\u003EIstoricul dvs. Web\u003C/a\u003E","psrl":"Elimina&#539;i","sbit":"Cuta&#539;i dup imagine","srch":"Cutare Google"},"nds":true,"ovr":{},"pq":"","refpd":true,"rfs":[],"sbpl":24,"sbpr":24,"scd":10,"sce":5,"stok":"rfRupoOffwnI-u_aTHOiH56XaoQ"},"d":{},"aWiv7g":{},"YFCs/g":{}};google.x(null,function(){});</script></div></body></html>

scala> source.getLines
res5: Iterator[String] = empty iterator

scala> // ok it is empty after println.

scala> source.close

scala> val source = Source.fromURL("http://www.google.com",  "iso-8859-1")
source: scala.io.BufferedSource = non-empty iterator

scala> val lines = source.getLines.toString
lines: String = non-empty iterator

scala> lines(1)
res7: Char = o

scala> lines(0)
res8: Char = n

scala> source.close

scala> lines.
*                     groupBy               scanLeft        
+                     grouped               scanRight       
++                    hasDefiniteSize       segmentLength   
++:                   hashCode              self            
+:                    head                  seq             
/:                    headOption            size            
:+                    indexOf               slice           
:\                    indexOfSlice          sliding         
<                     indexWhere            sortBy          
<=                    indices               sortWith        
>                     init                  sorted          
>=                    inits                 span            
addString             intern                split           
aggregate             intersect             splitAt         
andThen               isDefinedAt           startsWith      
apply                 isEmpty               stringPrefix    
applyOrElse           isTraversableAgain    stripLineEnd    
canEqual              iterator              stripMargin     
capitalize            last                  stripPrefix     
charAt                lastIndexOf           stripSuffix     
chars                 lastIndexOfSlice      subSequence     
codePointAt           lastIndexWhere        substring       
codePointBefore       lastOption            sum             
codePointCount        length                tail            
codePoints            lengthCompare         tails           
collect               lift                  take            
collectFirst          lines                 takeRight       
combinations          linesIterator         takeWhile       
companion             linesWithSeparators   to              
compare               map                   toArray         
compareTo             matches               toBoolean       
compareToIgnoreCase   max                   toBuffer        
compose               maxBy                 toByte          
concat                min                   toCharArray     
contains              minBy                 toDouble        
containsSlice         mkString              toFloat         
contentEquals         nonEmpty              toIndexedSeq    
copyToArray           offsetByCodePoints    toInt           
copyToBuffer          orElse                toIterable      
corresponds           padTo                 toIterator      
count                 par                   toList          
diff                  partition             toLong          
distinct              patch                 toLowerCase     
drop                  permutations          toMap           
dropRight             prefixLength          toSeq           
dropWhile             product               toSet           
endsWith              r                     toShort         
equals                reduce                toStream        
equalsIgnoreCase      reduceLeft            toString        
exists                reduceLeftOption      toTraversable   
filter                reduceOption          toUpperCase     
filterNot             reduceRight           toVector        
find                  reduceRightOption     transpose       
flatMap               regionMatches         trim            
flatten               replace               union           
fold                  replaceAll            unzip           
foldLeft              replaceAllLiterally   unzip3          
foldRight             replaceFirst          updated         
forall                repr                  view            
foreach               reverse               withFilter      
format                reverseIterator       zip             
formatLocal           reverseMap            zipAll          
genericBuilder        runWith               zipWithIndex    
getBytes              sameElements                          
getChars              scan                                  


!!! You can call getLines if you want to process one line at the time, and because they are iterators you can call methods like map and filter and do all the processing as with data from files !!! 


scala> val source = Source.fromURL("http://www.google.com",  "iso-8859-1")
source: scala.io.BufferedSource = non-empty iterator

scala> val data = source.getLines.toArray
data: Array[String] = Array(<!doctype html><html itemscope="" itemtype="http://schema.org/WebPage" lang="ro"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"><meta content="/images/branding/googleg/1x/googleg_standard_color_128dp.png" itemprop="image"><title>Google</title><script>(function(){window.google={kEI:'ooHgWbqQB8PbwQKd1qaIAw',kEXPI:'1353382,1354276,1354403,1354915,1355218,1355325,1355800,1355820,1355892,3700253,3700440,3700476,4029815,4031109,4041302,4043492,4045841,4048347,4072775,4076999,4078430,4081039,4081164,4092182,4095910,4097153,4097469,4097922,4097929,4098733,4098740,4098752,4100140,4102238,4103209,4103475,4103861,4104258,4104414,4105241,4109316,4109490,4110656,4112163,4113217,4116244,4116724,4116731,4116926,4116935,4117328,4117539,4117980,41181...
scala> data(0)
res16: String = <!doctype html><html itemscope="" itemtype="http://schema.org/WebPage" lang="ro"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"><meta content="/images/branding/googleg/1x/googleg_standard_color_128dp.png" itemprop="image"><title>Google</title><script>(function(){window.google={kEI:'ooHgWbqQB8PbwQKd1qaIAw',kEXPI:'1353382,1354276,1354403,1354915,1355218,1355325,1355800,1355820,1355892,3700253,3700440,3700476,4029815,4031109,4041302,4043492,4045841,4048347,4072775,4076999,4078430,4081039,4081164,4092182,4095910,4097153,4097469,4097922,4097929,4098733,4098740,4098752,4100140,4102238,4103209,4103475,4103861,4104258,4104414,4105241,4109316,4109490,4110656,4112163,4113217,4116244,4116724,4116731,4116926,4116935,4117328,4117539,4117980,4118102,4118226,4...

scala> val splited = data.map(i => i.split(","))
splited: Array[Array[String]] = Array(Array(<!doctype html><html itemscope="" itemtype="http://schema.org/WebPage" lang="ro"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"><meta content="/images/branding/googleg/1x/googleg_standard_color_128dp.png" itemprop="image"><title>Google</title><script>(function(){window.google={kEI:'ooHgWbqQB8PbwQKd1qaIAw', kEXPI:'1353382, 1354276, 1354403, 1354915, 1355218, 1355325, 1355800, 1355820, 1355892, 3700253, 3700440, 3700476, 4029815, 4031109, 4041302, 4043492, 4045841, 4048347, 4072775, 4076999, 4078430, 4081039, 4081164, 4092182, 4095910, 4097153, 4097469, 4097922, 4097929, 4098733, 4098740, 4098752, 4100140, 4102238, 4103209, 4103475, 4103861, 4104258, 4104414, 4105241, 4109316, 4109490, 4110656, 4112163, 4113217, 4116244...

scala> splited(0).length
res26: Int = 166

scala> val splited2 = data.flatMap(i => i.split(","))
splited2: Array[String] = Array(<!doctype html><html itemscope="" itemtype="http://schema.org/WebPage" lang="ro"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"><meta content="/images/branding/googleg/1x/googleg_standard_color_128dp.png" itemprop="image"><title>Google</title><script>(function(){window.google={kEI:'ooHgWbqQB8PbwQKd1qaIAw', kEXPI:'1353382, 1354276, 1354403, 1354915, 1355218, 1355325, 1355800, 1355820, 1355892, 3700253, 3700440, 3700476, 4029815, 4031109, 4041302, 4043492, 4045841, 4048347, 4072775, 4076999, 4078430, 4081039, 4081164, 4092182, 4095910, 4097153, 4097469, 4097922, 4097929, 4098733, 4098740, 4098752, 4100140, 4102238, 4103209, 4103475, 4103861, 4104258, 4104414, 4105241, 4109316, 4109490, 4110656, 4112163, 4113217, 4116244, 4116724, 4...
scala> splited2.length
res27: Int = 230

scala> data.length
res29: Int = 5


scala> source.close


scala> def countSplittedArray( a: Array[String], startIndex:Int, base: Int) :Int = {
     | val splitted = a.map(i=> i.split(","))
     | if (startIndex == 0) base
     | else base + countSplittedArray( splitted(startIndex -1), startIndex-1, splitted(startIndex-1).length)
     | }
countSplittedArray: (a: Array[String], startIndex: Int, base: Int)Int

scala> val arr = Array( "there you go", "this is weird")
arr: Array[String] = Array(there you go, this is weird)

scala> arr.length
res45: Int = 2

scala> val splitted = arr.map( i => i.split(","))
splitted: Array[Array[String]] = Array(Array(there you go), Array(this is weird))

scala> splitted(0).length
res46: Int = 1

scala> splitted(1).length
res47: Int = 1

scala> countSplittedArray(arr, arr.length, 0)
res51: Int = 2

:reset

scala> val arr = Array(1,1,1,0,1,1,0,0,1,1,0,1,1,1,0,1,1,0,1,0,0)
arr: Array[Int] = Array(1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0)

scala> arr.count(_ == 0)
res0: Int = 8

scala> arr.count(_ == 1)
res1: Int = 13

scala> def countOnes (a: Array[Int], index: Int, acc:Int) : Int = {
     | if (index == 0) acc
     | else countOnes(a, index -1, {if (a(index-1) == 0) acc else acc+1})
     | }
countOnes: (a: Array[Int], index: Int, acc: Int)Int

scala> countOnes(arr, arr.length, 0)
res17: Int = 13




___________

   
Writing to File:

- to write we use java.io.PrintWriter

scala> import java.io.PrintWriter
import java.io.PrintWriter

scala> val pw = new PrintWriter("file.txt")
pw: java.io.PrintWriter = java.io.PrintWriter@1850688b

scala> Array(1,2,3,4,5).foreach(i=> pw.println(i))

scala> pw.close

scala> // you have to close the file. 

scala> // NOTE: IF THE FILE ALREADY EXISTS pw WILL OVERWRITE IT!!! 

scala> // if you want to append: use java.io.FileWriter

scala> import java.io.FileWriter
import java.io.FileWriter

scala> val pw = new PrintWriter(new FileWriter("file.txt", true)) 
pw: java.io.PrintWriter = java.io.PrintWriter@541eeebd

// true ->appends, false -> erases

scala> pw.println("Goes after original contents.")

scala> pw.close

_______________

Formatted Output

- create formatted output
- for printing to the terminal or printing to a file

printf("A string")
A string

printf("A string \n")
A string


printf("A string %d\n", 42) //the % sign indicates a variable comes in there, you need to have a second argument for the variable
A string 42

printf("A string %5d\n", 42)
A string     42

printf("A string %f\n", 4.2) // %f for floating point
A string 4.2000000


printf("A string %5f\n, 4.2) // %5f we want 5 digits after the 4.2
A string 4.200000


printf("A string %5.2f\n", 4.2) // %5.2f for 2 digits after the decimal point, but takes 5 characters when we print it
A string  4.20

scala> printf("A string %5.2f\n", 4.2e10)
A string 42000000000.00

scala> printf("A string %5.2e\n" ,4.2e10) // e switches to scientific notation
A string 4.20e+10

______

File Example

- args is an Array of the arguments that were passed in. 


______

Case Classes

- give us the ability to group features together and are the first way which allows to define your own types. 

- you can create your own types, add functionality to these types

- example: use tuples to group things together that are of different types.

scala> val (name, age, abi) = ("roxi", 19, 2.4)
name: String = roxi
age: Int = 19
abi: Double = 2.4

scala> // all tuples with the same types in them are considered equivalent

scala> type Point = (Double, Double, Double)
defined type alias Point

scala> type Color = (Double, Double, Double)
defined type alias Color

scala> def mag(p:Point) :Double = math.sqrt(p._1*p._1 + p._2*p._2 + p._3*p._3)
mag: (p: Point)Double

scala> val p1 = (1.0, 2.0, 4.0)
p1: (Double, Double, Double) = (1.0,2.0,4.0)

scala> mag(p1)
res2: Double = 4.58257569495584


scala> // but no distinction betw. points and colors in this way!


Creating Case Classes


scala> import io.StdIn._
import io.StdIn._

scala> case class Point3D(x: Double, y: Double, z: Double)
defined class Point3D

scala> case class Student(name: String, tests:List[Int], assns:List[Int], quizzes: List[Int])
defined class Student

scala> Point3D(1.0,2.0,3.0)
res0: Point3D = Point3D(1.0,2.0,3.0)

scala> Student("Roxi", List(90, 80), List(100, 95), List(96, 84, 72)
     | )
res1: Student = Student(Roxi,List(90, 80),List(100, 95),List(96, 84, 72))

// making individual instances of classes (instantiating them)


Using Case Classes

scala> res0.x	// getting values out of a clase class using the fields that we want to pull out
res2: Double = 1.0

scala> res0.y
res3: Double = 2.0

scala> res0.z
res4: Double = 3.0

Write some simple functions that take the class:

scala> def distance(p1:Point3D, p2:Point3D):Double = {
     | val dx = p1.x - p2.x
     | val dy = p1.y - p2.y
     | val dz = p1.z - p2.z
     | math.sqrt(dx*dx + dy*dy + dz*dz)
     | }
distance: (p1: Point3D, p2: Point3D)Double

scala> distance(Point3D(5,2,1), Point3D(7,1,7))
res5: Double = 6.4031242374328485

scala> res1
res6: Student = Student(Roxi,List(90, 80),List(100, 95),List(96, 84, 72))

scala> classAverage(res6)
res7: Double = 91.15

______


!!! NOTE: THE VALUES IN THE CASE CLASSES INSTANCES ARE VALS !!!
IF I WANT TO CHANGE THE NAME OF THE STUDENT I CAN'T BECAUSE IT IS REASSIGNMENT TO VAL !!!

!!! BY DEFAULT CASE CLASSES ARE IMMUTABLE AS LONG AS THE THINGS IN THEM ARE IMMUTABLE !!! LISTS ARE IMMUTABLE; IF YOU USE ARRAYS I AM ABLE TO MUTATE THE VALUES INSIDE OF THE ARRAYS BUT NOT THE LENGTH OF THE ARRAYS!!! 

scala> val stu = Student("Roxi", List(90, 80), List(100, 95), List(96, 84, 72))
stu: Student = Student(Roxi,List(90, 80),List(100, 95),List(96, 84, 72))

scala> stu.name 
res0: String = Roxi

scala> stu.name = "John"
<console>:12: error: reassignment to val
       stu.name = "John"
     
           ^
_____

Named and Default Arguments

scala> def evalQuad(a: Double, b: Double, c: Double, x: Double) : Double = {
     | a*x*x + b*x + c
     | }
evalQuad: (a: Double, b: Double, c: Double, x: Double)Double

scala> evalQuad(1, 0, 0, 2)
res1: Double = 4.0

I can also NAME my arguments.  


scala> evalQuad( x=2, a=1, b=0, c=0)
res2: Double = 4.0

!!! NOTE: WE CAN PROVIDE DEFAULT VALUES FOR ARGUMENTS !!!

SPECIFY DEFAULT VALUES IN THE FUNCTION PARAMETERS:

scala> def evalQuad(a:Double = 0, b:Double = 1, c:Double =0, x:Double) : Double ={
     | a*x*x + b*x + c 
     | }
evalQuad: (a: Double, b: Double, c: Double, x: Double)Double

scala> evalQuad(x=4)
res4: Double = 4.0

scala> // even if you have default values you can specify different values for the default parameters:

scala> evalQuad(x=4, a=2) // uses default values for b and c and the named params for x and a
res5: Double = 36.0



The copy Method in Case Classes

- because of the immutability in case classes -> we cannot assign to members (fields) of a case class
- what if we want to change something? -> all case classes have a copy method.

scala> stu.
assns      equals     productArity      productPrefix   toString   
canEqual   hashCode   productElement    quizzes                    
copy       name       productIterator   tests                      

scala> case class Point3D(x: Double, y: Double, z: Double)
defined class Point3D

scala> val p = Point3D(1,2,3)
p: Point3D = Point3D(1.0,2.0,3.0)

scala> p.
canEqual   equals     productArity     productIterator   toString   y   
copy       hashCode   productElement   productPrefix     x          z   

scala> // make a new point:

scala> Point3D(1+p.x, p.y, p.z)
res6: Point3D = Point3D(2.0,2.0,3.0)

scala> p.copy(x = p.x +1)	// TO THE COPY METH. YOU PASS ONLY NAMED PARAMS.
res7: Point3D = Point3D(2.0,2.0,3.0)

scala> // WITH THE COPY METHOD IF I DON'T SPECIFY THE PARAMETERS THEY GET THE DEFAULT VALUES!!! 

!!!! SPECIFY ONLY THE THINGS I WANT TO CHANGE IN THE COPY METHOD !!!!
!!! THE REST OF THE STUFF WILL TAKE THE DEFAULT VALUES !!!

	
scala> val stu2 = Student ("Me", Nil, Nil, Nil)
stu2: Student = Student(Me,List(),List(),List())

scala> stu2.copy(tests = 99::stu.tests)
res8: Student = Student(Me,List(99, 90, 80),List(),List())

scala> stu
res9: Student = Student(Roxi,List(90, 80),List(100, 95),List(96, 84, 72))

scala> stu2.copy( assns = 89::stu2.assns )
res10: Student = Student(Me,List(),List(89),List())


SO THE COPY METHOD IS VERY HELPFUL AS IT GIVES AS THE WAY TO CREATE MODIFIED VERSIONS OF IMMUTABLE CASE CLASSES. 


Case class Patterns

- use case classes as patterns

scala> val points = Array.fill(20)(Point3D(math.random, math.random, math.random))
points: Array[Point3D] = Array(Point3D(0.9315241287287708,0.07718714222090839,0.15064727839716063), Point3D(0.48907011960045943,0.5131324347669253,0.3180524381310157), Point3D(0.5870943031245458,0.8941519246426349,0.19123143686193045), Point3D(0.10142071815034426,0.865368028087878,0.8696370647907797), Point3D(0.5237716174338423,0.23291686295481373,0.16901377966925224), Point3D(0.7038944512732811,0.3156439358325107,0.7688109936492333), Point3D(0.8523724815823078,0.9786385641034974,0.05744042440778663), Point3D(0.7506988168610095,0.30114625608359513,0.41368129074096205), Point3D(0.1269913704801262,0.7392208010515394,0.23159788920276847), Point3D(0.6710775553142501,0.7745831802482952,0.8574222095835569), Point3D(0.18219897311639421,0.034832427471294336,0.4801445833657585), Point3D(0.129550...
 
// You fill the Array with instances of Point3D(x,y,z)!


scala> points(0)
res11: Point3D = Point3D(0.9315241287287708,0.07718714222090839,0.15064727839716063)

scala> points(1)
res12: Point3D = Point3D(0.48907011960045943,0.5131324347669253,0.3180524381310157)

scala> for (Point3D(x,y,z) <- points) yield math.sqrt(x*x + y*y + z*z)
res13: Array[Double] = Array(0.9467785695803417, 0.7769503400455682, 1.0866263605985742, 1.2310225873495404, 0.5976224811668829, 1.0891137850183852, 1.2990656984408, 0.9084987570155472, 0.7849915815898143, 1.3362249188880075, 0.5147315657152661, 0.9831203117423695, 1.0317893898095745, 1.1419518828812365, 1.0337443836115974, 0.6507132721188713, 1.1743108964618425, 1.1061735191010567, 0.8762554863163657, 1.095823537820368)

scala> // a convenient way to unpackage the fields of a case class.


scala> for (Point3D(x, y , z) <- points)  yield (x>0.3)
res19: Array[Boolean] = Array(true, true, true, false, true, true, true, true, false, true, false, false, true, true, true, false, true, false, true, true)

scala> for (Point3D(x, _ , _) <- points)  yield (x>0.3)
res20: Array[Boolean] = Array(true, true, true, false, true, true, true, true, false, true, false, false, true, true, true, false, true, false, true, true)

scala> for (Point3D(x , y , z) <- points) yield {if(x>0.3 == true)  x}
res24: Array[AnyVal] = Array(0.9315241287287708, 0.48907011960045943, 0.5870943031245458, (), 0.5237716174338423, 0.7038944512732811, 0.8523724815823078, 0.7506988168610095, (), 0.6710775553142501, (), (), 0.7443213979748029, 0.7748429495816722, 0.5835984608376867, (), 0.35355425586138556, (), 0.3767868733664821, 0.7136417783309138)
 
scala> for (Point3D(x,y,z) <- points) if (x>0.3 == true)  println (x)
0.9315241287287708
0.48907011960045943
0.5870943031245458
0.5237716174338423
0.7038944512732811
0.8523724815823078
0.7506988168610095
0.6710775553142501
0.7443213979748029
0.7748429495816722
0.5835984608376867
0.35355425586138556
0.3767868733664821
0.7136417783309138





 


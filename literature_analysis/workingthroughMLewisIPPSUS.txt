Working through "Introduction to Programming and Problem Solving Using Scala" of Mark Lewis
https://www.youtube.com/playlist?list=PLLMXbkbDbVt9MIJ9DV4ps-_trOzWtphYO


scala> val age = 34
age: Int = 34

scala> val response = if (age >=18) "Come in" else "Get lost"
response: String = Come in

scala> //an expression returns a value

scala> var response2 = " "
response2: String = " "

scala> if (age >= 18) {
     | response2 = "come in"
     | } else {
     | response2 = "get lost"
     | }

scala> response2
res1: String = come in

scala> // a statement returns a reassigned var or the return of a println call

scala> // a statement makes something happen (like a side effect), whereas an expression returns a value which we can use later.

scala> if (age >= 18) {
     | println ("come in")
     | } else {
     | println ("get lost")
     | }
come in

scala> // Code blocks

scala> // code blocks are expressions and they have the value of the last thing that is in them

scala> {
     | println ("Giving back the 6")
     | 6
     | }
Giving back the 6
res3: Int = 6

scala> import scala.io.StdIn._
import scala.io.StdIn._

scala> println("How old are you?")
How old are you?

scala> val age = readInt
age: Int = 34

scala> val response = if (age >= 18) {
     | "old enough"
     | } else {
     | println ("too young")
     | "for too much coffee"
     | }
response: String = old enough

scala> // if and code blocks are used together if you want an output and a value 

scala> // this is because you can have only one expression inside the true or false parts.

scala> 

scala> //Comparison operators

scala> // ==     != (bang equal)   CHECK FOR EQUALITY

scala> // CHECK FOR IDENTITY: are the two objects the same object?

scala> // you use: s1 eq s2 instead of ==

scala> 

scala> 

scala> //Boolean logic

scala> // && AND     || INCLUSIVE OR     ^ EXCLUSIVE OR

scala> // ! NOT

scala> val age = readInt
age: Int = 19

scala> // val cost = 8 OR 12 based upon age

scala> val cost = if (age < 13 || age >=55) 8 else 12
cost: Int = 12

scala> val cost2 = if (age >= 13 && age < 55) 12 else 8
cost2: Int = 12

scala> // && and || are short-circuit operations

scala> // for && is the first is true it continues evaluating and if it's false it stops evaluating

scala> // for || if the first is false it continues evaluating

scala> // SHORT-CIRCUIT MEANS THAT IF THE VALUE CAN BE DETERMINED FROM THE FIRST PART WE WON'T EVALUATE THE SECOND ONE.

scala> val n = 2
n: Int = 2

scala> val d = 0
d: Int = 0

scala> val frac = n/d > 10
java.lang.ArithmeticException: / by zero
  ... 33 elided

scala> val frac = d>0 && n/d>10
frac: Boolean = false

scala> // we don't get the exception anymore

scala> // because if the first part is false, the second part never gets evaluated 

scala> 

scala> 

scala> // Operator precedence

scala> // * / %, + -, :, = !, < >, &, ^, |

scala> // other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment

scala> val operatorPrecendece = "// other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment"
operatorPrecendece: String = // other symbols,  * / %, + -, :, = !, < >, &, ^, |, letter, assignment

scala> 

scala> 

scala> // Nesting ifs

scala> val order = readline
<console>:10: error: not found: value readline
       val order = readline
                   ^

scala> val order = readLine
order: String = drink

scala> val size = readLine
size: String = s

scala> val price = if (order == "food") {
     | if (size.toLowerCase.startsWith("s")) {
     | 1.0
     | } else if (size.toLowerCase.startsWith("m")) {
     | 1.5
     | } else if (size.toLowerCase.startsWith("l")) {
     | 2.0
     | }
     | } else if (order == "drink") { 
     | if (size.toLowerCase.startsWith("s")) {
     | 0.5
     | } else if (size.toLowerCase.startsWith("m")) {
     | 0.7
     | } else if (size.toLowerCase.startsWith("l")) {
     | 0.9
     | }
     | } else if (order == "combo") {
     | if (size.toLowerCase.startsWith("s")) {
     | 1.5
     | } else if (size.toLowerCase.startsWith("m")) {
     | 2.5
     | } else if (size.toLowerCase.startsWith("l")) {
     | 3.0
     | }
     | }
price: AnyVal = 0.5

scala> \\ great comments on Unit and AnyVal types! 
     | 
     | 
You typed two blank lines.  Starting a new command.

scala> // read "=>" as "rocket"

scala> // Higher Order Functions

scala> //functions that you pass functions into

scala> // they can return functions

scala> // THE KEY IS TO PASS THE FUNCTION YOU WANT TO USE IN THE PARAMETER LIST OF THE HOF. 

scala> // YOU PASS IN THE FUNCTION AS LAMBDA EXPRESSION.

scala> // YOU CAN ALSO USE UNDERSCORES

scala> 

scala> 

scala> // Recursion

scala> // the function is written in such a way that it depends upon itself.

scala> // you keep moving towards the base case.

scala> // in such a way that you change the current return value. 

scala> // Note: in a recursive function you have to specify the return type!

scala> def factorial (n: Int) : Int = if (n<2) 1 else n*factorial(n-1)
factorial: (n: Int)Int

scala> // we have an if-expression that produces the different cases!

scala> factorial(5)
res5: Int = 120

scala> factorial(10)
res6: Int = 3628800

scala> factorial(16)
res7: Int = 2004189184

scala> factorial(17)
res8: Int = -288522240

scala> // this is where Ints are at their limit. 

scala> def factorial (n: Long) : Long = if (n< 2) 1 else n*factorial(n-1)
factorial: (n: Long)Long

scala> factorial(17)
res9: Long = 355687428096000

scala> // for very large numbers: use Long!!!!

scala> factorial(20)
res10: Long = 2432902008176640000

scala> factorial(30)
res11: Long = -8764578968847253504

scala> // now we should use BigInt:

scala> def factorial (n: BigInt) : BigInt = if (n<2) 1 else n*(n-1)
factorial: (n: BigInt)BigInt

scala> // the BigInt type can store any-size number!

scala> factorial(30)
res12: BigInt = 870

scala> factorial(30)
res13: BigInt = 870

scala> //oops! some external effect.... 

scala> def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSume(n-1)
<console>:11: error: not found: value squareSume
       def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSume(n-1)
                                                          ^
scala> def squareSum (n: Int) : Int = if (n<2) 1 else n*n+squareSum(n-1)
squareSum: (n: Int)Int

scala> squareSum(2)
res14: Int = 5

scala> squareSum(3)
res15: Int = 14

scala> squareSum(4)
res16: Int = 30

scala> squareSum(14)
res17: Int = 1015

scala> squareSum(140)
res18: Int = 924490

scala> def countDown (n:Int) : Unit = {
     | if (n>0) {
     | println(n)
     | countdown(n-1)
     | }
     | }
<console>:14: error: not found: value countdown
       countdown(n-1)
       ^

scala> def countDown (n:Int) : Unit = {
     | if (n>0) {
     | println(n)
     | countDown(n-1)
     | }
     | }
countDown: (n: Int)Unit

scala> countDown(10)
10
9
8
7
6
5
4
3
2
1

scala> def countFromTo (from: Int, to: Int) : Unit = {
     | if (from <= to) {
     | println(from)
     | countFromTo(from+1, to)
     | }
     | }
countFromTo: (from: Int, to: Int)Unit

scala> countFromTo(1,12_
<console>:1: error: Invalid literal number
       countFromTo(1,12_
                     ^

scala> countFromTo(1,12)
1
2
3
4
5
6
7
8
9
10
11
12



scala> 

_______________________ new REPL session _______________________________

scala> // Going through a program line by line in order to figure out what it is doing is called tracing

scala> // in case of sequential execution is easy.

scala> // tracing recursive functions is a little bit harder

scala> def fact (n:Int) :Int = if (n<2) 1 else n*fact(n-1)
fact: (n: Int)Int

scala> fact(5)
res3: Int = 120

scala> // a call on 5 takes us to 4 (there still is a "5*" waiting there to be executed. The callstack remembers where you are when you call functions, so when the function is done it returns to that point and does whatever is waiting there.   

scala> // the fact(4) is going to give a value to be multiplied with 5.

scala> // and so on. 

scala> // until we hit out base case.

scala> // so, the recursions are calling themselves going down the callstack, waiting and remembering values and the operations what need to be done, and the values are returned back-up to give us the end result. 

_______________________ new REPL session _______________________________

Tracing by Substitution: for pure functions (no prints, no reads, no assignments to vars) 

Example: 
def fact (n:Int) : Int = if (n<2) 1 else n*fact(n-1)

fact(5)
if (5<2) 1 else 5*fact(5-1)
5*fact(5-1)
5*fact(4)
5*(if(4<2) 1 else 4*fact(4-1))
5*(4*fact(4-1))
5*4*fact(3)
5*4*(if (3<2) 1 else 3*fact(3-1))
5*4*3*fact(2)
5*4*3* (if (2<2) 1 else 2*fact(1))
5*4*3*2*fact(1)
5*4*3*2* (if (1<2) 1 else 1*fact(0))
5*4*3*2*1

____________________________________________________________________

Recursion and User Input

scala> import io.StdIn._
import io.StdIn._

scala> def sum (n:Int) : Int = { 
     | if (n<1) 0
     | else {
     | val input = readInt
     | input + sum(n-1)
     | }
     | }
sum: (n: Int)Int

scala> sum(3)
res0: Int = 18

scala> // 5,6,7

scala> sum(3)
res1: Int = 16

scala> //5, 10, 1

scala> //you add up readInts

scala> 

scala> def sumPositive() : Int = {
     | val input = readInt
     | if(input >=0) {
     | input  + sumPositive()
     | } else 0
     | }
sumPositive: ()Int

scala> // when we call the function we are not passing anything because we only use the user input!! 

scala> sumPositive()
res2: Int = 9

scala> //8, 1,-1

scala> 

scala> // we don't pass any arguments,thus, we don't have something to count down towards the base case; our base case comes from the user input.

scala> def sumUntilQuit () : Int = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") 0
     | else input.toInt + sumUntilQuit()
     | }
sumUntilQuit: ()Int

scala> sumUntilQuit()
res3: Int = 15

scala> // 5,5,5, quit

scala> def sumAndCount () : (Int, Int) = {
     | val imput = readLine.toLowerCase.trim
     | if (input == "quit") (0.0)
     | else sumAndCount(input.toInt + sum, count +0)
     | }
<console>:17: error: not found: value input
       if (input == "quit") (0.0)
           ^
<console>:17: error: type mismatch;
 found   : Double(0.0)
 required: (Int, Int)
       if (input == "quit") (0.0)
                             ^
<console>:18: error: too many arguments for method sumAndCount: ()(Int, Int)
       else sumAndCount(input.toInt + sum, count +0)
                       ^

scala> //ok, it can't take any arguments. it can only have return values.

scala> //this is the trick by recursion with  user input. 

scala> def sumAndCount () : (Int, Int) = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") (0,0)
     | else {
     | val (sum, count) = sumAndCount()
     | (input.toInt + sum, count +1)
     | }
     | }
sumAndCount: ()(Int, Int)

scala> //so you assign the return values of sumAndCount() to some vals and then you add up user input to the sum accumulator and 1 to the count accumulator.

scala> sumAndCount()
res4: (Int, Int) = (4,2)

scala> // 1,3,quit

scala> val (s,c) = sumAndCount()
s: Int = 25
c: Int = 4

scala> println(s/4.toDouble)
6.25

scala> 

scala> //Abstracting Recursion

scala> def multAndCount () : (Int, Int) = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") (1,0) 
     | else {
     | val (prod, count) = multAndCount()
     | (input.toInt*prod, count +1)
     | }
     | }
multAndCount: ()(Int, Int)

scala> val (s,c) = multAndCount()
s: Int = 60
c: Int = 3

scala> // 2,6,5, quit

scala> // now we're going to write the HOF which can be used for both operations! 

scala> // the key is to ABSTRACT THE THINGS THAT CHANGE. These are the base and the operations done. 

scala> def inputAndCount (base: Int, op: (Int, Int) => Int) : (Int, Int) = {
     | val input = readLine.toLowerCase.trim
     | if (input == "quit") (base, 0)
     | else {
     | val (value, count) = inputAndCount(base, op)
     | ( op(input.toInt, value), count +1 )
     | }
     | }
inputAndCount: (base: Int, op: (Int, Int) => Int)(Int, Int)

scala> val (s,c) = inputAndCount(0, _ + _)
s: Int = 9
c: Int = 2

scala> val (s,c) = inputAndCount(1, _ * _)
s: Int = 30
c: Int = 2

scala> // for the minimum, the base value is some large value which cannot be the min.

scala> val (s,c) = inputAndCount( Int.MaxValue, _ min _)
s: Int = 3
c: Int = 7

scala> val (s,c) = inputAndCount( Int.MaxValue, _ min _)
s: Int = 2147483647
c: Int = 0

scala> // expr match { } inside we have cases of patterns.

scala> /* expr match {
     | case pattern1 => ...
     | case pattern2 => ...
     | ....
     | }
     | */
     | 
     | 
You typed two blank lines.  Starting a new command.

scala> 

scala> // expression -> returns a value; statement -> side effects

scala> // we can have as many cases we want. firstly, the expr is evaluated, then it compares the expr. to each of the patterns and the first pattern which matches is the one that will be used.

scala> // example: convert fact with match

scala> def fact2 (n:Int) : Int = n match {
     | case 0 => 1
     | case _ => n*fact2(n-1)
     | }
fact2: (n: Int)Int

scala> def countDown2 (n:Int) : Unit = n match {
     | case 0 =>    // we do nothing  
     | case _ => 
     | println(n)
     | countDown2(n-1)
     | }
countDown2: (n: Int)Unit

scala> countDown2(5)
5
4
3
2
1

scala> 
scala> (readInt, readInt) match {
     | case (0,0) => "zero, zero"
     | case (1,0) => "one, zero"
     | case (_, _) => "something, something"
     | case (1,1) => "one, one"
     | }
<console>:19: warning: unreachable code
       case (1,1) => "one, one"
                     ^
java.lang.NumberFormatException: For input string: ""
  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
  at java.lang.Integer.parseInt(Integer.java:592)
  at java.lang.Integer.parseInt(Integer.java:615)
  at scala.collection.immutable.StringLike$class.toInt(StringLike.scala:273)
  at scala.collection.immutable.StringOps.toInt(StringOps.scala:29)
  at scala.io.StdIn$class.readInt(StdIn.scala:110)
  at scala.io.StdIn$.readInt(StdIn.scala:229)
  ... 47 elided

scala> (readInt, readInt) match {
     | case (0,0) => "zero, zero"
     | case (1,0) => "one, zero"
     | case (1,1) => "one, one"
     | case (_, _) => "something, something"
     | }
res14: String = something, something

scala> def fizzBuzz (i: Int) : Unit = {
     | if ( i<=100) {
     | (i%3, i%5) match {
     | case (0,0) => "fizzbuzz"
     | case (0, _) => "fizz"
     | case (_, 0) => "buzz"
     | case _ => i
     | }
     | fizzBuzz(i+1)
     | }
     | }
fizzBuzz: (i: Int)Unit

scala> fizzBuzz(90)
fizzbuzz
91
92
fizz
94
buzz
fizz
97
98
fizz
buzz

scala> // The try/catch construct (used as expression or statement)

scala> val i = try {
     | readInt 
     | } catch {
     | case e: NumberFormatException => 0
     | }
i: Int = 8

scala> readInt
java.lang.NumberFormatException: For input string: "a"
  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
  at java.lang.Integer.parseInt(Integer.java:580)
  at java.lang.Integer.parseInt(Integer.java:615)
  at scala.collection.immutable.StringLike$class.toInt(StringLike.scala:273)
  at scala.collection.immutable.StringOps.toInt(StringOps.scala:29)
  at scala.io.StdIn$class.readInt(StdIn.scala:110)
  at scala.io.StdIn$.readInt(StdIn.scala:229)
  ... 42 elided

scala> 

scala> def safeReadInt :Int = {
     | try {
     | readInt
     | } catch {
     | case e: NumberFormatException => 
     | println ("This wasn's a valid input. Please try again.")
     | safeReadInt
     | }
     | }
safeReadInt: Int

scala> // this shows how you use recursion until you get an input which doesn't throws a NumberFormatException.

scala> safeReadInt
This wasn's a valid input. Please try again.
res21: Int = 8

scala> // this type of try/catch constructs catch possible exceptions which make a program crash. So, when you believe a possible exception might be caused by a wrong type you should use it. 


Arrays

scala> Array(3,4,4,6,7)
res22: Array[Int] = Array(3, 4, 4, 6, 7)

scala> Array[Double](3,4,4,6,7)
res23: Array[Double] = Array(3.0, 4.0, 4.0, 6.0, 7.0)

scala> val arr = re22
<console>:14: error: not found: value re22
       val arr = re22
                 ^

scala> val arr = res22
arr: Array[Int] = Array(3, 4, 4, 6, 7)

scala> arr.length
res24: Int = 5

scala> arr.size
res25: Int = 5

scala> // arrays are mutable!!!

scala> arr(2)
res26: Int = 4

scala> arr(2) = 99

scala> arr(2)
res28: Int = 99

scala> arr
res29: Array[Int] = Array(3, 4, 99, 6, 7)

scala> // the size cannot be modified, just its elements. If the size is modified, a new array is created.

scala> // In general we use arrays when we know upfront how many elements we will have in that array. 

scala> // Arrays Functions

scala> def setArray (arr: Array[Int], v:Int, i:Int) : Unit = {} // returns Unit because the only thing that it does is that it mutates the array.
setArray: (arr: Array[Int], v: Int, i: Int)Unit

scala> arr(100)
java.lang.ArrayIndexOutOfBoundsException: 100
  ... 42 elided

scala> def setArray (arr: Array[Int], v:Int, i:Int) : Unit = {
     | if (i < arr.length) {
     | arr(i) = v
     | setArray(arr, v, i+1)
     | }
     | }
setArray: (arr: Array[Int], v: Int, i: Int)Unit

scala> val arr2 = setArray(arr, 99, 0)
arr2: Unit = ()

scala> println (setArray(arr, 99, 0))
()

scala> setArray(arr, 99, 0)

scala> arr
res33: Array[Int] = Array(99, 99, 99, 99, 99)

_____________________ new REPL session _________________________________


Array functions 2
Combine the elements of an array (reduce)

scala> def operateOnArray( arr: Array[Int], i: Int, f: (Int, Int) => Int) : Int = {
     | if (i<arr.length -1) {
     | f( arr(i), operateOnArray(arr, i+1, f))
     | } else {
     | arr(i)
     | }
     | }
operateOnArray: (arr: Array[Int], i: Int, f: (Int, Int) => Int)Int

scala> val nums = Array(1,2,3,4,5,6)
nums: Array[Int] = Array(1, 2, 3, 4, 5, 6)

scala> operateOnArray(nums, 0, _+_)
res0: Int = 21

scala> // we used recursion and the index to move across the array. 

scala> operateOnArray(nums, 0, _*_)
res1: Int = 720

scala> 

scala> // Lists 

scala> //lists are immutable!!

scala> List(5,3,8,2)
res2: List[Int] = List(5, 3, 8, 2)

scala> //lists allow you to very efficiently add elements in front of them.

scala> val lst = List(6,8,3,5)
lst: List[Int] = List(6, 8, 3, 5)

scala> // cons operator prepends elements in front of the list:

scala> 1 :: lst
res3: List[Int] = List(1, 6, 8, 3, 5)

scala> // read as "one cons list"

scala> // our old list is still there, this created a new list

scala> // the list with no elements: Nil!

scala> Nil
res4: scala.collection.immutable.Nil.type = List()

scala> 1::2::3::4::Nil
res5: List[Int] = List(1, 2, 3, 4)

scala> // this is one way to create lists

scala> lst
res6: List[Int] = List(6, 8, 3, 5)

scala> lst(2)
res7: Int = 3

scala> // lists are immutable so we cannot update the values of elements

scala> lst(2) =99
<console>:13: error: value update is not a member of List[Int]
       lst(2) =99
       ^

scala> // exercise: function which builds up a list:

scala> import io.StdIn._
import io.StdIn._

scala> // lists work very well when you don't know how many elements the list will have:

scala> def inputList (n: Int) : List[Int] = {
     | if (n<1) Nil
     | else readInt :: inputList(n-1)
     | }
inputList: (n: Int)List[Int]

scala> val list2 = inputList(4)
list2: List[Int] = List(2, 4, 7, 6)

scala> // THE ARRAY IS BEST WHEN YOU DO KNOW HOW MANY THINGS YOU HAVE AND IT ALLOWS YOU TO MUTATE THEM.

scala> // LISTS WORK VERY WELL IF YOU DON'T KNOW HOW MANY INPUTS YOU HAVE (e.g. functions which work with quit).

scala> // Methods that we can call on Lists

scala> lst
res9: List[Int] = List(6, 8, 3, 5)

scala> lst.head
res10: Int = 6

scala> lst.tail
res11: List[Int] = List(8, 3, 5)

scala> def operateOnList (lst: List[Int], base: Int, f: (Int, Int) => Int) : Int = {
     | if (lst == Nil) base 
     | else f(lst.head, operateOnList(lst.tail, base, f))
     | }
operateOnList: (lst: List[Int], base: Int, f: (Int, Int) => Int)Int

scala> operateOnList(lst, 0, _ + _)
res12: Int = 22

scala> def operateOnList2 (lst : List[Int], base :Int, f: (Int, Int) => Int) : Int = lst match {
     | case Nil => base
     | case h :: t => f( h, operateOnList2(t, base, f))
     | }
operateOnList2: (lst: List[Int], base: Int, f: (Int, Int) => Int)Int

scala> operateOnList2(lst, 0, _ + _)
res13: Int = 22

scala> // if we need to express head and tail in the case pattern we use h::t (something cons something).

scala> // you can use head and tail to go through the recursion.

scala> // and pull a list apart.

scala> 

scala> Array.fill(10)(5)
res14: Array[Int] = Array(5, 5, 5, 5, 5, 5, 5, 5, 5, 5)

scala> val zeros = Array.fill(5)(0)
zeros: Array[Int] = Array(0, 0, 0, 0, 0)

scala> val ones = Array.fill(7)(1)
ones: Array[Int] = Array(1, 1, 1, 1, 1, 1, 1)

scala> val randomArr = Array.fill(10)(Math.random)
randomArr: Array[Double] = Array(0.3840458302727937, 0.18531876116607027, 0.40188798438581586, 0.8813083321922234, 0.8483406976447233, 0.23323373087375598, 0.769075009059168, 0.7098601334456789, 0.7922765871511024, 0.6774729303710884)

scala> // the second argument of Array.fill()() is PASSED BY VALUE!

scala> // PASSED BY NAME AND PASSED BY VALUE

scala> // when it's passed by name it's not evaluated until it's needed.

scala> // when it's passed by value it's evaluated over and over again every time it is used.

scala> var i = 0
i: Int = 0

scala> Array.fill(10)({i += 1; i})
res15: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> // the power of the Array.fill method is that whatever you pass in the second argument list is evaluated however many times you do this (the code happens 10 times -> the i value goes from 0 to 10)

scala> Array.fill(5)(readInt)
res16: Array[Int] = Array(6, 4, 8, 9, 10)

scala> 

scala> // The tabulate Method

scala> // the second argument that is used is not a passed by value argument but actually a function.

scala> // you can apply the function based upon the index within the array.

scala> Array.tabulate(10)(i => i)
res17: Array[Int] = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> Array.tabulate(10)(i => i+1)
res18: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> Array.tabulate(10)(i => i*3)
res19: Array[Int] = Array(0, 3, 6, 9, 12, 15, 18, 21, 24, 27)

scala> Array.tabulate(10)(_*3)
res20: Array[Int] = Array(0, 3, 6, 9, 12, 15, 18, 21, 24, 27)

scala> Array.tabulate(10)(i => 1)
res21: Array[Int] = Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)

scala> Array.tabulate(10)(i => Math.random)
res22: Array[Double] = Array(0.20191398398631388, 0.6265324706044582, 0.48655836432577704, 0.7116700805114097, 0.6609740626109651, 0.19503212412721582, 0.22931306287334907, 0.7324552123193775, 0.01191449330197314, 0.6359747030068716)

scala> Array.tabulate(10)(i => 0)
res23: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

scala> Array.tabulate(10)(i => 7)
res24: Array[Int] = Array(7, 7, 7, 7, 7, 7, 7, 7, 7, 7)

scala> 

scala> // Collection Methods

scala> 

scala> // slicing

scala> // drop -> drops off that many elements given in the argument:

scala> val a = Array(5,2,9,3,1,8,6)
a: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.drop(2)
res25: Array[Int] = Array(9, 3, 1, 8, 6)

scala> // Drop drops elements from left!

scala> a.init
res26: Array[Int] = Array(5, 2, 9, 3, 1, 8)

scala> // init leaves out the last element

scala> a.last
res27: Int = 6

scala> a.slice(2,4)
res28: Array[Int] = Array(9, 3)

scala> // slice is inclusive on the first index and exclusive on the second index.

scala> a.splitAt(3)
res29: (Array[Int], Array[Int]) = (Array(5, 2, 9),Array(3, 1, 8, 6))

scala> // with splitAt I get a tuple of two arrays. 

scala> // the argument indicates how many values go into the first collection. 

scala> a.take(3)
res30: Array[Int] = Array(5, 2, 9)

scala> // take the first 3 elements

scala> a
res31: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.dropRight(3)
res32: Array[Int] = Array(5, 2, 9, 3)

scala> // drops off the last 3 elements

scala> a.takeRight(3)
res33: Array[Int] = Array(1, 8, 6)

scala> // takeRight gives you the last 3 elements

scala> 

scala> // Methods that do Boolean tests and searching inside collections

scala> 

scala> a
res34: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.contains(3)
res35: Boolean = true

scala> a.contains(99)
res36: Boolean = false

scala> a.endsWith(Array(1,8,6))
res37: Boolean = true

scala> a.endsWith(Array(1,8,4))
res38: Boolean = false

scala> a.endsWith(List(1,8,6))
res39: Boolean = true

scala> a.isEmpty
res40: Boolean = false

scala> a.nonEmpty
res41: Boolean = true

scala> a.startsWith((Array(5,2,9))
     | )
res42: Boolean = true

scala> a.indexOf(9)
res43: Int = 2

scala> a.indexOf(99)
res44: Int = -1

scala> //returns a -1 when the element is not found.

scala> a.lastIndexOf(1)
res45: Int = 4

scala> a.indexOf(1,5)
res46: Int = -1

scala> // finding ones starting with index 5

 
scala> 

scala> // Multiset difference:

scala> a
res47: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.diff(Array(2,9,6,8))
res48: Array[Int] = Array(5, 3, 1)

scala> // finds the elements present in a and not present in the other collection.

scala> a.diff(Array(2,7,6,8))
res49: Array[Int] = Array(5, 9, 3, 1)

scala> a.distinct
res50: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> // gives back a collection with no duplicates in it.

scala> Array(1,1,1,6,5,5,7,7,72,3,1).distinct
res51: Array[Int] = Array(1, 6, 5, 7, 72, 3)

scala> println(a)
[I@5572d111

scala> a.mkString
res53: String = 5293186

scala> a.mkString(",")
res54: String = 5,2,9,3,1,8,6

scala> a.mkString("(",",", ")"))
<console>:1: error: ';' expected but ')' found.
a.mkString("(",",", ")"))
                        ^

scala> a.mkString("(",",", ")")
res55: String = (5,2,9,3,1,8,6)

scala> a
res56: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> // take some subset from an array and replace it with something else

scala> a.patch(2,Nil, 3)
res57: Array[Int] = Array(5, 2, 8, 6)

scala> // removing with Nil

scala> a.patch(2,Array(77,88,99), 3)
res58: Array[Int] = Array(5, 2, 77, 88, 99, 8, 6)

scala> // patch(location, what you put in that place, how many things you want to replace)

scala> a.reverse
res59: Array[Int] = Array(6, 8, 1, 3, 9, 2, 5)

scala> a.toList
res60: List[Int] = List(5, 2, 9, 3, 1, 8, 6)

scala> res60.toArray
res61: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> // zip 

scala> val lst2 = List("one", "two", "three", "four")
lst2: List[String] = List(one, two, three, four)

scala> a.zip(lst2)
res62: Array[(Int, String)] = Array((5,one), (2,two), (9,three), (3,four))

scala> // WHEN ONE COLLECTION ENDS, THEN THE zip METHOD ENDS!

scala> // zip pairs together the two collections in form of tuples.

scala> lst2.zip(a)
res63: List[(String, Int)] = List((one,5), (two,2), (three,9), (four,3))

scala> // it takes over the type of the first argument!!!

scala> a.zipWithIndex
res64: Array[(Int, Int)] = Array((5,0), (2,1), (9,2), (3,3), (1,4), (8,5), (6,6))

scala> lst2.zipWithIndex
res65: List[(String, Int)] = List((one,0), (two,1), (three,2), (four,3))

scala> a.min
res66: Int = 1

scala> lst2.min
res67: String = four

scala> a.max
res68: Int = 9

scala> a.sum
res69: Int = 34

scala> lst.sum
res70: Int = 22

scala> lst2.sum
<console>:19: error: could not find implicit value for parameter num: Numeric[String]
       lst2.sum
            ^

scala> a.product
res72: Int = 12960

scala> // min, max, sum , product for NUMERIC VALUES!!

scala> a.sum/a.length
res73: Int = 4

scala> a.sum/a.length.toDoub
<console>:19: error: value toDoub is not a member of Int
       a.sum/a.length.toDoub
                      ^

scala> a.sum/a.length.toDouble
res75: Double = 4.857142857142857

scala> 

scala> // HIGHER-ORDER METHODS (map and filter)

scala>

scala> a
res76: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.map(_ *2)
res77: Array[Int] = Array(10, 4, 18, 6, 2, 16, 12)

scala> //map returns a new collection

scala> a.map(_ * _)
<console>:19: error: missing parameter type for expanded function ((x$1, x$2) => x$1.$times(x$2))
       a.map(_ * _)
             ^
<console>:19: error: missing parameter type for expanded function ((x$1: <error>, x$2) => x$1.$times(x$2))
       a.map(_ * _)
                 ^

scala> a.map(_ /0.5)
res79: Array[Double] = Array(10.0, 4.0, 18.0, 6.0, 2.0, 16.0, 12.0)

scala> 

scala> // filter: passes in a predicate to filter 

scala> a.filter( i => i%2 ==1)
res80: Array[Int] = Array(5, 9, 3, 1)

scala> a.filter( i => i%2 ==1).map(_ *2)
res81: Array[Int] = Array(10, 18, 6, 2)

scala> 

scala> a.count( _%2 ==0)
res82: Int = 3

scala> a.dropWhile(_<9)
res83: Array[Int] = Array(9, 3, 1, 8, 6)

scala> // dropWhile drops things until it meets a 9 and is less than 9

scala> a.dropWhile(_<1)
res84: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.dropWhile(_ >1)
res85: Array[Int] = Array(1, 8, 6)

scala> a.exists(_ %7 ==0)
res86: Boolean = false

scala> a.exists(_ %4 ==0)
res87: Boolean = true

scala> 

scala> //flatmap

scala> val arr3 = Array(Array(1,2,3,4), Array(5,6,7,8))
arr3: Array[Array[Int]] = Array(Array(1, 2, 3, 4), Array(5, 6, 7, 8))

scala> arr3.flatMap(i=> i)
res90: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8)

scala> a.forall(_< 7)
res98: Boolean = false

scala> a.forall(_< 70)
res99: Boolean = true

scala> a.foreach(println)
5
2
9
3
1
8
6

scala> //foreach more for sife effects

scala> a.indexWhere(_ % 2 == 0)
res101: Int = 1

scala> a
res102: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)


scala> // find the index where some predicate is satisfied

scala> a.indexWhere( _ == 8)
res103: Int = 5

scala> //does the same thing as indexOf!

scala> a.lastIndexWhere(_ ==8)
res104: Int = 5

scala> a.lastIndexWhere( _ %3 ==0)
res105: Int = 6

scala> a.partition( _ %2==0)
res106: (Array[Int], Array[Int]) = (Array(2, 8, 6),Array(5, 9, 3, 1))

scala> // partition returns a tuple of two collections: the first which satisfies a predicate and the second with elements which don't satisfy a predicate.

scala> val (evens, odds) = a.partition(_%2 ==0)
evens: Array[Int] = Array(2, 8, 6)
odds: Array[Int] = Array(5, 9, 3, 1)

scala> //takeWhile

scala> a.takeWhile(_ %3 !=0)
res107: Array[Int] = Array(5, 2)

scala> a
res108: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> 

scala> // reduce and fold

scala> 

scala> a.reduceLeft(_ + _)
res109: Int = 34

scala> a.sum
res110: Int = 34

scala> a.reduceLeft((a,b) => {println(a+","+b); a+b})
5,2
7,9
16,3
19,1
20,8
28,6
res111: Int = 34

scala> a
res112: Array[Int] = Array(5, 2, 9, 3, 1, 8, 6)

scala> a.reduceRight((a,b) => {println(a+","+b); a+b})
8,6
1,14
3,15
9,18
2,27
5,29
res113: Int = 34

scala> a.reduceLeft((a,b) => {println(a+","+b); a-b})
5,2
3,9
-6,3
-9,1
-10,8
-18,6
res114: Int = -24

scala> a.reduceRight((a,b) => {println(a+","+b); a-b})
8,6
1,2
3,-1
9,4
2,5
5,-3
res115: Int = 8

scala> // depending on the operation we do, the reduceRight and reduceLeft might deliver different results.

scala> 

scala> // fold -> for more flexibility regarding types used

scala> a.foldLeft(0)(_ + _) //tekes two arguments: 1st is the accumulator and the 2nd is the function used in folding
res116: Int = 34

scala> a.foldLeft("")(_+_)
res117: String = 5293186

scala> //concatencates values to string.

scala> a.foldLeft("")(_+_+",")
res118: String = 5,2,9,3,1,8,6,

scala> // reduceLeft takes a function with two arguments!

scala> // foldLeft takes two lists of parameters: acc and function with two param.

scala> 

scala> // Combinatorial/Iterator Methods

scala> 

scala> var i = 0
i: Int = 0

scala> val nums = Array.fill(5)({i+=1;i})
nums: Array[Int] = Array(1, 2, 3, 4, 5)

An iterator is much like a collection, except that as you go through the values they are consumed. The advantage is that large collections don't consume that much memory.  

scala> nums.combinations(3)
res0: Iterator[Array[Int]] = non-empty iterator

scala> //an iterator of arrays

scala> //you don't want to create all those combinations at once and fill the memory of the computer

scala> //we can go through them one at the time and throw them away  when we are done. 

scala> nums.combinations(3).foreach(println)
[I@567387f0
[I@62cf019b
[I@d440e4b
[I@17a8f94a
[I@5d2eb048
[I@4777b1af
[I@6aecd95c
[I@3ade0fe2
[I@12da4401
[I@68da753c

scala> nums.combinations(3).foreach( a => println(a.mkString(",") )
     | )
1,2,3
1,2,4
1,2,5
1,3,4
1,3,5
1,4,5
2,3,4
2,3,5
2,4,5
3,4,5

scala> res0
res3: Iterator[Array[Int]] = non-empty iterator

scala> res0.next
res4: Array[Int] = Array(1, 2, 3)

scala> res0.next
res5: Array[Int] = Array(1, 2, 4)

scala> res0.next
res6: Array[Int] = Array(1, 2, 5)

scala> res0.next
res7: Array[Int] = Array(1, 3, 4)

scala> res0.next
res8: Array[Int] = Array(1, 3, 5)

scala> res0.next
res9: Array[Int] = Array(1, 4, 5)

scala> res0.next
res10: Array[Int] = Array(2, 3, 4)

scala> res0.next
res11: Array[Int] = Array(2, 3, 5)

scala> res0.next
res12: Array[Int] = Array(2, 4, 5)

scala> res0.next
res13: Array[Int] = Array(3, 4, 5)

scala> res0.next
java.util.NoSuchElementException: next on empty iterator
  at scala.collection.Iterator$$anon$2.next(Iterator.scala:39)
  at scala.collection.Iterator$$anon$2.next(Iterator.scala:37)
  at scala.collection.SeqLike$CombinationsItr.next(SeqLike.scala:219)
  ... 42 elided

scala> res0.hasNext
res15: Boolean = false

scala> // -> the combinations method give back an iterator

scala> // Another method that gives back an iterator is grouped.

scala> Array.tabulate(15)(i=>i)
res16: Array[Int] = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)

scala> Array.tabulate(15)(i=>i).grouped(3)
res17: Iterator[Array[Int]] = non-empty iterator

scala> Array.tabulate(15)(i=>i).grouped(3).foreach( a => println( a.mkString(",")))
0,1,2
3,4,5
6,7,8
9,10,11
12,13,14

scala> Array.tabulate(15)(i=>i).grouped(4).foreach( a => println( a.mkString(",")))
0,1,2,3
4,5,6,7
8,9,10,11
12,13,14

scala> // the inits method returns an interator and the iterator is all of the initial calls that you would get if you were to go through the collection.

scala> nums.init
res20: Array[Int] = Array(1, 2, 3, 4)

scala> nums.inits
res21: Iterator[Array[Int]] = non-empty iterator

scala> nums.inits.foreach( a => println( a.mkString(",")))
1,2,3,4,5
1,2,3,4
1,2,3
1,2
1


scala> nums.init
res23: Array[Int] = Array(1, 2, 3, 4)

scala> nums.permutations.foreach( a => println( a.mkString(",")))
1,2,3,4,5
1,2,3,5,4
1,2,4,3,5
1,2,4,5,3
1,2,5,3,4
1,2,5,4,3
1,3,2,4,5
1,3,2,5,4
1,3,4,2,5
1,3,4,5,2
1,3,5,2,4
1,3,5,4,2
1,4,2,3,5
1,4,2,5,3
1,4,3,2,5
1,4,3,5,2
1,4,5,2,3
1,4,5,3,2
1,5,2,3,4
1,5,2,4,3
1,5,3,2,4
1,5,3,4,2
1,5,4,2,3
1,5,4,3,2
2,1,3,4,5
2,1,3,5,4
2,1,4,3,5
2,1,4,5,3
2,1,5,3,4
2,1,5,4,3
2,3,1,4,5
2,3,1,5,4
2,3,4,1,5
2,3,4,5,1
2,3,5,1,4
2,3,5,4,1
2,4,1,3,5
2,4,1,5,3
2,4,3,1,5
2,4,3,5,1
2,4,5,1,3
2,4,5,3,1
2,5,1,3,4
2,5,1,4,3
2,5,3,1,4
2,5,3,4,1
2,5,4,1,3
2,5,4,3,1
3,1,2,4,5
3,1,2,5,4
3,1,4,2,5
3,1,4,5,2
3,1,5,2,4
3,1,5,4,2
3,2,1,4,5
3,2,1,5,4
3,2,4,1,5
3,2,4,5,1
3,2,5,1,4
3,2,5,4,1
3,4,1,2,5
3,4,1,5,2
3,4,2,1,5
3,4,2,5,1
3,4,5,1,2
3,4,5,2,1
3,5,1,2,4
3,5,1,4,2
3,5,2,1,4
3,5,2,4,1
3,5,4,1,2
3,5,4,2,1
4,1,2,3,5
4,1,2,5,3
4,1,3,2,5
4,1,3,5,2
4,1,5,2,3
4,1,5,3,2
4,2,1,3,5
4,2,1,5,3
4,2,3,1,5
4,2,3,5,1
4,2,5,1,3
4,2,5,3,1
4,3,1,2,5
4,3,1,5,2
4,3,2,1,5
4,3,2,5,1
4,3,5,1,2
4,3,5,2,1
4,5,1,2,3
4,5,1,3,2
4,5,2,1,3
4,5,2,3,1
4,5,3,1,2
4,5,3,2,1
5,1,2,3,4
5,1,2,4,3
5,1,3,2,4
5,1,3,4,2
5,1,4,2,3
5,1,4,3,2
5,2,1,3,4
5,2,1,4,3
5,2,3,1,4
5,2,3,4,1
5,2,4,1,3
5,2,4,3,1
5,3,1,2,4
5,3,1,4,2
5,3,2,1,4
5,3,2,4,1
5,3,4,1,2
5,3,4,2,1
5,4,1,2,3
5,4,1,3,2
5,4,2,1,3
5,4,2,3,1
5,4,3,1,2
5,4,3,2,1

scala> nums.sliding(3).foreach( a => println( a.mkString(",")))
1,2,3
2,3,4
3,4,5

scala> // groups of 3 but each one has an overleaf

scala> // groups of 3 but each one has an overleft

scala> // sliding advances one element at the time

scala> // is like a frame that slides down through our collection and the frame is of size 3.

scala> //running window 

scala> nums.tails.foreach( a => println( a.mkString(",")))
1,2,3,4,5
2,3,4,5
3,4,5
4,5
5


scala> // returns all possible tails after moving across the collection

scala> nums.tails.toList
res27: List[Array[Int]] = List(Array(1, 2, 3, 4, 5), Array(2, 3, 4, 5), Array(3, 4, 5), Array(4, 5), Array(5), Array())

scala> 

scala> // different useful methods like permutations, combinations. 

scala> 

scala> "1 2 3 4 5".split(" ").map(_.toInt)
res28: Array[Int] = Array(1, 2, 3, 4, 5)

scala> 

 
scala> // collections give us the ability to store and manipulate large amounts of data.


Playing with data:
- create arrays with Array.fill(34009)(readline) SUPER TIP!!!
- then filter the arrays on different variables (like year or gender or name).
- then map through the elements of those new subsets and extract information with counting the occurences and finding max or min values, etc.. 


_____________________ new REPL session ________________________________

The Option Type

- represents something that may or may not have a value
- it's used broadly so that the type system can help you find errors. If something doesn't have a value instead of causing an error, you are forced to deal with it.

Using the find method (for lists and arrays and passes a predicate) to give an example of Option use:

scala> val lst = List(1,2,3,4,5)
lst: List[Int] = List(1, 2, 3, 4, 5)

scala> lst.find(_ >6)
res0: Option[Int] = None

scala> // the Option type can either be None or Some.

scala> lst.find(_ >3)
res1: Option[Int] = Some(4)

scala> lst.find(_ >3).get
res2: Int = 4

scala> // use get to access the value

scala> lst.find(_>6).get
java.util.NoSuchElementException: None.get
  at scala.None$.get(Option.scala:347)
  at scala.None$.get(Option.scala:345)
  ... 42 elided

scala> // in the case of None, get throws an error!!!

scala> // you can get the value or you have a default for the case when you have such an error.

scala> // for this there is the getOrELse method.

scala> lst.find(_ > 3).getOrElse(0)
res4: Int = 4

scala> lst.find(_ > 6).getOrElse(0)
res5: Int = 0

scala> // getOrElse sets the default value for false cases.

scala> // You can safely use getOrElse for many cases to get the value for Some or get some default value for None. 

scala> // You can also use map and flatmap (which are defined also for Option)

scala> lst.find(_ > 6).map(_*2)
res6: Option[Int] = None

scala> lst.find(_ > 3).map(_*2)
res7: Option[Int] = Some(8)

scala> // map functions like in the normal case for arrays and lists if there is a Some, or returns a None for the case of a missing value (i.e. None).

scala> // You can also use match:

scala> lst.find(_ >3) match {
     | case Some(n) => n*5
     | case None => 0
     | }
res8: Int = 20

scala> // You can also work with if:

scala> val result = lst.find(_>3)
result: Option[Int] = Some(4)

scala> if(result.nonEmpty) result.get*5 else 0
res9: Int = 20

scala> // Parametric functions

scala> def ident[A](o:A):A = o
ident: [A](o: A)A

scala> ident(1)
res10: Int = 1

scala> ident(1.0)
res11: Double = 1.0

scala> // type abstraction

scala> def makeTuple[A,B] (a:A, b:B):(A,B) = (a,b)
makeTuple: [A, B](a: A, b: B)(A, B)

scala> makeTuple(1,2.2)
res12: (Int, Double) = (1,2.2)

scala> makeTuple(0.1, 1.4)
res13: (Double, Double) = (0.1,1.4)

scala> def threeList[A] (a1:A, a2:A, a3:A) : List[A] = List(a1,a2,a3)
threeList: [A](a1: A, a2: A, a3: A)List[A]

scala> threeList(1,2,3)
res14: List[Int] = List(1, 2, 3)

scala> threeList(1.0,2.0,3.0)
res15: List[Double] = List(1.0, 2.0, 3.0)

scala> def ourFold [A, B] (lst:List[A], base:B) (f:(A,B)=> B) :B =lst match {
     | case Nil => base
     | case h::t => f(h, ourFold(t, base)(f))
     | }
ourFold: [A, B](lst: List[A], base: B)(f: (A, B) => B)B

scala> ourFold(List(1,2,3,4,5), 0)(_ + _)
res17: Int = 15

scala> 

scala> // Subtyping

scala> 

scala> // one type can be a subtype of another. You can use the subtype in any place where a supertype is needed. 

scala> List(5, true)
res18: List[AnyVal] = List(5, true)

scala> // scala chooses a type that is above both!

scala> List("hi", Some(5))
res19: List[java.io.Serializable] = List(hi, Some(5))

scala> List("hi", List(2,3))
res20: List[java.io.Serializable] = List(hi, List(2, 3))

scala> List("hi",2,3)
res21: List[Any] = List(hi, 2, 3)

scala> // Null is a subtype of everything under AnyRef

scala> // we try to avoid it! 

scala> // type Nothing. Under everything

scala> // Nothing has no value. You cannot make anything of type Nothing.

scala> List()
res22: List[Nothing] = List()

scala> // we can build it up with everything that's above it!!!

scala> 

scala> // Variable no. of arguments! (varargs)

scala> 

scala> def average (n:Double*) : Double = if (n.length>0) n.sum/n.length else 0
average: (n: Double*)Double

scala> average(1,2,3)
res23: Double = 2.0

scala> val nums = List(94.0, 95, 97, 99)
nums: List[Double] = List(94.0, 95.0, 97.0, 99.0)

scala> average(nums:_*)
res24: Double = 96.25

scala> 

scala> // Mutability and Aliasing

scala> 

scala> // mutable types can also imply aliasing.

scala> 

_____________________ new REPL session _____________________________


Currying

- several argument lists
- having a function that returns a function (the idea is that you can partially apply these functions)
- example: def add(x: Int) : Int => Int = y => x+y

    










 










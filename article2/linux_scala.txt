desired journal: IEEE Computing in Science and Engineering
author: Roxana Tesileanu, roxana.te@web.de
affiliation: INCDS, Brasov Station
date: september 2017


Using Linux as a Development Platform for Scala Projects

1. Introduction

In order to implement software development projects, one should consider which tools to choose for the different components of the development system, which according to Rehman and Paul (2003) are the following: the hardware platform, the operating system, editors, compilers and assemblers, debuggers, version control system and bug tracking (Tesileanu 2017). For implementing Scala projects, working with the Simple Build Tool (SBT) (http://www.scala-sbt.org) condenses the list of the components of a development system, as it unites different steps in one tool (compiling, building, testing and debugging) (see Suereth and Farwell, 2016). Another advantage of using SBT is the opportunity of working interactively in Scala REPL, a tool for evaluating expressions in Scala (https://docs.scala-lang.org/overviews/repl/overview.html) within a SBT session, to develop bits of code which can then be inserted in the editor of choice.  

It is also important to understand that software development "is not just writing code", but rather a more comprehensive process (Rehman and Paul, 2003). Rehman and Paul (2003) describe it as comprising the following steps: requirement gathering, writing functional specifications, creating architecture and design documents, implementation and coding, testing and quality assurance, software release, documentation, and, support and development and release of new features. Each project starts with a requirement analysis which investigates the real-world need of the final product. Which functions should the new software carry in real-world problem solving within the specified domain? Further, functional specifications are declared to state the functionality of a software product at an abstract level "defining its input/output behavior". On the basis of the functional specifications, an architecture of the product is created. The architecture "defines the different components of the product and how they interact with each other", without providing the explicit details on how they should be implemented to reach the desired functionality. This happens at the design stage, when design documents are created which define each individual component to the level of functions and procedures. Using the design documents and development tools (SBT and editor) the code is then implemented and tested. There are more types of testing: unit testing (testing one part or one component of the product using test cases to test functionality of this part of the software), sanity testing to check if all components compile, regression or stress testing to check the long-term behavior of the product when used continuously over a period of time, and functional testing using test cases built on functional specifications. If a bug (an anomaly) is found it must be reported and fixed. The documentation includes: technical documentation developed during the development process, technical documentation prepared for technical support staff, and end-user manuals and guides. Finally, the last stage of the life cycle of a software development project is the support and release of new versions depending on requirements.       

The present article aims at introducing the reader to the tools needed to put in motion the development system of Scala projects on Linux, with emphasis on the Ubuntu distribution. The following sections will cover brief introductions in using the VIM editor as an editor for Scala code and using SBT to create and manage Scala projects.

2. Using VIM as an editor for Scala code

VIM is an editor which can be used from within the Linux command line and can be adapted to support the editing of Scala code by installing the vim-scala package of Derek Wyatt found at https://github.com/derekwyatt/vim-scala. 
Under Linux you can install VIM using the package tools at hand (like e.g. dphg, apt-get, aptitude, rpm or yum) depending on the installed distribution. In Ubuntu the command for installing VIM is: “$ sudo apt install vim”. Afterwards, you open the command line and launch VIM by typing “$ vim <ENTER>”. The following instructions will make the first VIM session easy to pass through:
- because VIM starts in command mode you can change to insert mode with the "i" key
- to exit insert mode and return to command mode, press the <ESC> key
- to write the open file to the hard drive use ":w" in command mode
- to save the changes type ":" in command mode
- to exit VIM type ":wq" to quit and save changes, or ":q!" to discard changes (both in command mode)
- pressing <ESC> will not just place you in command mode but also cancel an unwanted and partially completed command in command mode.

The following paragraphs will help you navigate through the VIM file, and, process text (append, delete, copy, paste, search and replace, edit multiple files and get help). 

To move the cursor you use: "l" (or right arrow), "h" (or left arrow), "j" (meaning going down one line), or "k" (meaning going up one line). Moving inside the current line is possible with "0" (to go to the beginning of the current line) and "$" (to go to the end of the current line). To go to the end of the file, i.e. to the last line of the file you use "G" and to go to the beginning of the file, i.e. to the first line you use "gg". To go to a specific line you use "numberG" (for example: 2G to go the the second line).

When you are in command mode, you can start inserting text by using the "i" key to place you in insert mode, but there are also other commands which can place you in insert mode so that you can start appending text. One of them is the "a" key, which lets you append text right at the spot where the cursor is placed, or the "A" key which lets you append text directly at the end of the line. You can also use the "o" key to open a line below the current line or "O" to open a line above the current line. 

You can undo changes by using the "u" key and redo changes the using "<CTRL>r".
   
Deleting text in command mode goes with (but not only) the following commands:
- the "x" key deleted the current character; "3x" will delete the current character and the next two characters
- the "dd" command deletes the current line; "6dd" will delete the current line and the next five lines
- the "dG" command will deleted to the end of the file
- the "d$" command will delete to the end of the line
- the "d0" command will delete to the beginning of the line.

The commnads based on "d" nut just delete text but also copy it to a paste baffer, which can be later recalled with the "p" command to paste the contents of the buffer after the cursor or the "P" command to paste the contents of the buffer before the cursor.

Cutting, copying and pasting text is done more traditionally with the "y" command (which stands for "yank", i.e. copy). To copy the current line you use "yy" ("6yy" means copy the current line and the next five lines). To copy to the end of the line use "y$" and to the beginning of the line use "y0". You can join lines with "J".

Searching and replacing is done within the line and within the whole file. Searching within the line is done with "f" (for example "fa" will move the cursor to the next occurence of "a"). You can also use the substitute command for a line (for example: while in command mode "s:caar/car<ENTER>" means substitute "caar" with "car", and replaces the first occurence of the searched word). The ":#,#s/big/small/g" replaces "big" with "small" within a range of lines. 
To search the entire file use "/" followed by the searched word and the <ENTER> key. You can go to the next occurrence of the searched word with the "n" (from "next") command. 



3. Using SBT to create and manage Scala projects
3.1 Installing SBT
3.2 Creating a Scala project
3.3 Some basic SBT tasks


   
4. Conclusion
 


 





Biography:

Roxana Tesileanu graduated Forestry and Environmental Sciences (Dipl. Forstwirtin, the German equivalent to BSc plus MSc in Forestry) in 2008 at Albert-Ludwigs-Universitaet in Freiburg i. Br., Germany, worked as project team member in more international projects (at WSL and Agroscope in Switzerland), and since 2014  as research assistant at INCDS Romania. She is specialized in soil chemistry, environmental statistics and bioinformatics.



Bibliography:

1. Rafeeq Ur Rehman and Christopher Paul. The Linux Development Platform. Pearson, 2003.

2. Roxana Tesileanu. Introduction to Statistical Computing in Scala - an Implementation of the K-Nearest Neighbors Classifier. IEEE Transactions on Neural Networks and Learning Systems. Submitted, under review, 2017.

3. Joshua Suereth and Matthew Farwell. SBT in action: the Simple Scala Build Tool. Manning Publications Co., Shelter Island. 2016


